<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>User Profile</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- These can 404/MIME-mismatch; this page won't depend on them. -->
    <link rel="stylesheet" href="/web/site.css">
    <link rel="stylesheet" href="/web/user-profile.css?v=dev">

    <style id="user-view-theme">
        :root {
            color-scheme: dark;
            /* neutral, grayscale-only palette */
            --bg: #0a0b0d;
            --bg-2: #0c0e12;
            --panel: #0e1116; /* card base */
            --panel-2: #12161c; /* card top for gradient */

            --text: #f2f2f2;
            --muted: #b3b3b3;
            --primary: #ffffff; /* links/buttons stay white */
            --border: #e6e6e6; /* soft white border */
            --border-soft: rgba(255,255,255,.14); /* inner separators */

            --bw: 2px; /* border thickness */
        }

        * {
            box-sizing: border-box;
        }

        body.theme-editor {
            margin: 0;
            font-family: 'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
            color: var(--text) !important;
            background: radial-gradient(1200px 800px at 20% -10%, #111214 0%, #0a0b0d 45%, #08090b 100%), linear-gradient(180deg, #0a0b0d, #0a0b0d);
        }

        .container {
            max-width: 980px;
            margin: 24px auto;
            padding: 0 16px;
        }

        header {
            display: flex;
            align-items: center;
            gap: 18px;
            margin-bottom: 20px;
        }

        /* Avatar: circular border as requested */
        .avatar {
            width: 88px;
            height: 88px;
            flex: 0 0 auto;
            background: #0b0c0f;
            border: var(--bw) solid #fff;
            border-radius: 50%;
            overflow: hidden;
            display: grid;
            place-items: center;
            box-shadow: 0 0 0 1px var(--border-soft) inset;
        }

            .avatar img {
                max-width: 100%;
                max-height: 100%;
                display: block;
            }

        .title h1 {
            margin: 0 0 6px;
            font-weight: 700;
            font-size: 22px;
        }

        .title .muted {
            color: var(--muted);
            font-size: 14px;
        }

        /* Card/grid */
        .card {
            background: linear-gradient(180deg, var(--panel-2), var(--panel));
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 16px;
            box-shadow: 0 1px 0 var(--border-soft) inset, 0 8px 18px rgba(0,0,0,.35);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* Buttons */
        .btn, button {
            appearance: none;
            background: #0c0e12;
            color: #fff;
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 10px 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 1px 0 var(--border-soft) inset;
            transition: background-color .12s ease, color .12s ease, border-color .12s ease;
        }

            .btn.primary, button.primary {
                background: #0f1216;
                border-color: #fff;
                color: #fff;
            }

            .btn:hover, button:hover {
                background: #12151a;
            }

            .btn.is-active {
                box-shadow: 0 0 0 var(--bw) rgba(255,255,255,.18) inset;
            }

            .btn.is-down {
                box-shadow: 0 0 0 var(--bw) rgba(255,255,255,.10) inset;
            }

        a.btn, a.btn:hover, a.btn:focus, a.btn:active {
            text-decoration: none !important;
        }

        .btn:hover, button:hover {
            background: #fff !important;
            color: #000 !important;
            border-color: #fff !important;
        }

        .btn:active, button:active {
            background: #0c0e12 !important;
            color: #fff !important;
            border-color: var(--border) !important;
        }

        .btn.primary:active, button.primary:active {
            background: #0f1216 !important;
            color: #fff !important;
            border-color: #fff !important;
        }

        /* vote-state colors */
        :root {
            --vote-like-bg: #ffffff;
            --vote-like-fg: #000000;
            --vote-dislike-bg: #e6e6e6;
            --vote-dislike-fg: #000000;
        }

        .btn.is-active {
            background: var(--vote-like-bg) !important;
            color: var(--vote-like-fg) !important;
            border-color: #fff !important;
        }

        .btn.is-down {
            background: var(--vote-dislike-bg) !important;
            color: var(--vote-dislike-fg) !important;
            border-color: #fff !important;
        }

            .btn.is-active:hover,
            .btn.is-active:focus-visible,
            .btn.is-down:hover,
            .btn.is-down:focus-visible {
                background: #fff !important;
                color: #000 !important;
                border-color: #fff !important;
            }

        /* Pills / field boxes */
        .pill, .field-box {
            background: linear-gradient(180deg, #0f1216, #0d1014);
            color: var(--text);
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 10px;
            box-shadow: 0 1px 0 var(--border-soft) inset;
        }

        .pill {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            padding: 6px 10px;
        }

        a {
            color: var(--primary);
        }

        .muted {
            color: var(--muted);
        }

        /* Activity groups */
        .group {
            background: linear-gradient(180deg, var(--panel-2), var(--panel));
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 16px;
            margin: 16px 0;
            box-shadow: 0 1px 0 var(--border-soft) inset, 0 8px 18px rgba(0,0,0,.35);
        }

            .group h3 {
                margin: 0 0 10px;
                font-size: 16px;
            }

                .group h3 a {
                    color: var(--text);
                    text-decoration: none;
                }

                    .group h3 a:hover {
                        text-decoration: underline;
                    }

        /* Comments */
        .comment {
            background: linear-gradient(180deg, #0f1216, #0c0f13);
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 12px;
            margin-top: 12px;
            box-shadow: 0 1px 0 var(--border-soft) inset;
        }

            .comment .parent {
                background: linear-gradient(180deg, #0e1115, #0b0e12);
                color: var(--muted);
                border: var(--bw) solid var(--border);
                border-radius: 0;
                padding: 10px;
                margin-bottom: 10px;
                box-shadow: 0 1px 0 var(--border-soft) inset;
            }

        #load-more {
            margin: 14px 0 28px;
        }

        #empty, #msg {
            color: var(--muted);
        }

        .body {
            white-space: pre-wrap;
            word-break: break-word;
        }

        .replies {
            margin-top: 10px;
        }

        .reply {
            background: linear-gradient(180deg, #101318, #0c0f13);
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 10px;
            margin-top: 10px;
            box-shadow: 0 1px 0 var(--border-soft) inset;
        }

            .reply .actions {
                display: flex;
                gap: 10px;
                margin-top: 8px;
            }

        .comment .reply-editor {
            margin-top: 10px;
        }

        /* ===== Inline owner meta (beside username in H1) ===== */
        .owner-inline {
            display: none;
            margin-left: -2px; /* space after @username */
            font-size: 14px; /* smaller than H1 */
            color: var(--text); /* <- white */
        }

        .title h1 .owner-inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            vertical-align: baseline;
        }

        .owner-inline .sep {
            opacity: .9;
        }

        /* keep link white too */
        .owner-inline a {
            color: var(--text); /* <- white */
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

            .owner-inline a:hover {
                text-decoration: underline;
            }

        /* status dot (offline ring by default) */
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid #fff; /* white ring, empty center */
            background: transparent;
            display: inline-block;
        }

            /* online = solid green + smooth pulse */
            .status-dot.is-online {
                border-color: transparent;
                background: #34d399;
                animation: pulseDot 2.2s ease-in-out infinite;
            }

        @keyframes pulseDot {
            0% {
                box-shadow: 0 0 0 0 rgba(52,211,153,.45);
            }

            50% {
                box-shadow: 0 0 0 6px rgba(52,211,153,0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(52,211,153,0);
            }
        }
    </style>

    <style id="friend-btn-css">
             /* More-specific rules to beat the global .btn:hover */
             .btn.btn-friend {
                 position: relative;
             }

                 /* Pending request: keep it white even when not hovering */
                 .btn.btn-friend.is-pending {
                     background: #fff !important;
                     color: #000 !important;
                     border-color: #fff !important;
                 }

                     /* Pending + hover: go black & invert text color (size stays fixed) */
                     .btn.btn-friend.is-pending:hover {
                         background: #000 !important;
                         color: #fff !important;
                         border-color: #fff !important;
                     }

                 /* “Remove Friend” uses normal dark look; on hover it’ll still go white
        (from your global rules). We only swap the label via JS. */

                 /* Optional: cursor hint when the action requires hover-confirm */
                 .btn.btn-friend.is-confirm-warn:hover {
                     cursor: pointer;
                 }
    </style>
</head>
<body class="theme-editor">
    <div class="container">
        <header>
            <div class="avatar"><img id="pfp" alt=""></div>
            <div class="title">
                <h1 id="hdr-name">@<span id="uname">…</span></h1>
                <div class="muted">Profile: <span id="hdr-slug">…</span> • Joined <span id="hdr-joined">…</span></div>
            </div>
            <div class="actions" style="margin-left:auto">
                <a id="btn-edit" class="btn primary" href="#" style="display:none">Edit profile</a>
                <button id="btn-logout" class="btn" type="button" style="display:none">Log out</button>
            </div>
        </header>

        <!-- Bio -->
        <section class="card" id="bio-card" style="display:none">
            <h3 style="margin:0 0 10px">Bio</h3>
            <div id="bio" class="field-box"></div>
        </section>

        <!-- Activity -->
        <section class="card">
            <h3 style="margin:0 0 10px">Recent comments & replies</h3>
            <div id="groups"></div>
            <button id="load-more" class="btn" style="display:none">Load 10 more</button>
            <div id="empty" class="muted" style="display:none">No comments yet.</div>
            <div id="msg" class="muted"></div>
        </section>
    </div>

    <script>
        (function () {
            "use strict";
            const API_BASE = "http://localhost:3000/api";
            const $ = id => document.getElementById(id);

            /* ================= DEBUG ================= */
            const DEBUG = /\bdebug=1\b/.test(location.search) || (window.DP_DEBUG === true);
            const D = (...a) => { if (DEBUG) console.log("[profile-debug]", ...a); };
            function setOwnerBadge(text) {
                if (!DEBUG) return;
                let el = document.getElementById("owner-debug");
                if (!el) {
                    el = document.createElement("div");
                    el.id = "owner-debug";
                    Object.assign(el.style, {
                        position: "fixed", right: "12px", bottom: "12px", zIndex: 100000,
                        background: "rgba(0,0,0,.8)", color: "#fff", padding: "8px 10px",
                        border: "1px solid #fff", fontFamily: "monospace", fontSize: "12px",
                        borderRadius: "0", whiteSpace: "pre-wrap", maxWidth: "48ch"
                    });
                    document.body.appendChild(el);
                }
                el.textContent = String(text || "");
            }
            window.__ownerbits = {}; // expose a few things for the console

            /* ======================================== */

            const state = {
                slug: "", profile: null, isOwner: false,
                pleaTitleMap: new Map(),
                offset: 0, limit: 10, total: 0, loading: false,
                domGroups: new Map(),
                // OWNER WIDGETS
                friendsRefreshTimer: null,
                presenceTimer: null,
                presenceVisHandler: null
            };

            /* ---------- CSRF + API ---------- */
            async function fetchCsrf() {
                const url = API_BASE.replace("/api", "") + "/api/csrf";
                D("csrf: fetching", url);
                const r = await fetch(url, { credentials: "include" });
                const txt = await r.text();
                let j = {};
                try { j = txt ? JSON.parse(txt) : {}; } catch { j = {}; }
                const tok = j?.token ?? j?.csrfToken ?? j?.csrf ?? null;
                D("csrf: response ok?", r.ok, "token?", !!tok, j);
                if (!r.ok || !tok) throw new Error("csrf");
                return tok;
            }
            async function api(path, opts = {}) {
                const method = (opts.method || "GET").toUpperCase();
                const headers = Object.assign({}, opts.headers || {});
                if (opts.body && !headers["content-type"]) headers["content-type"] = "application/json";
                if (method !== "GET" && !headers["x-csrf-token"]) headers["x-csrf-token"] = await fetchCsrf();
                const url = API_BASE + path;
                D("api:", method, url, opts.body ? "(with body)" : "");
                const r = await fetch(url, { method, headers, credentials: "include", body: opts.body });
                const txt = await r.text();
                let data; try { data = txt ? JSON.parse(txt) : {}; } catch { data = { raw: txt }; }
                D("api: response", r.status, r.ok ? "OK" : "ERR", data);
                if (!r.ok) { const err = new Error(data?.error || r.statusText); err.status = r.status; err.data = data; err.detail = data?.detail || txt; throw err; }
                return data;
            }

            /* ---------- utils ---------- */
            function extractSlugFromPath(path) {
                const p = path.replace(/\/+$/, "");
                const m = p.match(/^\/user\/([^\/?#]+)(?:[\/?#]|$)/i);
                return m ? decodeURIComponent(m[1]) : "";
            }
            const firstNonEmpty = (...v) => { for (const s of v) if (typeof s === "string" && s.trim()) return s.trim(); return ""; };
            const escapeHtml = s => String(s || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

            // Robust owner detection + reason string for debugging
            function resolveOwner(u, fallbackFromActivity) {
                if (!u) return { flag: false, reason: "no profile loaded" };
                const cand = [
                    ["is_me", u.is_me],
                    ["isMe", u.isMe],
                    ["is_owner", u.is_owner],
                    ["isOwner", u.isOwner],
                    ["me", u.me],
                    ["owner", u.owner]
                ];
                for (const [k, v] of cand) {
                    if (typeof v !== "undefined") return { flag: !!v, reason: `profile.${k}=${v}` };
                }
                if (typeof fallbackFromActivity !== "undefined") {
                    return { flag: !!fallbackFromActivity, reason: `activity.is_me=${fallbackFromActivity}` };
                }
                return { flag: false, reason: "no owner flag on profile" };
            }

            /* --- logout helper --- */
            async function logout() {
                D("logout: start");
                let token = null;
                try { token = await fetchCsrf(); } catch { D("logout: csrf failed (continuing best-effort)"); }
                const baseHeaders = { Accept: "application/json" };
                if (token) baseHeaders["X-CSRF-Token"] = token;
                const tries = [
                    { url: API_BASE + "/auth/logout", method: "POST" },
                    { url: API_BASE + "/logout", method: "POST" },
                    { url: API_BASE + "/auth/session", method: "DELETE" },
                    { url: API_BASE.replace("/api", "") + "/logout", method: "POST" }
                ];
                for (const t of tries) {
                    try { const r = await fetch(t.url, { method: t.method, credentials: "include", headers: baseHeaders }); D("logout: try", t, "->", r.status); if (r.ok || r.status === 204) break; }
                    catch (e) { D("logout: error", e); }
                }
                location.reload();
            }

            /* ===== OWNER WIDGETS ===== */
            async function pingPresenceOnce() {
                try { await api(`/presence/ping`, { method: "POST", body: "{}" }); D("presence: ping ok"); }
                catch (e) { D("presence: ping failed", e); }
            }
            function startPresence() {
                stopPresence();
                D("presence: start");
                pingPresenceOnce();
                state.presenceTimer = setInterval(pingPresenceOnce, 60_000);
                state.presenceVisHandler = () => { if (document.visibilityState === "visible") pingPresenceOnce(); };
                document.addEventListener("visibilitychange", state.presenceVisHandler, { passive: true });
            }
            function stopPresence() {
                if (state.presenceTimer) clearInterval(state.presenceTimer);
                if (state.presenceVisHandler) document.removeEventListener("visibilitychange", state.presenceVisHandler);
                state.presenceTimer = null; state.presenceVisHandler = null;
                D("presence: stopped");
            }
            async function fetchFriendsSummary() {
                try {
                    const j = await api(`/users/me/friends/summary`);
                    const out = { total: j.total | 0, online: j.online | 0, window: j.window_minutes | 0 };
                    D("friends.summary:", out);
                    return out;
                } catch (e) {
                    D("friends.summary: failed", e);
                    return { total: 0, online: 0, window: 0 };
                }
            }
            function teardownOwnerBits(reason = "teardown") {
                D("ownerbits: hide", { reason });
                if (state.friendsRefreshTimer) clearInterval(state.friendsRefreshTimer);
                state.friendsRefreshTimer = null;
                stopPresence();

                const slot = document.getElementById('owner-inline');
                if (slot) { slot.style.display = "none"; slot.innerHTML = ""; }

                setOwnerBadge("ownerbits: hidden\n" + reason);
            }
            function ensureOwnerInlineSlot() {
                const name = document.getElementById('hdr-name'); // the H1 line
                if (!name) return null;
                let slot = document.getElementById('owner-inline');
                if (!slot) {
                    slot = document.createElement('span');
                    slot.id = 'owner-inline';
                    slot.className = 'owner-inline';
                    name.appendChild(document.createTextNode(' '));
                    name.appendChild(slot);
                }
                return slot;
            }
            async function renderOwnerBits() {
                const u = state.profile; if (!u) return;
                startPresence();

                const slot = ensureOwnerInlineSlot();
                if (!slot) { D("owner-inline: missing '.title .muted'"); return; }

                const likes = u?.received_likes | 0;
                const dislikes = u?.received_dislikes | 0;
                const karma = (likes - dislikes) | 0;
                const arrow = karma > 0 ? "▲" : (karma < 0 ? "▼" : "");
                const kNum = Math.abs(karma);

                const friendsHref = `/user/${encodeURIComponent(state.slug)}/friends`;

                // Build: [▲/▼] [abs(karma)] • [dot] [N] Friends Online
                slot.innerHTML = `
            <span class="karma-seg" title="Karma = likes − dislikes">
              ${arrow ? `${arrow} ` : ""}${kNum}
            </span>
            <span class="sep">•</span>
            <a class="friends-seg" id="friends-link" href="${friendsHref}" aria-label="Friends online">
              <span class="status-dot" id="friends-dot" aria-hidden="true"></span>
              <span class="friends-count" id="friends-count">0</span>
              <span class="friends-label">Friends Online</span>
            </a>
          `;
                slot.style.display = "inline-flex";

                const dot = slot.querySelector("#friends-dot");
                const countEl = slot.querySelector("#friends-count");

                const refresh = async () => {
                    const s = await fetchFriendsSummary();
                    const n = s.online | 0;
                    countEl.textContent = String(n);
                    const online = n > 0;
                    dot.classList.toggle("is-online", online); // green pulse when true; white ring otherwise
                };

                try { await refresh(); } catch { }
                if (state.friendsRefreshTimer) clearInterval(state.friendsRefreshTimer);
                state.friendsRefreshTimer = setInterval(refresh, 90_000);

                // expose for console testing
                window.__ownerbits.refreshFriends = refresh;

                D("owner-inline: rendered", { karma, likes, dislikes });
                setOwnerBadge(`ownerbits: inline\nkarma=${karma} (+${likes}/-${dislikes})`);
            }
            window.__ownerbits.render = renderOwnerBits;
            window.__ownerbits.teardown = teardownOwnerBits;

            /* ---------- header/bio ---------- */
            function renderHeader(activityIsMe) {
                const u = state.profile; if (!u) return;

                $("uname").textContent = u.username || u.first_username || state.slug;
                $("hdr-slug").textContent = u.first_username || state.slug;
                try { $("hdr-joined").textContent = new Date(u.created_at).toLocaleDateString(); } catch { $("hdr-joined").textContent = "—"; }
                $("pfp").src = u.profile_photo || "";

                const bio = firstNonEmpty(u.bio_html, u.bio);
                if (bio && bio.trim()) { $("bio").innerHTML = bio; $("bio-card").style.display = ""; }
                else { $("bio-card").style.display = "none"; }

                const btnEdit = $("btn-edit");
                const btnLogout = $("btn-logout");

                const { flag, reason } = resolveOwner(u, activityIsMe);
                state.isOwner = flag;
                D("owner: resolve", { flag, reason, profile: u });

                if (flag) {
                    btnEdit.style.display = "";
                    btnEdit.href = `/user/${encodeURIComponent(state.slug)}/edit`;
                    btnLogout.style.display = "";
                    btnLogout.onclick = (e) => { e.preventDefault(); logout(); };
                    renderOwnerBits();
                } else {
                    btnEdit.style.display = "none";
                    btnLogout.style.display = "none";
                    btnLogout.onclick = null;
                    teardownOwnerBits("not owner (" + reason + ")");
                }
            }

            /* ---------- group helpers ---------- */
            function ensureGroup(pleaNum) {
                if (state.domGroups.has(pleaNum)) return state.domGroups.get(pleaNum);

                const wrap = document.createElement("div");
                wrap.className = "group";
                wrap.dataset.plea = String(pleaNum);

                const h = document.createElement("h3");
                const a = document.createElement("a");
                a.href = `/#${encodeURIComponent(pleaNum)}`;
                a.textContent = state.pleaTitleMap.get(pleaNum) || `Plea #${pleaNum}`;
                h.appendChild(a);

                const list = document.createElement("div");
                list.className = "list";

                wrap.appendChild(h);
                wrap.appendChild(list);
                document.getElementById("groups").appendChild(wrap);
                state.domGroups.set(pleaNum, list);

                ensureTitleFor(pleaNum, a);
                return list;
            }

            /* ---------- voting ---------- */
            async function apiGetMyVote(pleaNum, id, fallback = 0) {
                if (fallback === 1 || fallback === -1) return fallback;
                const tries = [
                    `/comments/${encodeURIComponent(id)}/my_vote`,
                    `/comments/${encodeURIComponent(id)}/vote`,
                    `/pleas/${encodeURIComponent(pleaNum)}/comments/${encodeURIComponent(id)}/vote`
                ];
                for (const u of tries) {
                    try {
                        const j = await api(u);
                        if (j && (j.vote === 'up' || j.direction === 'up' || j.delta === 1 || j.value === 1 || j.liked === true)) return 1;
                        if (j && (j.vote === 'down' || j.direction === 'down' || j.delta === -1 || j.value === -1 || j.disliked === true)) return -1;
                        if (typeof j?.my_vote === 'number') return j.my_vote > 0 ? 1 : j.my_vote < 0 ? -1 : 0;
                    } catch { }
                }
                return 0;
            }
            async function apiSetMyVote(pleaNum, id, newVote) {
                try {
                    const j = await api(`/comments/${encodeURIComponent(id)}/vote`, {
                        method: "POST", body: JSON.stringify(newVote === 0 ? { vote: "none" } : { value: newVote })
                    });
                    if (j && (typeof j.likes !== "undefined" || typeof j.dislikes !== "undefined")) {
                        return { ok: true, likes: +j.likes || 0, dislikes: +j.dislikes || 0, my: (typeof j.my_vote === "number" ? j.my_vote : newVote) };
                    }
                    return { ok: true, likes: null, dislikes: null, my: newVote };
                } catch {
                    if (newVote === 0) {
                        try { await api(`/comments/${encodeURIComponent(id)}/vote`, { method: "DELETE" }); return { ok: true, likes: null, dislikes: null, my: 0 }; }
                        catch { }
                    }
                    const mv = await apiGetMyVote(pleaNum, id, 0);
                    return { ok: true, likes: null, dislikes: null, my: mv };
                }
            }
            function makeVoteController({ pleaNum, id, likeBtn, dislikeBtn, initialUps = 0, initialDowns = 0, initialMy = 0, onCountsChanged }) {
                const st = { ups: +initialUps || 0, downs: +initialDowns || 0, my: (typeof initialMy === 'number' ? initialMy : 0), resolved: (initialMy === 1 || initialMy === -1) };
                const render = () => {
                    if (likeBtn) { likeBtn.textContent = `▲ ${st.ups}`; likeBtn.classList.toggle("is-active", st.my === 1); likeBtn.classList.remove("is-down"); }
                    if (dislikeBtn) { dislikeBtn.textContent = `▼ ${st.downs}`; dislikeBtn.classList.toggle("is-down", st.my === -1); dislikeBtn.classList.remove("is-active"); }
                };
                async function ensureKnownMy() { if (st.resolved) return; const v = await apiGetMyVote(pleaNum, id).catch(() => 0); if (v === 1 || v === -1 || v === 0) { st.my = v; st.resolved = true; render(); } }
                async function setMy(nextMy) {
                    likeBtn && (likeBtn.disabled = true); dislikeBtn && (dislikeBtn.disabled = true);
                    await ensureKnownMy(); const prev = st.my; if (nextMy === prev) nextMy = 0;
                    st.my = nextMy; render();
                    try {
                        const r = await apiSetMyVote(pleaNum, id, nextMy);
                        if (r.likes != null && r.dislikes != null) { st.ups = r.likes; st.downs = r.dislikes; }
                        else {
                            const after = (typeof r.my === 'number') ? r.my : nextMy;
                            const dUp = (after === 1 ? 1 : 0) - (prev === 1 ? 1 : 0);
                            const dDown = (after === -1 ? 1 : 0) - (prev === -1 ? 1 : 0);
                            st.ups = Math.max(0, st.ups + dUp);
                            st.downs = Math.max(0, st.downs + dDown);
                        }
                        st.my = (typeof r.my === 'number') ? r.my : nextMy; st.resolved = true; render(); onCountsChanged && onCountsChanged(st);
                        const verify = await apiGetMyVote(pleaNum, id).catch(() => st.my); if (verify !== st.my) { st.my = verify; render(); }
                    } finally {
                        likeBtn && (likeBtn.disabled = false); dislikeBtn && (dislikeBtn.disabled = false);
                    }
                }
                likeBtn && likeBtn.addEventListener("click", () => setMy(1));
                dislikeBtn && dislikeBtn.addEventListener("click", () => setMy(-1));
                render(); ensureKnownMy();
                return { state: st, render, setMy };
            }

            /* ---------- reply helpers ---------- */
            const isReplyItem = (it) =>
                !!(it.parent || it.parent_id != null || it.in_reply_to != null || it.reply_to != null || it.is_reply === true);

            function nRepliesCount(it) {
                const a = it.reply_count ?? it.replies_count ?? it.children_count;
                if (Number.isFinite(a)) return +a;
                if (Array.isArray(it.replies)) return it.replies.length;
                return 0;
            }
            async function apiReplies(parentId) {
                const j = await api(`/comments/${encodeURIComponent(parentId)}/replies`);
                return Array.isArray(j?.items) ? j.items : (Array.isArray(j) ? j : []);
            }

            /* ---------- compose/edit/delete ---------- */
            function openInlineEditor(opts, mountAfter) {
                const root = mountAfter?.closest?.('.comment') || document;
                root.querySelectorAll('.reply-editor').forEach(n => n.remove());

                const ed = document.createElement("div");
                ed.className = "comment reply-editor";
                ed.innerHTML = `
                          <textarea style="width:100%;min-height:80px" class="field-box">${escapeHtml(opts.initial || "")}</textarea>
                          <div class="actions" style="margin-top:8px">
                            <button class="btn primary js-ok">Post</button>
                            <button class="btn js-cancel" type="button">Cancel</button>
                          </div>`;
                const ta = ed.querySelector("textarea");
                ed.querySelector(".js-ok").addEventListener("click", async () => {
                    const val = ta.value.trim(); if (!val) return; await opts.onSubmit(val, ed);
                });
                ed.querySelector(".js-cancel").addEventListener("click", () => ed.remove());

                if (mountAfter) mountAfter.insertAdjacentElement('afterend', ed);
                else (document.getElementById("groups")).appendChild(ed);
            }

            async function editComment(id, text) {
                const form = new URLSearchParams({ _method: "PATCH", body: text });
                try {
                    await fetch(API_BASE + `/comments/${encodeURIComponent(id)}`, {
                        method: "POST", credentials: "include",
                        headers: { "Accept": "application/json", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
                        body: form.toString()
                    }).then(r => { if (!r.ok) throw 0; });
                    return;
                } catch { }
                await api(`/comments/${encodeURIComponent(id)}`, { method: "PATCH", body: JSON.stringify({ body: text }) });
            }
            async function deleteComment(id) {
                const form = new URLSearchParams({ _method: "DELETE" });
                try {
                    const r = await fetch(API_BASE + `/comments/${encodeURIComponent(id)}`, {
                        method: "POST", credentials: "include",
                        headers: { "Accept": "application/json", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
                        body: form.toString()
                    });
                    if (r.ok || r.status === 204) return true;
                } catch { }
                await api(`/comments/${encodeURIComponent(id)}`, { method: "DELETE" }); return true;
            }

            /* ---------- tiny reply renderer ---------- */
            function renderOneReply(r, fallbackPleaNum) {
                const wrap = document.createElement("div");
                wrap.className = "reply";

                const body = document.createElement("div");
                body.className = "body";
                body.textContent = r.body || "";
                wrap.appendChild(body);

                const meta = document.createElement("div");
                meta.className = "muted";
                meta.textContent = new Date(r.created_at || r.timestamp || Date.now()).toLocaleString();
                wrap.appendChild(meta);

                const row = document.createElement("div");
                row.className = "actions";
                const likeBtn = document.createElement("button");
                likeBtn.className = "btn";
                likeBtn.textContent = `▲ ${r.likes | 0}`;
                const dislikeBtn = document.createElement("button");
                dislikeBtn.className = "btn";
                dislikeBtn.textContent = `▼ ${r.dislikes | 0}`;
                row.appendChild(likeBtn);
                row.appendChild(dislikeBtn);
                wrap.appendChild(row);

                const vc = makeVoteController({
                    pleaNum: r.plea_num ?? fallbackPleaNum,
                    id: r.id,
                    likeBtn,
                    dislikeBtn,
                    initialUps: r.likes | 0,
                    initialDowns: r.dislikes | 0,
                    initialMy: 0
                });
                apiGetMyVote(r.plea_num ?? fallbackPleaNum, r.id).then(v => {
                    if (v !== vc.state.my) { vc.state.my = v; vc.render(); }
                }).catch(() => { });

                return wrap;
            }

            /* ---------- render item ---------- */
            function renderItem(container, item) {
                const node = document.createElement("div"); node.className = "comment"; node.dataset.commentId = item.id;

                const thisIsReply = isReplyItem(item);
                if (thisIsReply && item.parent) {
                    const parent = document.createElement("div");
                    parent.className = "parent";
                    const who = item.parent.author_username || item.parent.author_first_username || "User";
                    parent.innerHTML = `<div class="muted">In reply to <b>${escapeHtml(who)}</b>:</div><div>${escapeHtml(item.parent.body || "")}</div>`;
                    node.appendChild(parent);
                }

                const body = document.createElement("div"); body.className = "body"; body.innerHTML = escapeHtml(item.body || ""); node.appendChild(body);

                const meta = document.createElement("div");
                meta.className = "muted";
                try { meta.textContent = new Date(item.created_at).toLocaleString(); } catch { meta.textContent = ""; }
                node.appendChild(meta);

                const actions = document.createElement("div"); actions.className = "actions";
                const likeBtn = document.createElement("button"); likeBtn.className = "btn js-like"; likeBtn.textContent = `▲ ${item.likes | 0}`;
                const dislikeBtn = document.createElement("button"); dislikeBtn.className = "btn js-dislike"; dislikeBtn.textContent = `▼ ${item.dislikes | 0}`;
                actions.appendChild(likeBtn); actions.appendChild(dislikeBtn);

                const vc = makeVoteController({
                    pleaNum: item.plea_num, id: item.id, likeBtn, dislikeBtn,
                    initialUps: item.likes | 0, initialDowns: item.dislikes | 0, initialMy: 0,
                    onCountsChanged: s => { likeBtn.textContent = `▲ ${s.ups}`; dislikeBtn.textContent = `▼ ${s.downs}`; }
                });
                apiGetMyVote(item.plea_num, item.id).then(v => { if (v !== vc.state.my) { vc.state.my = v; vc.render(); } }).catch(() => { });

                const isTopLevel = !thisIsReply;
                let repliesWrap = null, repliesList = null, toggleRepliesBtn = null;

                if (isTopLevel) {
                    repliesWrap = document.createElement("div");
                    repliesWrap.className = "replies";
                    repliesWrap.style.display = "none";

                    repliesList = document.createElement("div");
                    repliesList.className = "replies-list";
                    repliesWrap.appendChild(repliesList);

                    toggleRepliesBtn = document.createElement("button");
                    toggleRepliesBtn.className = "btn js-toggle-replies";
                    toggleRepliesBtn.style.display = "none";
                    toggleRepliesBtn.textContent = "View replies (0)";
                    actions.appendChild(toggleRepliesBtn);

                    async function refreshReplies(openAfter = false) {
                        const reps = await apiReplies(item.id).catch(() => []);
                        repliesList.innerHTML = "";
                        if (!reps.length) {
                            const empty = document.createElement("div");
                            empty.className = "muted";
                            empty.textContent = "(No replies)";
                            repliesList.appendChild(empty);
                            toggleRepliesBtn.textContent = "View replies (0)";
                            toggleRepliesBtn.style.display = "none";
                        } else {
                            for (const r of reps) repliesList.appendChild(renderOneReply(r, item.plea_num));
                            toggleRepliesBtn.style.display = "";
                            toggleRepliesBtn.textContent = openAfter ? "Hide replies" : `View replies (${reps.length})`;
                        }
                        if (openAfter) repliesWrap.style.display = "";
                    }

                    (async () => {
                        const known = nRepliesCount(item);
                        if (known > 0) { toggleRepliesBtn.style.display = ""; toggleRepliesBtn.textContent = `View replies (${known})`; }
                        else {
                            const reps = await apiReplies(item.id).catch(() => []);
                            if (reps.length > 0) { toggleRepliesBtn.style.display = ""; toggleRepliesBtn.textContent = `View replies (${reps.length})`; }
                        }
                    })();

                    toggleRepliesBtn.addEventListener("click", async () => {
                        const open = repliesWrap.style.display !== "none";
                        if (open) {
                            repliesWrap.style.display = "none";
                            const cnt = Math.max(0, repliesList.querySelectorAll(".reply").length);
                            toggleRepliesBtn.textContent = `View replies (${cnt})`;
                        } else {
                            repliesWrap.style.display = "";
                            await refreshReplies(false);
                            toggleRepliesBtn.textContent = "Hide replies";
                        }
                    });

                    const replyBtn = document.createElement("button");
                    replyBtn.className = "btn js-reply";
                    replyBtn.textContent = "Reply";
                    actions.appendChild(replyBtn);

                    replyBtn.addEventListener("click", async () => {
                        repliesWrap.style.display = "";
                        await (async () => {
                            const reps = await apiReplies(item.id).catch(() => []);
                            repliesList.innerHTML = "";
                            if (!reps.length) {
                                const empty = document.createElement("div");
                                empty.className = "muted";
                                empty.textContent = "(No replies)";
                                repliesList.appendChild(empty);
                            } else {
                                for (const r of reps) repliesList.appendChild(renderOneReply(r, item.plea_num));
                            }
                            toggleRepliesBtn.style.display = "";
                            toggleRepliesBtn.textContent = "Hide replies";
                        })();

                        openInlineEditor({
                            plea_num: item.plea_num,
                            parent_id: item.id,
                            onSubmit: async (text, ed) => {
                                await api(`/pleas/${item.plea_num}/comments`, { method: "POST", body: JSON.stringify({ parent_id: item.id, body: text }) });
                                ed.remove();
                                const reps = await apiReplies(item.id).catch(() => []);
                                repliesList.innerHTML = "";
                                if (!reps.length) {
                                    const empty = document.createElement("div");
                                    empty.className = "muted";
                                    empty.textContent = "(No replies)";
                                    repliesList.appendChild(empty);
                                } else {
                                    for (const r of reps) repliesList.appendChild(renderOneReply(r, item.plea_num));
                                }
                                toggleRepliesBtn.style.display = "";
                                toggleRepliesBtn.textContent = "Hide replies";
                            }
                        }, actions);
                    });
                }

                if (state.isOwner) {
                    const editBtn = document.createElement("button"); editBtn.className = "btn js-edit"; editBtn.textContent = "Edit";
                    const delBtn = document.createElement("button"); delBtn.className = "btn js-del"; delBtn.textContent = "Delete";
                    actions.appendChild(editBtn); actions.appendChild(delBtn);

                    editBtn.addEventListener("click", () => {
                        const mountTarget = (isTopLevel && repliesWrap) ? repliesWrap : node;
                        openInlineEditor({
                            initial: item.body || "",
                            onSubmit: async (text, ed) => { await editComment(item.id, text); ed.remove(); body.textContent = text; }
                        }, mountTarget);
                    });
                    delBtn.addEventListener("click", async () => {
                        if (!confirm("Delete this comment?")) return;
                        await deleteComment(item.id); node.remove();
                    });
                }

                node.appendChild(actions);
                if (isTopLevel && repliesWrap) node.appendChild(repliesWrap);
                container.appendChild(node);
            }

            /* ---------- activity loading ---------- */
            async function loadMore() {
                if (state.loading) return; state.loading = true; $("load-more").disabled = true;
                D("activity: load", { offset: state.offset, limit: state.limit });
                try {
                    const j = await api(`/users/${encodeURIComponent(state.slug)}/activity?offset=${state.offset}&limit=${state.limit}`);
                    D("activity: got", j);
                    state.total = j.total | 0;
                    // keep track of activity-provided owner flag for debugging
                    const activityIsMe = !!j.is_me;
                    if (state.profile && state.profile.is_me !== j.is_me) {
                        state.profile.is_me = j.is_me;
                        D("profile.is_me updated from activity:", j.is_me);
                        renderHeader(activityIsMe);
                    }

                    if (!j.items || j.items.length === 0) {
                        if (state.offset === 0) $("empty").style.display = ""; $("load-more").style.display = "none";
                        return;
                    }
                    $("empty").style.display = "none";
                    for (const it of j.items) {
                        const group = ensureGroup(it.plea_num);
                        renderItem(group, it);
                    }
                    state.offset += j.items.length;
                    $("load-more").style.display = (state.offset < state.total) ? "" : "none";
                } catch (e) { msg(e); D("activity: error", e); }
                finally { state.loading = false; $("load-more").disabled = false; }
            }
            function resetAndLoad() {
                D("activity: reset");
                state.offset = 0; state.total = 0; state.domGroups.clear();
                $("groups").innerHTML = ""; loadMore();
            }

            // --- title helpers ---
            async function fetchPleaTitleByNum(num) {
                const candidates = [`/${encodeURIComponent(num)}/`, `/${encodeURIComponent(num)}`];
                for (const u of candidates) {
                    try {
                        const res = await fetch(u, { cache: 'no-store' });
                        if (!res.ok) continue;
                        const html = await res.text();
                        const doc = new DOMParser().parseFromString(html, 'text/html');
                        const raw = (doc.querySelector('.plea-number')?.textContent?.trim() || doc.title || '').trim();
                        const title = raw.replace(/^\s*plea\s*[:#-]?\s*/i, '').trim();
                        if (title) return title;
                    } catch { }
                }
                return null;
            }
            function ensureTitleFor(pleaNum, anchorEl) {
                if (state.pleaTitleMap.has(pleaNum)) { anchorEl.textContent = state.pleaTitleMap.get(pleaNum); return; }
                fetchPleaTitleByNum(pleaNum).then(title => {
                    if (!title) return;
                    state.pleaTitleMap.set(pleaNum, title);
                    anchorEl.textContent = title;
                }).catch(() => { });
            }

            /* ---------- titles ---------- */
            async function loadPleaTitles() {
                try {
                    const j = await api(`/plealist`);
                    const arr = Array.isArray(j) ? j
                        : Array.isArray(j?.items) ? j.items
                            : Array.isArray(j?.pleas) ? j.pleas : [];
                    for (const it of arr) {
                        const id = it.id ?? it.num ?? it.plea_num ?? it.pleaId ?? it.pleaID;
                        const ttl = it.title ?? it.name ?? null;
                        if (id != null && ttl) state.pleaTitleMap.set(+id, String(ttl));
                    }
                    D("titles: loaded", state.pleaTitleMap.size);
                } catch (e) { D("titles: failed", e); }
            }

            function msg(e) {
                const m = typeof e === "string" ? e : (e?.detail || e?.message || "Error");
                $("msg").textContent = m; setTimeout(() => { $("msg").textContent = ""; }, 3000);
            }

            /* ---------- boot ---------- */
            async function init() {
                D("init: start", { API_BASE, path: location.pathname, search: location.search });
                state.slug = extractSlugFromPath(location.pathname) || "";
                if (!state.slug) { msg("Bad URL"); D("init: bad URL"); setOwnerBadge("ownerbits: hidden\nreason=bad URL"); return; }
                $("hdr-slug").textContent = state.slug;

                const prof = await api(`/users/by-first/${encodeURIComponent(state.slug)}`).catch((e) => { D("profile fetch failed", e); return null; });
                state.profile = prof?.user || null;
                D("profile:", state.profile);

                if (!state.profile) { msg("Profile not found"); setOwnerBadge("ownerbits: hidden\nreason=profile not found"); return; }

                renderHeader(); // no activity fallback yet

                await loadPleaTitles();
                $("load-more").addEventListener("click", loadMore);
                await loadMore();

                // expose for console checks
                window.__ownerbits.state = state;
                const card = $("owner-card");
                D("ownerbits: dom", { hasOwnerCard: !!card, ownerCardDisplay: card?.style?.display });
            }

            if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init); else init();

            // cleanup
            window.addEventListener("beforeunload", () => {
                if (state.friendsRefreshTimer) clearInterval(state.friendsRefreshTimer);
                stopPresence();
            });
        })();
    </script>

    <script>
        (function mountPleaHubBtnExact() {
            'use strict';
            const HUB_URL = '/pleas/';
            const ICON_SRC = '/icons/plea-hub.png';
            const STYLE_ID = 'plea-hub-btn-style';
            const prev = document.getElementById(STYLE_ID);
            if (prev) prev.remove();
            function injectExactStyles() {
                const s = document.createElement('style');
                s.id = STYLE_ID;
                s.textContent = `
:root{ --hub-native:21; --hub-scale:3; --hub-gap:20px; --sbw:0px; }
@media (max-width:480px){ :root{ --hub-scale:2; } }
@media (min-width:1024px){ :root{ --hub-scale:4; } }
.plea-hub-btn{
                  position:fixed; top:calc(var(--hub-gap) + env(safe-area-inset-top));
                  right:calc(var(--hub-gap) + env(safe-area-inset-right) + var(--sbw,0px));
                  width:calc(var(--hub-native) * var(--hub-scale) * 1px);
                  height:calc(var(--hub-native) * var(--hub-scale) * 1px);
                  display:inline-flex; align-items:center; justify-content:center;
                  padding:0; border:none; background:transparent; border-radius:0; text-decoration:none;
                  z-index:10050; opacity:0; transition:opacity .3s ease; pointer-events:auto; touch-action:manipulation; overflow:hidden;
}
.plea-hub-btn.is-show{ opacity:.5; }
.plea-hub-btn:hover, .plea-hub-btn:focus-visible{ opacity:.8; }
.plea-hub-btn:active{ opacity:1; }
.plea-hub-btn img{ width:100%; height:100%; display:block; image-rendering:pixelated; image-rendering:crisp-edges; image-rendering:-moz-crisp-edges; -ms-interpolation-mode:nearest-neighbor; }
`;
                document.head.appendChild(s);
            }
            function stashReturnTarget() {
                const m = location.pathname.match(/\/(\d{1,6})\/?$/);
                if (m) { try { sessionStorage.setItem('plea:return', String(m[1])); } catch { } }
            }
            function updateSBW() {
                const sw = window.innerWidth - document.documentElement.clientWidth;
                document.documentElement.style.setProperty('--sbw', (sw > 0 ? sw : 0) + 'px');
            }
            function buildBtn() {
                if (document.querySelector('.plea-hub-btn')) return;
                const a = document.createElement('a');
                a.href = HUB_URL;
                a.className = 'plea-hub-btn';
                a.setAttribute('aria-label', 'Open Plea Select');
                const img = new Image();
                img.src = ICON_SRC; img.alt = 'Plea Select'; img.decoding = 'async'; img.loading = 'eager'; img.draggable = false;
                a.appendChild(img);
                document.body.appendChild(a);
                a.addEventListener('click', () => { stashReturnTarget(); }, { capture: true });
                requestAnimationFrame(() => a.classList.add('is-show'));
            }
            function bindEscapeShortcut() {
                const handler = (e) => {
                    const tag = (e.target && e.target.tagName || '').toLowerCase();
                    if (['input', 'textarea', 'select'].includes(tag) || e.target?.isContentEditable) return;
                    if (e.repeat) return;
                    if (e.key === 'Escape' || e.key === 'Esc') {
                        e.preventDefault(); e.stopPropagation();
                        stashReturnTarget();
                        const href = document.querySelector('.plea-hub-btn')?.href || HUB_URL;
                        window.location.assign(href);
                    }
                };
                window.addEventListener('keydown', handler, { capture: true });
            }
            function mount() {
                injectExactStyles();
                updateSBW();
                window.addEventListener('resize', updateSBW, { passive: true });
                buildBtn();
                bindEscapeShortcut();
            }
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', mount, { once: true });
            } else {
                mount();
            }
        })();
    </script>

    <script>
        /* ===== Auth Bar (profile view) ===== */
        (() => {
            const API = "http://localhost:3000/api";
            const ASSET_BASE = "/web";
            const OVERLAY_JS = ASSET_BASE + "/authOverlay.js";
            const OVERLAY_CSS = ASSET_BASE + "/authOverlay.css";

            if (window.DPAuthBar && typeof window.DPAuthBar.ensure === "function") {
                if (document.readyState === "loading") {
                    document.addEventListener("DOMContentLoaded", () => window.DPAuthBar.ensure(), { once: true });
                } else { window.DPAuthBar.ensure(); }
                return;
            }

            function loadStyle(href) { try { const l = document.createElement("link"); l.rel = "stylesheet"; l.href = href; document.head.appendChild(l); } catch { } }
            function loadScript(src) {
                return new Promise((res, rej) => {
                    const s = document.createElement("script"); s.src = src; s.defer = true;
                    s.onload = res; s.onerror = () => rej(new Error("Failed to load " + src)); document.head.appendChild(s);
                });
            }
            async function getMe() {
                try { const r = await fetch(API + "/auth/me", { credentials: "include" }); return r.ok ? r.json() : { user: null }; }
                catch { return { user: null }; }
            }

            function injectStyles() {
                if (document.getElementById("dp-authbar-style")) return;
                const s = document.createElement("style");
                s.id = "dp-authbar-style";
                s.textContent = `
#dp-authbar{
                  position:fixed; top:12px; left:12px; z-index:10060;
                  display:flex; align-items:center; gap:10px;
                  background:transparent; color:#fff; padding:0; border:none; border-radius:0;
                  font-family:'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important; line-height:1;
}
#dp-authprefix{ opacity:.95; }
#dp-authlink{
                  display:inline-flex; align-items:center; gap:8px;
                  color:#fff; text-decoration:none; cursor:pointer; outline:none;
}
#dp-authlink:hover{ text-decoration:underline; }
#dp-authlink:focus-visible{ outline:2px solid #fff; outline-offset:2px; }
#dp-authname{ font-weight:600; }
#dp-authavatar{
                  width:26px; height:26px; display:block; border-radius:50%; object-fit:cover; background:#000; border:2px solid #fff;
}
#dp-logout-btn{ display:none; }`;
                document.head.appendChild(s);
            }

            const AVATAR_FALLBACK = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64">
                          <rect width="100%" height="100%" fill="#000"/>
                          <circle cx="32" cy="24" r="14" fill="#fff"/>
                          <rect x="10" y="40" width="44" height="16" rx="8" fill="#fff"/>
                        </svg>`);

            async function resolveProfileHrefFor(user) {
                const first = (user?.first_username || user?.firstUsername || "").trim();
                if (first) return "/user/" + encodeURIComponent(first);
                const uname = (user?.username || "").trim();
                if (!uname) return null;

                const tries = [
                    `${API}/users/by_username/${encodeURIComponent(uname)}`,
                    `${API}/users/resolve?username=${encodeURIComponent(uname)}`
                ];
                for (const url of tries) {
                    try {
                        const r = await fetch(url, { credentials: "include", headers: { Accept: "application/json" } });
                        const j = await r.json().catch(() => ({}));
                        const fx = j?.first_username || j?.user?.first_username || j?.firstUsername || j?.user?.firstUsername;
                        if (fx) return "/user/" + encodeURIComponent(String(fx).trim());
                    } catch { }
                }
                return "/user/" + encodeURIComponent(uname);
            }

            function mount() {
                injectStyles();
                if (document.getElementById("dp-authbar")) return;

                const bar = document.createElement("div");
                bar.id = "dp-authbar";
                bar.innerHTML = `
                          <span id="dp-authprefix" aria-hidden="true">User:</span>
                          <a id="dp-authlink" href="#"></a>
                          <button id="dp-logout-btn" type="button">Sign out</button>
                        `;
                document.body.appendChild(bar);

                const authLink = bar.querySelector("#dp-authlink");
                authLink.addEventListener("click", (e) => {
                    if (authLink.getAttribute("data-state") === "logged-out") {
                        e.preventDefault();
                        if (window.DP && DP.openAuth) DP.openAuth();
                        else alert("Login UI not loaded — check " + OVERLAY_JS);
                    }
                });

                window.DP = window.DP || {};
                const prev = DP.syncAfterLogin;
                DP.syncAfterLogin = async () => { try { if (prev) await prev(); } finally { await refresh(); } };
            }

            async function refresh() {
                const bar = document.getElementById("dp-authbar");
                if (!bar) return;
                const prefixEl = bar.querySelector("#dp-authprefix");
                const authLink = bar.querySelector("#dp-authlink");

                const { user } = await getMe();

                if (user) {
                    const uname = (user.username || user.first_username || "me").trim();
                    const pfp = (user.profile_photo || user.photo || "").trim() || AVATAR_FALLBACK;
                    const href = await resolveProfileHrefFor(user);

                    prefixEl.style.display = "";
                    authLink.setAttribute("data-state", "logged-in");
                    authLink.setAttribute("href", href || "#");
                    authLink.innerHTML = `
                            <img id="dp-authavatar" alt="" src="${pfp}">
                            <span id="dp-authname">${uname}</span>
                          `;
                    authLink.onclick = null;
                } else {
                    prefixEl.style.display = "none";
                    authLink.setAttribute("data-state", "logged-out");
                    authLink.setAttribute("href", "#");
                    authLink.textContent = "User Login";
                }
            }

            async function ensure() {
                try { loadStyle(OVERLAY_CSS); } catch { }
                let overlayOk = true;
                try { await loadScript(OVERLAY_JS); } catch (e) { overlayOk = false; console.warn(e.message); }
                window.DP = window.DP || {};
                if (overlayOk && DP.init) DP.init({ apiBase: API });

                mount();
                await refresh();
            }

            window.DPAuthBar = { ensure, refresh };

            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => ensure(), { once: true });
            } else {
                ensure();
            }
        })();
    </script>
    <script>
        (() => {
            "use strict";
            const API = "http://localhost:3000/api";

            const Q = sel => document.querySelector(sel);
            const $ = id => document.getElementById(id);

            // extend labels
            const LABELS = {
                add: "Add Friend",
                pending: "Request Sent",
                pendingHover: "Cancel Request?",
                accept: "Accept Request",          // <—
                remove: "Remove Friend",
                removeHover: "Are you sure?"
            };

            /* ---------- tiny http helpers ---------- */
            async function getJSON(url, opts = {}) {
                const r = await fetch(url, { credentials: "include", ...opts });
                const t = await r.text(); let j; try { j = t ? JSON.parse(t) : {}; } catch { j = { raw: t }; }
                if (!r.ok) { const e = new Error(j?.error || r.statusText); e.status = r.status; e.detail = j?.detail || t; throw e; }
                return j;
            }
            async function csrfToken() {
                try {
                    const r = await fetch(API.replace("/api", "") + "/api/csrf?_=" + Date.now(), { credentials: "include" });
                    const j = await r.json().catch(() => ({}));
                    if (!r.ok || !j.token) throw 0;
                    return j.token;
                } catch { return null; }
            }
            async function postJSON(url, body) {
                const tok = await csrfToken();
                return getJSON(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json", ...(tok ? { "X-CSRF-Token": tok } : {}) },
                    body: JSON.stringify(body || {})
                });
            }
            async function delJSON(url) {
                const tok = await csrfToken();
                const r = await fetch(url, {
                    method: "DELETE",
                    credentials: "include",
                    headers: tok ? { "X-CSRF-Token": tok } : {}
                });
                const text = await r.text();
                let json; try { json = text ? JSON.parse(text) : null; } catch { json = { raw: text }; }

                console.log("[DELETE]", url, "->", r.status, json);

                if (!r.ok && r.status !== 204) {
                    const msg = json?.error || json?.raw || r.statusText;
                    throw new Error(`${r.status} ${msg}`);
                }
                return { status: r.status, body: json };
            }

            /* ---------- login + target ---------- */
            async function getMe() {
                try { const j = await getJSON(API + "/auth/me"); return j?.user || null; }
                catch { return null; }
            }
            function getSlug() {
                const fromDom = ($("#hdr-slug")?.textContent || "").trim();
                if (fromDom) return fromDom;
                const m = location.pathname.match(/^\/user\/([^\/?#]+)/i);
                return m ? decodeURIComponent(m[1]) : "";
            }

            /* ---------- requests list helpers ---------- */
            async function listRequests(direction) {
                // returns [{ id, slug }]
                const urls = [
                    API + `/friends/requests?direction=${direction}`,
                    API + `/users/me/friends/requests?direction=${direction}`,
                    API + `/users/me/friends/requests/${direction}` // some backends expose /out /in
                ];
                for (const u of urls) {
                    try {
                        const j = await getJSON(u);
                        const arr = Array.isArray(j?.items) ? j.items : Array.isArray(j) ? j : [];
                        return arr.map(row => {
                            const id = row.id || row.request_id || row.requestId || null;
                            const user = direction === "out" ? (row.to_user || row.user || row) : (row.from_user || row.user || row);
                            const slug = (user?.first_username || user?.firstUsername || user?.username || "").trim();
                            return { id, slug };
                        }).filter(x => x.slug);
                    } catch { /* try next */ }
                }
                return [];
            }
            async function findOutgoingRequestId(targetSlug) {
                const out = await listRequests("out");
                const hit = out.find(x => x.slug.toLowerCase() === targetSlug.toLowerCase());
                return hit?.id || null;
            }
            async function findIncomingRequest(targetSlug) {
                const inn = await listRequests("in");
                const hit = inn.find(x => x.slug.toLowerCase() === targetSlug.toLowerCase());
                return hit || null; // {id, slug} or null
            }

            /* ---------- relationship discovery (read-only) ---------- */
            // replace getRelationship() with this:
            async function getRelationship(targetSlug) {
                try {
                    const j = await getJSON(API + `/relationships/${encodeURIComponent(targetSlug)}?_=` + Date.now());
                    const s = j?.status;
                    return (s === "friend" || s === "requested_by_me" || s === "requested_of_me" || s === "none") ? s : "none";
                } catch { return "none"; }
            }

            /* ---------- friend actions (request-only) ---------- */
            // replace addFriendRequest() with this:
            async function addFriendRequest(target) {
                const slug = (target.first_username || target.username || "").trim();
                const tries = [
                    { url: API + "/friends/requests", body: { to_username: slug } },
                    { url: API + "/users/me/friends/requests", body: { to_username: slug } },
                ];
                for (const t of tries) {
                    try {
                        const resp = await postJSON(t.url, t.body);
                        return (resp?.status === "accepted") ? "friend" : "requested_by_me";
                    } catch (e) {
                        // Normalize common conflicts to server truth
                        if (e?.status === 409) return await getRelationship(slug);
                    }
                }
                return "none";
            }

            async function acceptIncomingRequest(targetSlug) {
                // accept by id if possible; try a few shapes
                const req = await findIncomingRequest(targetSlug);
                const id = req?.id || targetSlug; // fall back to slug if API allows it
                const urls = [
                    API + `/friends/requests/${encodeURIComponent(id)}/accept`,
                    API + `/users/me/friends/requests/${encodeURIComponent(id)}/accept`,
                    API + `/friends/accept/${encodeURIComponent(id)}`
                ];
                for (const u of urls) {
                    try { await postJSON(u, {}); return true; } catch { }
                }
                return false;
            }

            async function cancelOutgoingRequest(targetSlug) {
                const id = await findOutgoingRequestId(targetSlug);
                if (!id) return false;
                const urls = [
                    API + `/friends/requests/${encodeURIComponent(id)}/cancel`, // add server route for this
                    API + `/friends/requests/${encodeURIComponent(id)}`,        // optional legacy DELETE
                ];
                for (const u of urls) { try { await del(u); return true; } catch { } }
                return false;
            }

            async function resolveUser(slug) {
                const tries = [
                    API + `/users/by-first/${encodeURIComponent(slug)}`,
                    API + `/users/by_username/${encodeURIComponent(slug)}`,
                    API + `/users/resolve?username=${encodeURIComponent(slug)}`
                ];
                for (const u of tries) {
                    try {
                        const j = await getJSON(u);
                        const user = j?.user || j;
                        if (user && (user.id || user.user_id || user.username || user.first_username)) {
                            return {
                                id: user.id || user.user_id || null,
                                first: (user.first_username || user.firstUsername || "").trim(),
                                uname: (user.username || "").trim()
                            };
                        }
                    } catch { }
                }
                return { id: null, first: slug, uname: slug };
            }

            async function removeFriend(targetSlug) {
                try {
                    const resp = await delJSON(API + `/users/me/friends/${encodeURIComponent(targetSlug)}`);
                    console.log("[removeFriend] resp:", resp);
                    return true;
                } catch (e) {
                    console.warn("[removeFriend] failed:", e);
                    return false;
                }
            }

            /* ---------- UI ---------- */
            function ensureFriendButtonSlot() {
                const actionsWrap = Q('header .actions');
                if (!actionsWrap) return null;
                let btn = $("#btn-friend");
                if (!btn) {
                    btn = document.createElement("button");
                    btn.id = "btn-friend";
                    btn.className = "btn btn-friend";
                    btn.type = "button";
                    actionsWrap.prepend(btn);
                }
                btn.style.display = "";
                return btn;
            }

            function fixStableWidth(btn, labels) {
                const keep = btn.textContent;
                let max = 0;
                for (const label of labels) {
                    btn.textContent = label;
                    btn.style.width = "auto";
                    const w = Math.ceil(btn.getBoundingClientRect().width);
                    if (w > max) max = w;
                }
                btn.style.width = max + "px";
                btn.style.minWidth = btn.style.width;
                btn.textContent = keep;
            }

            function wireButtonBehavior(btn, target, initialState) {
                let state = initialState;          // "none" | "requested_by_me" | "requested_of_me" | "friend"
                let armed = false;                 // replaces the hover requirement
                let armTimer = null;

                const setLabel = (txt) => { btn.textContent = txt; };
                const setPendingLook = (on) => {
                    btn.classList.toggle("is-pending", !!on);
                };
                const setWarnLook = (on) => {
                    btn.classList.toggle("is-confirm-warn", !!on);
                };

                const render = () => {
                    if (state === "friend") {
                        setPendingLook(false);
                        setWarnLook(armed);
                        setLabel(armed ? LABELS.removeHover : LABELS.remove);
                    } else if (state === "requested_by_me") {
                        setPendingLook(true);
                        setWarnLook(armed);
                        setLabel(armed ? LABELS.pendingHover : LABELS.pending);
                    } else if (state === "requested_of_me") {
                        setPendingLook(false);
                        setWarnLook(false);
                        setLabel(LABELS.accept);
                    } else {
                        setPendingLook(false);
                        setWarnLook(false);
                        setLabel(LABELS.add);
                    }
                };

                function armOnce() {
                    armed = true;
                    clearTimeout(armTimer);
                    armTimer = setTimeout(() => { armed = false; render(); }, 2000);
                    render();
                }

                btn.addEventListener("click", async () => {
                    try {
                        btn.disabled = true;
                        const slug = (target.first_username || target.username || "").trim();

                        if (state === "none") {
                            state = await addFriendRequest(target);
                            armed = false;

                        } else if (state === "requested_by_me") {
                            if (!armed) { armOnce(); return; }
                            clearTimeout(armTimer); armed = false;
                            await cancelOutgoingRequest(slug);
                            state = "none";

                        } else if (state === "requested_of_me") {
                            const ok = await acceptIncomingRequest(slug);
                            state = ok ? "friend" : "requested_of_me";
                            armed = false;

                        } else if (state === "friend") {
                            if (!armed) { armOnce(); return; }
                            clearTimeout(armTimer); armed = false;
                            const ok = await removeFriend(slug);

                            // Optimistically flip to "none" so the label changes immediately,
                            // then reconcile with server truth.
                            state = ok ? "none" : "friend";
                            render();

                            try {
                                const truth = await getRelationship(slug); // you already cache-bust here
                                if (truth !== state) { state = truth; render(); }
                            } catch { }
                        }

                        render();
                    } catch (e) {
                        console.warn("[friend-btn]", e);
                    } finally {
                        btn.disabled = false;
                    }
                });

                // Keep your fixed width so labels don’t jiggle:
                fixStableWidth(btn, [
                    LABELS.add, LABELS.pending, LABELS.pendingHover, LABELS.remove, LABELS.removeHover, LABELS.accept
                ]);

                render();
            }

            async function bootFriendButton() {
                const slug = getSlug();
                if (!slug) return;

                const me = await getMe();
                if (!me) return; // not logged in

                const myFirst = (me.first_username || me.firstUsername || me.username || "").toLowerCase();
                if (myFirst && myFirst === slug.toLowerCase()) return; // your own profile

                const target = {
                    first_username: ($("#hdr-slug")?.textContent || slug).trim(),
                    username: ($("#uname")?.textContent || "").replace(/^@/, "").trim() || slug
                };

                let rel = "none";
                try { rel = await getRelationship(target.first_username || target.username || ""); } catch { }

                const btn = ensureFriendButtonSlot();
                if (!btn) return;

                wireButtonBehavior(btn, target, rel);
            }

            if (document.readyState === "complete" || document.readyState === "interactive") {
                setTimeout(bootFriendButton, 0);
            } else {
                document.addEventListener("DOMContentLoaded", bootFriendButton, { once: true });
            }
        })();
    </script>
</body>
</html>
