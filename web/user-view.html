<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>User Profile</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- These can 404/MIME-mismatch; this page won't depend on them. -->
    <link rel="stylesheet" href="/web/site.css">
    <link rel="stylesheet" href="/web/user-profile.css?v=dev">

    <style id="user-view-theme">
        :root {
            color-scheme: dark;
            /* neutral, grayscale-only palette */
            --bg: #0a0b0d;
            --bg-2: #0c0e12;
            --panel: #0e1116; /* card base */
            --panel-2: #12161c; /* card top for gradient */

            --text: #f2f2f2;
            --muted: #b3b3b3;
            --primary: #ffffff; /* links/buttons stay white */
            --border: #e6e6e6; /* soft white border */
            --border-soft: rgba(255,255,255,.14); /* inner separators */

            --bw: 2px; /* border thickness */
        }

        * {
            box-sizing: border-box;
        }

        body.theme-editor {
            margin: 0;
            font-family: 'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
            color: var(--text) !important;
            /* subtle neutral background (no colors, just gray shades) */
            background: radial-gradient(1200px 800px at 20% -10%, #111214 0%, #0a0b0d 45%, #08090b 100%), linear-gradient(180deg, #0a0b0d, #0a0b0d);
        }

        .container {
            max-width: 980px;
            margin: 24px auto;
            padding: 0 16px;
        }

        header {
            display: flex;
            align-items: center;
            gap: 18px;
            margin-bottom: 20px;
        }

        /* Avatar: circular border as requested */
        .avatar {
            width: 88px;
            height: 88px;
            flex: 0 0 auto;
            background: #0b0c0f;
            border: var(--bw) solid #fff; /* crisp white ring */
            border-radius: 50%; /* keep circle */
            overflow: hidden;
            display: grid;
            place-items: center;
            box-shadow: 0 0 0 1px var(--border-soft) inset;
        }

            .avatar img {
                max-width: 100%;
                max-height: 100%;
                display: block;
            }

        .title h1 {
            margin: 0 0 6px;
            font-weight: 700;
            font-size: 22px;
        }

        .title .muted {
            color: var(--muted);
            font-size: 14px;
        }

        /* Card/grid â€” square corners, gentle depth via neutral gradient + inner edge */
        .card {
            background: linear-gradient(180deg, var(--panel-2), var(--panel));
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 16px;
            box-shadow: 0 1px 0 var(--border-soft) inset, /* inner stroke for definition */
            0 8px 18px rgba(0,0,0,.35); /* soft lift */
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* Buttons: square, neutral hover */
        .btn, button {
            appearance: none;
            background: #0c0e12;
            color: #fff;
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 10px 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 1px 0 var(--border-soft) inset;
        }

            .btn.primary, button.primary {
                background: #0f1216;
                border-color: #fff;
                color: #fff;
            }

            .btn:hover, button:hover {
                background: #12151a;
            }

            .btn.is-active {
                box-shadow: 0 0 0 var(--bw) rgba(255,255,255,.18) inset;
            }

            .btn.is-down {
                box-shadow: 0 0 0 var(--bw) rgba(255,255,255,.10) inset;
            }

        /* --- Button polish --- */
        .btn, button {
            transition: background-color .12s ease, color .12s ease, border-color .12s ease;
        }

        /* make anchor-buttons never underline */
        a.btn,
        a.btn:hover,
        a.btn:focus,
        a.btn:active {
            text-decoration: none !important;
        }

        /* hover: invert (white bg, black text) */
        .btn:hover,
        button:hover {
            background: #fff !important;
            color: #000 !important;
            border-color: #fff !important;
        }

        /* active: revert to base look */
        .btn:active,
        button:active {
            background: #0c0e12 !important;
            color: #fff !important;
            border-color: var(--border) !important;
        }
        /* primary active uses its own base bg + white border */
        .btn.primary:active,
        button.primary:active {
            background: #0f1216 !important;
            color: #fff !important;
            border-color: #fff !important;
        }

        /* vote-state colors */
        :root {
            --vote-like-bg: #ffffff;
            --vote-like-fg: #000000;
            --vote-dislike-bg: #e6e6e6; /* a touch dimmer than full white */
            --vote-dislike-fg: #000000;
        }

        /* persistent highlight while selected */
        .btn.is-active { /* upvoted */
            background: var(--vote-like-bg) !important;
            color: var(--vote-like-fg) !important;
            border-color: #fff !important;
        }

        .btn.is-down { /* downvoted */
            background: var(--vote-dislike-bg) !important;
            color: var(--vote-dislike-fg) !important;
            border-color: #fff !important;
        }

            /* keep highlight on hover/focus (donâ€™t let the global hover invert fight it) */
            .btn.is-active:hover,
            .btn.is-active:focus-visible,
            .btn.is-down:hover,
            .btn.is-down:focus-visible {
                background: #fff !important;
                color: #000 !important;
                border-color: #fff !important;
            }

        /* Pills / field boxes â€“ match card chrome */
        .pill, .field-box {
            background: linear-gradient(180deg, #0f1216, #0d1014);
            color: var(--text);
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 10px;
            box-shadow: 0 1px 0 var(--border-soft) inset;
        }

        .pill {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            padding: 6px 10px;
        }

        a {
            color: var(--primary);
        }

        .muted {
            color: var(--muted);
        }

        /* Activity groups â€” same card treatment */
        .group {
            background: linear-gradient(180deg, var(--panel-2), var(--panel));
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 16px;
            margin: 16px 0;
            box-shadow: 0 1px 0 var(--border-soft) inset, 0 8px 18px rgba(0,0,0,.35);
        }

            .group h3 {
                margin: 0 0 10px;
                font-size: 16px;
            }

                .group h3 a {
                    color: var(--text);
                    text-decoration: none;
                }

                    .group h3 a:hover {
                        text-decoration: underline;
                    }

        /* Comments â€” boxed with subtle layering so it isnâ€™t a wall of outlines */
        .comment {
            background: linear-gradient(180deg, #0f1216, #0c0f13);
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 12px;
            margin-top: 12px;
            box-shadow: 0 1px 0 var(--border-soft) inset;
        }

            .comment .parent {
                background: linear-gradient(180deg, #0e1115, #0b0e12);
                color: var(--muted);
                border: var(--bw) solid var(--border);
                border-radius: 0;
                padding: 10px;
                margin-bottom: 10px;
                box-shadow: 0 1px 0 var(--border-soft) inset;
            }

        #load-more {
            margin: 14px 0 28px;
        }

        #empty, #msg {
            color: var(--muted);
        }

        .body {
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* replies container + single reply rows */
        .replies {
            margin-top: 10px;
        }

        .reply {
            background: linear-gradient(180deg, #101318, #0c0f13);
            border: var(--bw) solid var(--border);
            border-radius: 0;
            padding: 10px;
            margin-top: 10px;
            box-shadow: 0 1px 0 var(--border-soft) inset;
        }

            .reply .actions {
                display: flex;
                gap: 10px;
                margin-top: 8px;
            }

        .comment .reply-editor {
            margin-top: 10px;
        }
    </style>
</head>
<body class="theme-editor">
    <div class="container">
        <header>
            <div class="avatar"><img id="pfp" alt=""></div>
            <div class="title">
                <h1 id="hdr-name">@<span id="uname">â€¦</span></h1>
                <div class="muted">Profile: <span id="hdr-slug">â€¦</span> â€¢ Joined <span id="hdr-joined">â€¦</span></div>
            </div>
            <div class="actions" style="margin-left:auto">
                <a id="btn-edit" class="btn primary" href="#" style="display:none">Edit profile</a>
                <button id="btn-logout" class="btn" type="button" style="display:none">Log out</button>
            </div>
        </header>

        <!-- Bio -->
        <section class="card" id="bio-card" style="display:none">
            <h3 style="margin:0 0 10px">Bio</h3>
            <div id="bio" class="field-box"></div>
        </section>

        <!-- Activity -->
        <section class="card">
            <h3 style="margin:0 0 10px">Recent comments & replies</h3>
            <div id="groups"></div>
            <button id="load-more" class="btn" style="display:none">Load 10 more</button>
            <div id="empty" class="muted" style="display:none">No comments yet.</div>
            <div id="msg" class="muted"></div>
        </section>
    </div>

    <script>
        (function () {
            "use strict";
            const API_BASE = "http://localhost:3000/api";
            const $ = id => document.getElementById(id);

            const state = {
                slug: "", profile: null, isOwner: false,
                pleaTitleMap: new Map(),
                offset: 0, limit: 10, total: 0, loading: false,
                domGroups: new Map()
            };

            /* ---------- CSRF + API ---------- */
            async function fetchCsrf() {
                const r = await fetch(API_BASE.replace("/api", "") + "/api/csrf", { credentials: "include" });
                const j = await r.json().catch(() => ({}));
                const tok = j?.token ?? j?.csrfToken ?? j?.csrf ?? null;
                if (!r.ok || !tok) throw new Error("csrf");
                return tok;
            }
            async function api(path, opts = {}) {
                const method = (opts.method || "GET").toUpperCase();
                const headers = Object.assign({}, opts.headers || {});
                if (opts.body && !headers["content-type"]) headers["content-type"] = "application/json";
                if (method !== "GET" && !headers["x-csrf-token"]) headers["x-csrf-token"] = await fetchCsrf();
                const r = await fetch(API_BASE + path, { method, headers, credentials: "include", body: opts.body });
                const txt = await r.text(); let data; try { data = txt ? JSON.parse(txt) : {}; } catch { data = { raw: txt }; }
                if (!r.ok) { const err = new Error(data?.error || r.statusText); err.status = r.status; err.data = data; err.detail = data?.detail || txt; throw err; }
                return data;
            }

            /* ---------- utils ---------- */
            function extractSlugFromPath(path) {
                const p = path.replace(/\/+$/, "");
                const m = p.match(/^\/user\/([^\/?#]+)(?:[\/?#]|$)/i);
                return m ? decodeURIComponent(m[1]) : "";
            }
            const firstNonEmpty = (...v) => { for (const s of v) if (typeof s === "string" && s.trim()) return s.trim(); return ""; };
            const escapeHtml = s => String(s || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

            /* --- logout helper (tries a few common endpoints) --- */
            async function logout() {
                // best-effort CSRF
                let token = null;
                try { token = await fetchCsrf(); } catch { }
                const baseHeaders = { Accept: "application/json" };
                if (token) baseHeaders["X-CSRF-Token"] = token;

                const tries = [
                    { url: API_BASE + "/auth/logout", method: "POST" },
                    { url: API_BASE + "/logout", method: "POST" },
                    { url: API_BASE + "/auth/session", method: "DELETE" },
                    { url: API_BASE.replace("/api", "") + "/logout", method: "POST" } // non-namespaced fallback
                ];

                for (const t of tries) {
                    try {
                        const r = await fetch(t.url, { method: t.method, credentials: "include", headers: baseHeaders });
                        if (r.ok || r.status === 204) break;
                    } catch { /* keep trying */ }
                }

                // Refresh the page (or send to home if you prefer)
                location.reload();
            }

            /* ---------- header/bio ---------- */
            function renderHeader() {
                const u = state.profile; if (!u) return;

                $("uname").textContent = u.username || u.first_username || state.slug;
                $("hdr-slug").textContent = u.first_username || state.slug;
                try { $("hdr-joined").textContent = new Date(u.created_at).toLocaleDateString(); } catch { $("hdr-joined").textContent = "â€”"; }
                $("pfp").src = u.profile_photo || "";

                const bio = firstNonEmpty(u.bio_html, u.bio);
                if (bio && bio.trim()) { $("bio").innerHTML = bio; $("bio-card").style.display = ""; }
                else { $("bio-card").style.display = "none"; }

                const btnEdit = $("btn-edit");
                const btnLogout = $("btn-logout");

                if (u.is_me) {
                    btnEdit.style.display = "";
                    btnEdit.href = `/user/${encodeURIComponent(state.slug)}/edit`;

                    btnLogout.style.display = "";
                    btnLogout.onclick = (e) => { e.preventDefault(); logout(); };
                } else {
                    btnEdit.style.display = "none";
                    btnLogout.style.display = "none";
                    btnLogout.onclick = null;
                }
            }

            /* ---------- group helpers ---------- */
            function ensureGroup(pleaNum) {
                if (state.domGroups.has(pleaNum)) return state.domGroups.get(pleaNum);

                const wrap = document.createElement("div");
                wrap.className = "group";
                wrap.dataset.plea = String(pleaNum);

                const h = document.createElement("h3");
                const a = document.createElement("a");

                // ðŸ” new hash-style route:
                a.href = `/#${encodeURIComponent(pleaNum)}`;

                // placeholder â†’ real title will be filled in below
                a.textContent = state.pleaTitleMap.get(pleaNum) || `Plea #${pleaNum}`;
                h.appendChild(a);

                const list = document.createElement("div");
                list.className = "list";

                wrap.appendChild(h);
                wrap.appendChild(list);
                document.getElementById("groups").appendChild(wrap);
                state.domGroups.set(pleaNum, list);

                // ðŸ”Ž fetch & upgrade to actual title (same method as the hub)
                ensureTitleFor(pleaNum, a);

                return list;
            }

            /* ---------- voting ---------- */
            async function apiGetMyVote(pleaNum, id, fallback = 0) {
                if (fallback === 1 || fallback === -1) return fallback;
                const tries = [
                    `/comments/${encodeURIComponent(id)}/my_vote`,
                    `/comments/${encodeURIComponent(id)}/vote`,
                    `/pleas/${encodeURIComponent(pleaNum)}/comments/${encodeURIComponent(id)}/vote`
                ];
                for (const u of tries) {
                    try {
                        const j = await api(u);
                        if (j && (j.vote === 'up' || j.direction === 'up' || j.delta === 1 || j.value === 1 || j.liked === true)) return 1;
                        if (j && (j.vote === 'down' || j.direction === 'down' || j.delta === -1 || j.value === -1 || j.disliked === true)) return -1;
                        if (typeof j?.my_vote === 'number') return j.my_vote > 0 ? 1 : j.my_vote < 0 ? -1 : 0;
                    } catch { }
                }
                return 0;
            }
            async function apiSetMyVote(pleaNum, id, newVote) {
                try {
                    const j = await api(`/comments/${encodeURIComponent(id)}/vote`, {
                        method: "POST", body: JSON.stringify(newVote === 0 ? { vote: "none" } : { value: newVote })
                    });
                    if (j && (typeof j.likes !== "undefined" || typeof j.dislikes !== "undefined")) {
                        return { ok: true, likes: +j.likes || 0, dislikes: +j.dislikes || 0, my: (typeof j.my_vote === "number" ? j.my_vote : newVote) };
                    }
                    return { ok: true, likes: null, dislikes: null, my: newVote };
                } catch (e) {
                    if (newVote === 0) {
                        try { await api(`/comments/${encodeURIComponent(id)}/vote`, { method: "DELETE" }); return { ok: true, likes: null, dislikes: null, my: 0 }; }
                        catch { }
                    }
                    const mv = await apiGetMyVote(pleaNum, id, 0);
                    return { ok: true, likes: null, dislikes: null, my: mv };
                }
            }
            function makeVoteController({ pleaNum, id, likeBtn, dislikeBtn, initialUps = 0, initialDowns = 0, initialMy = 0, onCountsChanged }) {
                const st = { ups: +initialUps || 0, downs: +initialDowns || 0, my: (typeof initialMy === 'number' ? initialMy : 0), resolved: (initialMy === 1 || initialMy === -1) };
                const render = () => {
                    if (likeBtn) { likeBtn.textContent = `â–² ${st.ups}`; likeBtn.classList.toggle("is-active", st.my === 1); likeBtn.classList.remove("is-down"); }
                    if (dislikeBtn) { dislikeBtn.textContent = `â–¼ ${st.downs}`; dislikeBtn.classList.toggle("is-down", st.my === -1); dislikeBtn.classList.remove("is-active"); }
                };
                async function ensureKnownMy() { if (st.resolved) return; const v = await apiGetMyVote(pleaNum, id).catch(() => 0); if (v === 1 || v === -1 || v === 0) { st.my = v; st.resolved = true; render(); } }
                async function setMy(nextMy) {
                    likeBtn && (likeBtn.disabled = true); dislikeBtn && (dislikeBtn.disabled = true);
                    await ensureKnownMy(); const prev = st.my; if (nextMy === prev) nextMy = 0;
                    st.my = nextMy; render();
                    try {
                        const r = await apiSetMyVote(pleaNum, id, nextMy);
                        if (r.likes != null && r.dislikes != null) { st.ups = r.likes; st.downs = r.dislikes; }
                        else {
                            const after = (typeof r.my === 'number') ? r.my : nextMy;
                            const dUp = (after === 1 ? 1 : 0) - (prev === 1 ? 1 : 0);
                            const dDown = (after === -1 ? 1 : 0) - (prev === -1 ? 1 : 0);
                            st.ups = Math.max(0, st.ups + dUp);
                            st.downs = Math.max(0, st.downs + dDown);
                        }
                        st.my = (typeof r.my === 'number') ? r.my : nextMy; st.resolved = true; render(); onCountsChanged && onCountsChanged(st);
                        const verify = await apiGetMyVote(pleaNum, id).catch(() => st.my); if (verify !== st.my) { st.my = verify; render(); }
                    } finally {
                        likeBtn && (likeBtn.disabled = false); dislikeBtn && (dislikeBtn.disabled = false);
                    }
                }
                likeBtn && likeBtn.addEventListener("click", () => setMy(1));
                dislikeBtn && dislikeBtn.addEventListener("click", () => setMy(-1));
                render(); ensureKnownMy();
                return { state: st, render, setMy };
            }

            /* ---------- reply helpers ---------- */
            const isReplyItem = (it) =>
                !!(it.parent || it.parent_id != null || it.in_reply_to != null || it.reply_to != null || it.is_reply === true);

            function nRepliesCount(it) {
                const a = it.reply_count ?? it.replies_count ?? it.children_count;
                if (Number.isFinite(a)) return +a;
                if (Array.isArray(it.replies)) return it.replies.length;
                return 0;
            }
            async function apiReplies(parentId) {
                const j = await api(`/comments/${encodeURIComponent(parentId)}/replies`);
                return Array.isArray(j?.items) ? j.items : (Array.isArray(j) ? j : []);
            }

            /* ---------- compose/edit/delete (editor mounts beneath the comment) ---------- */
            function openInlineEditor(opts, mountAfter) {
                // ensure single editor under the same comment
                const root = mountAfter?.closest?.('.comment') || document;
                root.querySelectorAll('.reply-editor').forEach(n => n.remove());

                const ed = document.createElement("div");
                ed.className = "comment reply-editor";
                ed.innerHTML = `
                      <textarea style="width:100%;min-height:80px" class="field-box">${escapeHtml(opts.initial || "")}</textarea>
                      <div class="actions" style="margin-top:8px">
                        <button class="btn primary js-ok">Post</button>
                        <button class="btn js-cancel" type="button">Cancel</button>
                      </div>`;
                const ta = ed.querySelector("textarea");
                ed.querySelector(".js-ok").addEventListener("click", async () => {
                    const val = ta.value.trim(); if (!val) return; await opts.onSubmit(val, ed);
                });
                ed.querySelector(".js-cancel").addEventListener("click", () => ed.remove());

                if (mountAfter) mountAfter.insertAdjacentElement('afterend', ed);
                else (document.getElementById("groups")).appendChild(ed);
            }

            async function editComment(id, text) {
                const form = new URLSearchParams({ _method: "PATCH", body: text });
                try {
                    await fetch(API_BASE + `/comments/${encodeURIComponent(id)}`, {
                        method: "POST", credentials: "include",
                        headers: { "Accept": "application/json", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
                        body: form.toString()
                    }).then(r => { if (!r.ok) throw 0; });
                    return;
                } catch { }
                await api(`/comments/${encodeURIComponent(id)}`, { method: "PATCH", body: JSON.stringify({ body: text }) });
            }
            async function deleteComment(id) {
                const form = new URLSearchParams({ _method: "DELETE" });
                try {
                    const r = await fetch(API_BASE + `/comments/${encodeURIComponent(id)}`, {
                        method: "POST", credentials: "include",
                        headers: { "Accept": "application/json", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
                        body: form.toString()
                    });
                    if (r.ok || r.status === 204) return true;
                } catch { }
                await api(`/comments/${encodeURIComponent(id)}`, { method: "DELETE" }); return true;
            }

            /* ---------- tiny renderer for a single reply row ---------- */
            function renderOneReply(r, fallbackPleaNum) {
                const wrap = document.createElement("div");
                wrap.className = "reply";

                const body = document.createElement("div");
                body.className = "body";
                body.textContent = r.body || "";
                wrap.appendChild(body);

                const meta = document.createElement("div");
                meta.className = "muted";
                meta.textContent = new Date(r.created_at || r.timestamp || Date.now()).toLocaleString();
                wrap.appendChild(meta);

                const row = document.createElement("div");
                row.className = "actions";
                const likeBtn = document.createElement("button");
                likeBtn.className = "btn";
                likeBtn.textContent = `â–² ${r.likes | 0}`;
                const dislikeBtn = document.createElement("button");
                dislikeBtn.className = "btn";
                dislikeBtn.textContent = `â–¼ ${r.dislikes | 0}`;
                row.appendChild(likeBtn);
                row.appendChild(dislikeBtn);
                wrap.appendChild(row);

                const vc = makeVoteController({
                    pleaNum: r.plea_num ?? fallbackPleaNum,
                    id: r.id,
                    likeBtn,
                    dislikeBtn,
                    initialUps: r.likes | 0,
                    initialDowns: r.dislikes | 0,
                    initialMy: 0
                });
                apiGetMyVote(r.plea_num ?? fallbackPleaNum, r.id).then(v => {
                    if (v !== vc.state.my) { vc.state.my = v; vc.render(); }
                }).catch(() => { });

                return wrap;
            }

            /* ---------- render item (with replies + correct editor placement) ---------- */
            function renderItem(container, item) {
                const node = document.createElement("div"); node.className = "comment"; node.dataset.commentId = item.id;

                // If this item is a reply, show parent context + NEVER show a Reply button
                const thisIsReply = isReplyItem(item);
                if (thisIsReply && item.parent) {
                    const parent = document.createElement("div");
                    parent.className = "parent";
                    const who = item.parent.author_username || item.parent.author_first_username || "User";
                    parent.innerHTML = `<div class="muted">In reply to <b>${escapeHtml(who)}</b>:</div><div>${escapeHtml(item.parent.body || "")}</div>`;
                    node.appendChild(parent);
                }

                const body = document.createElement("div"); body.className = "body"; body.innerHTML = escapeHtml(item.body || ""); node.appendChild(body);

                const meta = document.createElement("div");
                meta.className = "muted";
                try { meta.textContent = new Date(item.created_at).toLocaleString(); } catch { meta.textContent = ""; }
                node.appendChild(meta);

                const actions = document.createElement("div"); actions.className = "actions";
                const likeBtn = document.createElement("button"); likeBtn.className = "btn js-like"; likeBtn.textContent = `â–² ${item.likes | 0}`;
                const dislikeBtn = document.createElement("button"); dislikeBtn.className = "btn js-dislike"; dislikeBtn.textContent = `â–¼ ${item.dislikes | 0}`;
                actions.appendChild(likeBtn); actions.appendChild(dislikeBtn);

                const vc = makeVoteController({
                    pleaNum: item.plea_num, id: item.id, likeBtn, dislikeBtn,
                    initialUps: item.likes | 0, initialDowns: item.dislikes | 0, initialMy: 0,
                    onCountsChanged: s => { likeBtn.textContent = `â–² ${s.ups}`; dislikeBtn.textContent = `â–¼ ${s.downs}`; }
                });
                apiGetMyVote(item.plea_num, item.id).then(v => { if (v !== vc.state.my) { vc.state.my = v; vc.render(); } }).catch(() => { });

                // Replies UI (top-level comments only)
                const isTopLevel = !thisIsReply;
                let repliesWrap = null, repliesList = null, toggleRepliesBtn = null;

                if (isTopLevel) {
                    repliesWrap = document.createElement("div");
                    repliesWrap.className = "replies";
                    repliesWrap.style.display = "none";

                    repliesList = document.createElement("div");
                    repliesList.className = "replies-list";
                    repliesWrap.appendChild(repliesList);

                    toggleRepliesBtn = document.createElement("button");
                    toggleRepliesBtn.className = "btn js-toggle-replies";
                    toggleRepliesBtn.style.display = "none";     // hidden until we confirm replies exist
                    toggleRepliesBtn.textContent = "View replies (0)";
                    actions.appendChild(toggleRepliesBtn);

                    async function refreshReplies(openAfter = false) {
                        const reps = await apiReplies(item.id).catch(() => []);
                        repliesList.innerHTML = "";
                        if (!reps.length) {
                            const empty = document.createElement("div");
                            empty.className = "muted";
                            empty.textContent = "(No replies)";
                            repliesList.appendChild(empty);
                            toggleRepliesBtn.textContent = "View replies (0)";
                            toggleRepliesBtn.style.display = "none";
                        } else {
                            for (const r of reps) repliesList.appendChild(renderOneReply(r, item.plea_num));
                            toggleRepliesBtn.style.display = "";
                            toggleRepliesBtn.textContent = openAfter ? "Hide replies" : `View replies (${reps.length})`;
                        }
                        if (openAfter) repliesWrap.style.display = "";
                    }

                    // Initial presence check (uses reply_count if available, otherwise fetch once)
                    (async () => {
                        const known = nRepliesCount(item);
                        if (known > 0) { toggleRepliesBtn.style.display = ""; toggleRepliesBtn.textContent = `View replies (${known})`; }
                        else {
                            const reps = await apiReplies(item.id).catch(() => []);
                            if (reps.length > 0) { toggleRepliesBtn.style.display = ""; toggleRepliesBtn.textContent = `View replies (${reps.length})`; }
                        }
                    })();

                    toggleRepliesBtn.addEventListener("click", async () => {
                        const open = repliesWrap.style.display !== "none";
                        if (open) {
                            repliesWrap.style.display = "none";
                            const cnt = Math.max(0, repliesList.querySelectorAll(".reply").length);
                            toggleRepliesBtn.textContent = `View replies (${cnt})`;
                        } else {
                            repliesWrap.style.display = "";
                            await refreshReplies(false);
                            toggleRepliesBtn.textContent = "Hide replies";
                        }
                    });

                    // Reply button (ONLY for top-level)
                    const replyBtn = document.createElement("button");
                    replyBtn.className = "btn js-reply";
                    replyBtn.textContent = "Reply";
                    actions.appendChild(replyBtn);

                    replyBtn.addEventListener("click", async () => {
                        // open replies so the editor is clearly *beneath* the comment
                        repliesWrap.style.display = "";
                        await (async () => {
                            const reps = await apiReplies(item.id).catch(() => []);
                            repliesList.innerHTML = "";
                            if (!reps.length) {
                                const empty = document.createElement("div");
                                empty.className = "muted";
                                empty.textContent = "(No replies)";
                                repliesList.appendChild(empty);
                            } else {
                                for (const r of reps) repliesList.appendChild(renderOneReply(r, item.plea_num));
                            }
                            toggleRepliesBtn.style.display = "";
                            toggleRepliesBtn.textContent = "Hide replies";
                        })();

                        // mount editor *after* repliesWrap => beneath comment
                        openInlineEditor({
                            plea_num: item.plea_num,
                            parent_id: item.id,
                            onSubmit: async (text, ed) => {
                                await api(`/pleas/${item.plea_num}/comments`, { method: "POST", body: JSON.stringify({ parent_id: item.id, body: text }) });
                                ed.remove();
                                // refresh + keep open + update label
                                const reps = await apiReplies(item.id).catch(() => []);
                                repliesList.innerHTML = "";
                                if (!reps.length) {
                                    const empty = document.createElement("div");
                                    empty.className = "muted";
                                    empty.textContent = "(No replies)";
                                    repliesList.appendChild(empty);
                                } else {
                                    for (const r of reps) repliesList.appendChild(renderOneReply(r, item.plea_num));
                                }
                                toggleRepliesBtn.style.display = "";
                                toggleRepliesBtn.textContent = "Hide replies";
                            }
                        }, actions);
                    });
                }

                // Owner controls
                if (state.isOwner) {
                    const editBtn = document.createElement("button"); editBtn.className = "btn js-edit"; editBtn.textContent = "Edit";
                    const delBtn = document.createElement("button"); delBtn.className = "btn js-del"; delBtn.textContent = "Delete";
                    actions.appendChild(editBtn); actions.appendChild(delBtn);

                    editBtn.addEventListener("click", () => {
                        const mountTarget = (isTopLevel && repliesWrap) ? repliesWrap : node; // still beneath content
                        openInlineEditor({
                            initial: item.body || "",
                            onSubmit: async (text, ed) => { await editComment(item.id, text); ed.remove(); body.textContent = text; }
                        }, mountTarget);
                    });
                    delBtn.addEventListener("click", async () => {
                        if (!confirm("Delete this comment?")) return;
                        await deleteComment(item.id); node.remove();
                    });
                }

                node.appendChild(actions);
                if (isTopLevel && repliesWrap) node.appendChild(repliesWrap); // replies live above the editor
                container.appendChild(node);
            }

            /* ---------- activity loading ---------- */
            async function loadMore() {
                if (state.loading) return; state.loading = true; $("load-more").disabled = true;
                try {
                    const j = await api(`/users/${encodeURIComponent(state.slug)}/activity?offset=${state.offset}&limit=${state.limit}`);
                    state.total = j.total | 0; state.isOwner = !!j.is_me;
                    if (state.profile && state.profile.is_me !== j.is_me) { state.profile.is_me = j.is_me; renderHeader(); }

                    if (!j.items || j.items.length === 0) {
                        if (state.offset === 0) $("empty").style.display = ""; $("load-more").style.display = "none"; return;
                    }
                    $("empty").style.display = "none";

                    for (const it of j.items) {
                        const group = ensureGroup(it.plea_num);
                        renderItem(group, it);
                    }
                    state.offset += j.items.length;
                    $("load-more").style.display = (state.offset < state.total) ? "" : "none";
                } catch (e) { msg(e); }
                finally { state.loading = false; $("load-more").disabled = false; }
            }
            function resetAndLoad() {
                state.offset = 0; state.total = 0; state.domGroups.clear();
                $("groups").innerHTML = ""; loadMore();
            }

            // --- title helpers (mirror the plea hub approach) ---
            async function fetchPleaTitleByNum(num) {
                // try both with and without trailing slash
                const candidates = [`/${encodeURIComponent(num)}/`, `/${encodeURIComponent(num)}`];
                for (const u of candidates) {
                    try {
                        const res = await fetch(u, { cache: 'no-store' });
                        if (!res.ok) continue;
                        const html = await res.text();
                        const doc = new DOMParser().parseFromString(html, 'text/html');
                        const raw = (doc.querySelector('.plea-number')?.textContent?.trim() || doc.title || '').trim();
                        const title = raw.replace(/^\s*plea\s*[:#-]?\s*/i, '').trim(); // strip "Plea #", "Plea:", etc.
                        if (title) return title;
                    } catch { }
                }
                return null;
            }

            function ensureTitleFor(pleaNum, anchorEl) {
                if (state.pleaTitleMap.has(pleaNum)) {
                    anchorEl.textContent = state.pleaTitleMap.get(pleaNum);
                    return;
                }
                fetchPleaTitleByNum(pleaNum).then(title => {
                    if (!title) return;
                    state.pleaTitleMap.set(pleaNum, title);
                    anchorEl.textContent = title;
                }).catch(() => { });
            }

            /* ---------- titles ---------- */
            async function loadPleaTitles() {
                try {
                    const j = await api(`/plealist`);
                    const arr = Array.isArray(j) ? j
                        : Array.isArray(j?.items) ? j.items
                            : Array.isArray(j?.pleas) ? j.pleas : [];
                    for (const it of arr) {
                        const id = it.id ?? it.num ?? it.plea_num ?? it.pleaId ?? it.pleaID;
                        const ttl = it.title ?? it.name ?? null;
                        if (id != null && ttl) state.pleaTitleMap.set(+id, String(ttl));
                    }
                } catch { }
            }

            function msg(e) {
                const m = typeof e === "string" ? e : (e?.detail || e?.message || "Error");
                $("msg").textContent = m; setTimeout(() => { $("msg").textContent = ""; }, 3000);
            }

            /* ---------- boot ---------- */
            async function init() {
                state.slug = extractSlugFromPath(location.pathname) || "";
                if (!state.slug) { msg("Bad URL"); return; }
                $("hdr-slug").textContent = state.slug;

                const prof = await api(`/users/by-first/${encodeURIComponent(state.slug)}`).catch(() => null);
                state.profile = prof?.user || null;
                if (!state.profile) { msg("Profile not found"); return; }
                renderHeader();

                await loadPleaTitles();
                $("load-more").addEventListener("click", loadMore);
                await loadMore();
            }

            if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init); else init();
        })();
    </script>
    <script>
        (function mountPleaHubBtnExact() {
            'use strict';

            const HUB_URL = '/pleas/';
            const ICON_SRC = '/icons/plea-hub.png';
            const STYLE_ID = 'plea-hub-btn-style';

            // Remove any prior injected styles for the button
            const prev = document.getElementById(STYLE_ID);
            if (prev) prev.remove();

            // Inject the exact CSS used by the reader (matches main styles.css)
            function injectExactStyles() {
                const s = document.createElement('style');
                s.id = STYLE_ID;
                s.textContent = `
:root{
          --hub-native:21;
          --hub-scale:3;
          --hub-gap:20px;
          --sbw:0px; /* JS updates this */
}
@media (max-width:480px){ :root{ --hub-scale:2; } }
@media (min-width:1024px){ :root{ --hub-scale:4; } }

.plea-hub-btn{
          position:fixed;
          top:calc(var(--hub-gap) + env(safe-area-inset-top));
          right:calc(var(--hub-gap) + env(safe-area-inset-right) + var(--sbw,0px));
          width:calc(var(--hub-native) * var(--hub-scale) * 1px);
          height:calc(var(--hub-native) * var(--hub-scale) * 1px);
          display:inline-flex;
          align-items:center;
          justify-content:center;
          padding:0;
          border:none;
          background:transparent;
          border-radius:0;
          text-decoration:none;
          z-index:10050;
          opacity:0;              /* will fade to .5 */
          transition:opacity .3s ease;
          pointer-events:auto;
          touch-action:manipulation;
          overflow:hidden;
}
.plea-hub-btn.is-show{ opacity:.5; }
.plea-hub-btn:hover,
.plea-hub-btn:focus-visible{ opacity:.8; }
.plea-hub-btn:active{ opacity:1; }

.plea-hub-btn img{
          width:100%;
          height:100%;
          display:block;
          image-rendering:pixelated;
          image-rendering:crisp-edges;
          image-rendering:-moz-crisp-edges;
          -ms-interpolation-mode:nearest-neighbor;
}
`;
                document.head.appendChild(s);
            }

            // Same stash behavior the reader uses (no-op on non-plea pages)
            function stashReturnTarget() {
                const m = location.pathname.match(/\/(\d{1,6})\/?$/);
                if (m) { try { sessionStorage.setItem('plea:return', String(m[1])); } catch { } }
            }

            // Keep --sbw (scrollbar width) accurate so right offset matches reader
            function updateSBW() {
                const sw = window.innerWidth - document.documentElement.clientWidth;
                document.documentElement.style.setProperty('--sbw', (sw > 0 ? sw : 0) + 'px');
            }

            // Build exactly like main.js â†’ addPleaHubButton()
            function buildBtn() {
                if (document.querySelector('.plea-hub-btn')) return; // already mounted

                const a = document.createElement('a');
                a.href = HUB_URL;
                a.className = 'plea-hub-btn';
                a.setAttribute('aria-label', 'Open Plea Select');

                const img = new Image();
                img.src = ICON_SRC;
                img.alt = 'Plea Select';
                img.decoding = 'async';
                img.loading = 'eager';
                img.draggable = false;

                a.appendChild(img);
                document.body.appendChild(a);

                a.addEventListener('click', () => { stashReturnTarget(); }, { capture: true });

                requestAnimationFrame(() => a.classList.add('is-show'));
            }

            // Escape â†’ go to hub (reader UX)
            function bindEscapeShortcut() {
                const handler = (e) => {
                    const tag = (e.target && e.target.tagName || '').toLowerCase();
                    if (['input', 'textarea', 'select'].includes(tag) || e.target?.isContentEditable) return;
                    if (e.repeat) return;
                    if (e.key === 'Escape' || e.key === 'Esc') {
                        e.preventDefault(); e.stopPropagation();
                        stashReturnTarget();
                        const href = document.querySelector('.plea-hub-btn')?.href || HUB_URL;
                        window.location.assign(href);
                    }
                };
                window.addEventListener('keydown', handler, { capture: true });
            }

            function mount() {
                injectExactStyles();
                updateSBW();
                window.addEventListener('resize', updateSBW, { passive: true });
                buildBtn();
                bindEscapeShortcut();
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', mount, { once: true });
            } else {
                mount();
            }
        })();
    </script>
    <script>
        /* ===== Auth Bar (profile view) ===== */
        (() => {
            const API = "http://localhost:3000/api";        // fallback (global API_BASE isn't visible here)
            const ASSET_BASE = "/web";
            const OVERLAY_JS = ASSET_BASE + "/authOverlay.js";
            const OVERLAY_CSS = ASSET_BASE + "/authOverlay.css";

            if (window.DPAuthBar && typeof window.DPAuthBar.ensure === "function") {
                if (document.readyState === "loading") {
                    document.addEventListener("DOMContentLoaded", () => window.DPAuthBar.ensure(), { once: true });
                } else { window.DPAuthBar.ensure(); }
                return;
            }

            function loadStyle(href) { try { const l = document.createElement("link"); l.rel = "stylesheet"; l.href = href; document.head.appendChild(l); } catch { } }
            function loadScript(src) {
                return new Promise((res, rej) => {
                    const s = document.createElement("script"); s.src = src; s.defer = true;
                    s.onload = res; s.onerror = () => rej(new Error("Failed to load " + src)); document.head.appendChild(s);
                });
            }
            async function getMe() {
                try { const r = await fetch(API + "/auth/me", { credentials: "include" }); return r.ok ? r.json() : { user: null }; }
                catch { return { user: null }; }
            }

            function injectStyles() {
                if (document.getElementById("dp-authbar-style")) return;
                const s = document.createElement("style");
                s.id = "dp-authbar-style";
                s.textContent = `
#dp-authbar{
      position:fixed; top:12px; left:12px; z-index:10060;
      display:flex; align-items:center; gap:10px;
      background:transparent; color:#fff; padding:0; border:none; border-radius:0;
      font-family:'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
      line-height:1;
}
#dp-authprefix{ opacity:.95; }
#dp-authlink{
      display:inline-flex; align-items:center; gap:8px;
      color:#fff; text-decoration:none; cursor:pointer; outline:none;
}
#dp-authlink:hover{ text-decoration:underline; }
#dp-authlink:focus-visible{ outline:2px solid #fff; outline-offset:2px; }
#dp-authname{ font-weight:600; }
#dp-authavatar{
      width:26px; height:26px; display:block;
      border-radius:50%; object-fit:cover; background:#000; border:2px solid #fff;
}
#dp-logout-btn{ display:none; } /* reserved */
`;
                document.head.appendChild(s);
            }

            const AVATAR_FALLBACK = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64">
          <rect width="100%" height="100%" fill="#000"/>
          <circle cx="32" cy="24" r="14" fill="#fff"/>
          <rect x="10" y="40" width="44" height="16" rx="8" fill="#fff"/>
        </svg>`);

            async function resolveProfileHrefFor(user) {
                const first = (user?.first_username || user?.firstUsername || "").trim();
                if (first) return "/user/" + encodeURIComponent(first);
                const uname = (user?.username || "").trim();
                if (!uname) return null;

                const tries = [
                    `${API}/users/by_username/${encodeURIComponent(uname)}`,
                    `${API}/users/resolve?username=${encodeURIComponent(uname)}`
                ];
                for (const url of tries) {
                    try {
                        const r = await fetch(url, { credentials: "include", headers: { Accept: "application/json" } });
                        const j = await r.json().catch(() => ({}));
                        const fx = j?.first_username || j?.user?.first_username || j?.firstUsername || j?.user?.firstUsername;
                        if (fx) return "/user/" + encodeURIComponent(String(fx).trim());
                    } catch { }
                }
                return "/user/" + encodeURIComponent(uname);
            }

            function mount() {
                injectStyles();
                if (document.getElementById("dp-authbar")) return;

                const bar = document.createElement("div");
                bar.id = "dp-authbar";
                bar.innerHTML = `
          <span id="dp-authprefix" aria-hidden="true">User:</span>
          <a id="dp-authlink" href="#"></a>
          <button id="dp-logout-btn" type="button">Sign out</button>
        `;
                document.body.appendChild(bar);

                const authLink = bar.querySelector("#dp-authlink");
                authLink.addEventListener("click", (e) => {
                    if (authLink.getAttribute("data-state") === "logged-out") {
                        e.preventDefault();
                        if (window.DP && DP.openAuth) DP.openAuth();
                        else alert("Login UI not loaded â€” check " + OVERLAY_JS);
                    }
                });

                // refresh after overlay login
                window.DP = window.DP || {};
                const prev = DP.syncAfterLogin;
                DP.syncAfterLogin = async () => { try { if (prev) await prev(); } finally { await refresh(); } };
            }

            async function refresh() {
                const bar = document.getElementById("dp-authbar");
                if (!bar) return;
                const prefixEl = bar.querySelector("#dp-authprefix");
                const authLink = bar.querySelector("#dp-authlink");

                const { user } = await getMe();

                if (user) {
                    const uname = (user.username || user.first_username || "me").trim();
                    const pfp = (user.profile_photo || user.photo || "").trim() || AVATAR_FALLBACK;
                    const href = await resolveProfileHrefFor(user);

                    prefixEl.style.display = "";
                    authLink.setAttribute("data-state", "logged-in");
                    authLink.setAttribute("href", href || "#");
                    authLink.innerHTML = `
            <img id="dp-authavatar" alt="" src="${pfp}">
            <span id="dp-authname">${uname}</span>
          `;
                    authLink.onclick = null;
                } else {
                    prefixEl.style.display = "none";
                    authLink.setAttribute("data-state", "logged-out");
                    authLink.setAttribute("href", "#");
                    authLink.textContent = "User Login";
                }
            }

            async function ensure() {
                try { loadStyle(OVERLAY_CSS); } catch { }
                let overlayOk = true;
                try { await loadScript(OVERLAY_JS); } catch (e) { overlayOk = false; console.warn(e.message); }
                window.DP = window.DP || {};
                if (overlayOk && DP.init) DP.init({ apiBase: API });

                mount();
                await refresh();
            }

            window.DPAuthBar = { ensure, refresh };

            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => ensure(), { once: true });
            } else {
                ensure();
            }
        })();
    </script>
</body>
</html>
