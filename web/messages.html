<!doctype html>
<meta charset="utf-8">
<title>Messages</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/web/messages.css">
<link rel="preload" href="/fonts/Voice1.woff2" as="font" type="font/woff2" crossorigin>

<div class="wrap">
    <aside class="left">
        <div class="head">Direct Messages</div>
        <div class="tools">
            <input id="conv-q" class="search-input" placeholder="Search conversations…">
            <button id="btn-newdm" class="iconbtn" title="Start a conversation"><img src="/web/icons/new-dm.png" alt="+"></button>
            <button id="btn-newgroup" class="iconbtn" title="Create a group"><img src="/web/icons/new-group.png" alt="◎"></button>
        </div>
        <div id="convs"></div>
    </aside>

    <main class="right">
        <div class="chat-head">
            <img id="chat-pfp" class="chat-pfp" src="/web/default-avatar.png" alt="">
            <div class="chat-title" id="chat-title">Pick a conversation</div>
            <div class="spacer"></div>
            <button id="chat-menu-btn" class="iconbtn" title="Options">⋮</button>
            <div id="chat-menu" class="menu"></div>
        </div>

        <div class="msgs" id="msgs">
            <div id="pad-top"></div>
            <button id="jump" class="jump btn" style="display:none">Jump to present ↓</button>
            <div id="pad-bottom"></div>
        </div>

        <div class="composer">
            <div>
                <textarea id="text" maxlength="10000" placeholder="Message…"></textarea>
                <div class="chips" id="att-chips"></div>
                <div class="warn" id="rec-warn" style="display:none"></div>
            </div>
            <div class="col">
                <button class="btn" id="btn-attach">Attach</button>
                <button class="btn" id="btn-voice">Hold to record</button>
                <button class="btn" id="btn-send">Send</button>
                <input type="file" id="file" multiple style="display:none">
            </div>
        </div>
    </main>
</div>

<!-- People picker overlay (DM / group create / edit / view) -->
<div id="overlay" class="overlay" role="dialog" aria-modal="true">
    <div class="sheet" id="sheet">
        <h3 id="sheet-title">Start a conversation</h3>
        <div class="picker-bar">
            <input id="user-q" class="search-input" placeholder="Search friends…">
        </div>
        <div id="user-list" class="list"></div>
        <div class="bottom-center" id="group-cta" style="display:none">
            <div id="selected-chips"></div>
            <div style="display:flex; gap:8px;">
                <button class="btn" id="btn-cancel">Cancel</button>
                <button class="btn" id="btn-group-submit" disabled>Create Group</button>
            </div>
        </div>
    </div>
</div>

<script src="/web/vendor/ffmpeg/umd/ffmpeg.js"></script>
<script src="/web/messages/compressors.js"></script>

<script>
    (() => {
        const API = 'http://localhost:3000/api';
        const $ = id => document.getElementById(id);

        /* ---------------- state ---------------- */
        const state = {
            convId: null, meId: 0,
            allConvs: [], filteredConvs: [],
            lastMsgId: 0, oldestMsgId: null, nextBefore: null,
            es: null, poll: null,
            uploading: false,
            pendingFiles: [],
            recording: { active: false, chunks: [], size: 0, rec: null, warnShown: false },

            // convo + meta
            convMeta: new Map(),         // convId -> { name, photo, is_group, color }
            convRowEls: new Map(),       // convId -> DOM div.conv
            convUserOg: new Map(),       // convId -> other @username (1:1)
            userCache: new Map(),        // og -> { username, photo, display_name, raw }
            convItems: new Map(),        // convId -> raw item

            // group/menu
            audioPlayers: new Map(), // attId -> { root, audio, btn, track, fill, curEl, totEl, totalMs, dragging }
            audioDurEls: new Map(), // attId -> { audio: HTMLAudioElement, chip: HTMLElement }
            msgColorsByConv: new Map(),
            convDetailById: new Map(),
            currentConvDetail: null,     // {id,is_group,title,owner_id,is_owner,members:[]}
            pickerMode: 'dm',            // 'dm' | 'group-create' | 'group-edit' | 'view-members'
            selectedIds: new Set(),      // picked user_ids (others)
            initialSelectedIds: new Set(),
            friendsCache: [],
            idToFriend: new Map(),

            renderedMsgIds: new Set(),
            fetchingAfter: false,
            meSlug: '',
        };

        const LASTDM_KEY = 'dp:lastdm';
        const META_CACHE_KEY = 'dp:metaCache';
        let _metaSaveTimer = null;

        /* ---------------- defaults & helpers ---------------- */
        const DEFAULT_PFP_DM = '/web/default-avatar.png';
        const DEFAULT_PFP_GROUP = '/web/default-groupavatar.png';

        const GROUP_COLORS = [
            { key: 'blue', val: '#3b82f6' },
            { key: 'green', val: '#22c55e' },
            { key: 'purple', val: '#a855f7' },
            { key: 'orange', val: '#f97316' },
            { key: 'pink', val: '#ec4899' },
            { key: 'teal', val: '#14b8a6' },
            { key: 'yellow', val: '#eab308' },
            { key: 'red', val: '#ef4444' },
        ];
        function randomGroupColor() { return GROUP_COLORS[(Math.random() * GROUP_COLORS.length) | 0]; }
        const afterPaint = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        function esc(s) { return String(s || '').replace(/[&<>]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m])) }
        function fmt(t) { try { return new Date(t).toLocaleString() } catch { return '' } }
        function saveLastDM() { try { localStorage.setItem(LASTDM_KEY, JSON.stringify({ meId: state.meId | 0, convId: state.convId | 0, at: Date.now() })) } catch { } }
        function loadLastDM() { try { return JSON.parse(localStorage.getItem(LASTDM_KEY) || 'null') } catch { return null } }
        function nearBottom(px = 60) { const el = $('msgs'); return (el.scrollHeight - el.scrollTop - el.clientHeight) < px }
        function scrollToBottom() { const el = $('msgs'); el.scrollTop = el.scrollHeight + 9999 }

        const pickUsername = o => o?.first_username || o?.username || o?.handle || null;
        const pickPhoto = o => o?.profile_photo || o?.profile_photo_url || o?.photo || o?.photo_url || o?.avatar || o?.avatar_url || o?.picture || o?.image || o?.image_url || null;
        const pickName = o => o?.display_name || o?.name || o?.username || o?.first_username || o?.handle || o?.title || null;

        const HIDE_BEFORE_KEY = 'dp:hideBefore';
        function _getHideMap() { try { return JSON.parse(localStorage.getItem(HIDE_BEFORE_KEY) || '{}'); } catch { return {}; } }
        function _setHideMap(m) { try { localStorage.setItem(HIDE_BEFORE_KEY, JSON.stringify(m)); } catch { } }
        function getHideBeforeId(convId) { const m = _getHideMap(); return m[convId] | 0; }
        function setHideBeforeId(convId, id) { const m = _getHideMap(); m[convId] = id | 0; _setHideMap(m); }
        function clearHideBeforeId(convId) { const m = _getHideMap(); delete m[convId]; _setHideMap(m); }

        function filterHidden(items, convId = state.convId) {
            const cut = getHideBeforeId(convId) | 0;
            if (!cut) return items || [];
            return (items || []).filter(m => (m.id | 0) > cut);
        }

        function joinNames(arr) {
            const a = (arr || []).filter(Boolean);
            if (a.length === 0) return 'Group';
            if (a.length === 1) return a[0];
            if (a.length === 2) return a[0] + ' & ' + a[1];
            return a.slice(0, -1).join(', ') + ' & ' + a[a.length - 1];
        }
        function labelForMember(u) {
            return pickName(u) || 'user';
        }
        function computeDefaultGroupTitle(members) {
            return joinNames((members || []).map(labelForMember));
        }

        function saveMetaCache() {
            const out = {
                convUserOg: Array.from(state.convUserOg.entries()),
                userCache: Array.from(state.userCache.entries()),
                convMeta: Array.from(state.convMeta.entries()),
            };
            try { localStorage.setItem(META_CACHE_KEY, JSON.stringify(out)); } catch { }
        }
        function scheduleSaveMeta() {
            clearTimeout(_metaSaveTimer);
            _metaSaveTimer = setTimeout(saveMetaCache, 120);
        }
        function loadMetaCache() {
            try {
                const j = JSON.parse(localStorage.getItem(META_CACHE_KEY) || 'null');
                if (!j) return;
                (j.convUserOg || []).forEach(([k, v]) => state.convUserOg.set(+k || k, v));
                (j.userCache || []).forEach(([k, v]) => state.userCache.set(k, v));
                (j.convMeta || []).forEach(([k, v]) => state.convMeta.set(+k || k, v));
            } catch { }
        }

        /* ---------------- API core ---------------- */
        async function api(path, opts = {}) {
            const headers = Object.assign({ 'Accept': 'application/json' }, opts.headers || {});
            const isJSON = opts.body && !(opts.body instanceof FormData);
            if (isJSON && !headers['Content-Type']) headers['Content-Type'] = 'application/json';
            const url = API + path;
            const r = await fetch(url, { credentials: 'include', method: opts.method || 'GET', headers, body: isJSON ? JSON.stringify(opts.body) : opts.body });
            const t = await r.text(); let d; try { d = t ? JSON.parse(t) : {} } catch { d = { raw: t } }
            if (!r.ok) { const e = new Error(d?.error || r.statusText); e.status = r.status; e.detail = d?.detail || t; throw e; }
            return d;
        }
        async function getMe() {
            const j = await api('/auth/me');
            state.meId = j?.user?.id || 0;
            state.meSlug = j?.user?.first_username || j?.user?.username || '';
            return state.meId;
        }
        // ---- Server-backed message color helpers ----
        async function fetchMsgColors(convId) {
            const j = await api(`/dm/conversations/${convId}/message_colors`);
            return j?.colors || {}; // { [user_id]: '#hex' }
        }

        // Set ONLY my color (server infers me from auth)
        async function setMyMsgColor(convId, color /* '#hex' or null to clear */) {
            return api(`/dm/conversations/${convId}/message_colors/me`, {
                method: 'PATCH',
                body: { color }
            });
        }

        // Patch multiple users' colors at once (used on create/add)
        async function patchMsgColors(convId, colors /* { [user_id]: '#hex' } */) {
            return api(`/dm/conversations/${convId}/message_colors`, {
                method: 'PATCH',
                body: { colors }
            });
        }

        // In-memory utilities
        function setColorMap(convId, map) { state.msgColorsByConv.set(convId, map || {}); }
        function getColorMap(convId) { return state.msgColorsByConv.get(convId) || {}; }

        async function syncMsgColors(convId, { retry = 0, backoff = 300 } = {}) {
            try {
                let map = await fetchMsgColors(convId);
                let tries = retry;
                let delay = backoff;
                while ((!map || Object.keys(map).length === 0) && tries-- > 0) {
                    await new Promise(r => setTimeout(r, delay));
                    delay *= 2; // exponential backoff
                    map = await fetchMsgColors(convId);
                }
                setColorMap(convId, map || {});
                updateAllMessageBorders();
                return map || {};
            } catch {
                setColorMap(convId, {});
                return {};
            }
        }

        // Choose distinct colors for given user IDs, avoiding already-used colors
        function chooseUniqueColorsForUsers(userIds, existingMap = {}) {
            const used = new Set(Object.values(existingMap || {}));
            const palette = GROUP_COLORS.map(c => c.val);
            const available = palette.filter(c => !used.has(c));
            const out = {};
            for (const uid of userIds) {
                if (existingMap[uid]) continue;
                let color = available.length ? available.splice((Math.random() * available.length) | 0, 1)[0]
                    : palette[(Math.random() * palette.length) | 0];
                out[uid] = color;
                used.add(color);
            }
            return out; // only the newly-assigned entries
        }

        /* ---------------- meta resolution ---------------- */
        async function fetchConvMeta(id) {
            const prev = state.convMeta.get(id);
            try {
                const j = await api(`/dm/conversations/${id}`);

                let meta = { name: 'Direct Message', photo: DEFAULT_PFP_DM, is_group: !!j.is_group, color: (j.color || null) };
                if (j.is_group) {
                    const members = j.members || [];
                    const autoDefault = computeDefaultGroupTitle(members);
                    const serverTitle = (j.title || '').trim();
                    const hasCustom = !!(serverTitle && serverTitle !== autoDefault);

                    meta.name = hasCustom ? serverTitle : autoDefault;
                    meta.photo = j.photo || j.avatar || DEFAULT_PFP_GROUP;
                    meta.color = j.color || meta.color || '#ffffff';
                    meta.auto_title = !hasCustom;
                } else {
                    const other = j.other || (Array.isArray(j.members) ? j.members.find(u => (u.id | 0) !== (state.meId | 0)) : null);
                    meta.name = pickName(other) || meta.name;
                    meta.photo = pickPhoto(other) || DEFAULT_PFP_DM;
                }

                const detail = { id: j.id, is_group: !!j.is_group, title: j.title || null, owner_id: j.owner_id || null, is_owner: !!j.is_owner, members: j.members || [] };
                state.convDetailById.set(id, detail);
                if ((state.convId | 0) === (id | 0)) state.currentConvDetail = detail;

                const best = { ...(prev || {}), ...meta };
                state.convMeta.set(id, best);
                if ((state.convId | 0) === (id | 0)) updateEverywhere(id);
                return best;
            } catch (e) {
                if (prev) return prev;
                const fallback = { name: 'Direct Message', photo: DEFAULT_PFP_DM, is_group: false };
                state.convMeta.set(id, fallback);
                return fallback;
            }
        }

        function setConvMeta(id, meta) {
            const prev = state.convMeta.get(id) || {};
            const next = { ...prev, ...meta };
            state.convMeta.set(id, next);
            updateEverywhere(id);
            scheduleSaveMeta();
        }

        function setImgSafe(img, src, fallback = DEFAULT_PFP_DM) {
            if (!img) return;
            const want = src || fallback;
            if (img.dataset.srcApplied === want) return;
            img.onerror = () => { img.src = fallback; img.dataset.srcApplied = fallback; };
            img.src = want; img.dataset.srcApplied = want;
        }

        function updateTopBar(meta) {
            if (!meta) return;
            $('chat-title').textContent = meta.name || 'Direct Message';
            const pfp = $('chat-pfp');
            setImgSafe(pfp, meta.photo, meta?.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM);
            if (meta.is_group) {
                const gc = meta.color || '#ffffff';
                pfp.style.borderColor = gc;
                pfp.style.setProperty('--gc', gc);
                const isDefaultGroup = (meta.photo === DEFAULT_PFP_GROUP);
                pfp.classList.toggle('tinted-default', isDefaultGroup);
                pfp.classList.toggle('pixel', isDefaultGroup);
                pfp.style.background = isDefaultGroup ? gc : '#000';
            } else {
                const isDefaultDm = (meta.photo === DEFAULT_PFP_DM);
                pfp.style.borderColor = 'var(--border)';
                pfp.classList.remove('tinted-default');
                pfp.classList.toggle('pixel', isDefaultDm);
                pfp.style.background = '#000';
            }
            renderChatMenu();
        }

        function updateEverywhere(id) {
            const meta = state.convMeta.get(id);
            if (!meta) return;
            const row = state.convRowEls.get(id);
            if (row) setConvRowContent(row, meta, row.querySelector('.preview')?.textContent || '');
            if (state.convId === id) updateTopBar(meta);
        }

        function setConvRowContent(row, meta, preview) {
            const photo = meta?.photo || (meta?.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM);
            const border = meta?.is_group ? (meta?.color || '#fff') : '#fff';
            const isDefault = (photo === DEFAULT_PFP_GROUP) || (photo === DEFAULT_PFP_DM);
            row.innerHTML = `
    <img class="avatar ${photo === DEFAULT_PFP_GROUP ? 'tinted-default' : ''} ${isDefault ? 'pixel' : ''}"
         src="${photo}" alt=""
         style="border-color:${border}; background:${photo === DEFAULT_PFP_GROUP ? border : '#000'}">
    <div>
      <div class="name">${esc(meta?.name || 'Direct Message')}</div>
      <div class="preview">${esc(preview || '…')}</div>
    </div>`;
        }

        function applySelectedHighlight() {
            document.querySelectorAll('.conv.active').forEach(el => el.classList.remove('active'));
            const el = state.convRowEls.get(state.convId);
            if (el) el.classList.add('active');
        }

        function extractOgFromConvDetail(j) {
            const direct = j?.other_username || j?.other?.first_username || j?.other?.username ||
                j?.with?.first_username || j?.with?.username || null;
            if (direct) return direct;
            const arr = j?.members || j?.participants || j?.users || j?.people || [];
            if (Array.isArray(arr) && arr.length) {
                const other = arr.find(p => {
                    const pid = (p?.id ?? p?.user?.id);
                    return pid == null || (pid | 0) !== (state.meId | 0);
                }) || arr[0];
                const u = other?.user || other || {};
                return pickUsername(u) || null;
            }
            return null;
        }

        /* ---------------- conversations list ---------------- */
        function renderConvs(list) {
            const wrap = $('convs'); wrap.innerHTML = '';
            state.convRowEls.clear();
            list.forEach(it => {
                const row = document.createElement('div'); row.className = 'conv'; row.dataset.id = it.id;
                const defaultMeta = { name: (it.is_group ? (it.title || 'Group') : (it.title || 'Direct Message')), photo: it.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM, is_group: !!it.is_group, color: it.color || null };
                const meta = state.convMeta.get(it.id) || defaultMeta;
                row.onclick = () => openConversation(it.id, meta?.name || defaultMeta.name);

                // If we have a cutoff for this convo, suppress the server preview (it points to old history)
                const hasCut = !!getHideBeforeId(it.id);
                const preview = hasCut ? '' : (it.preview || '');

                setConvRowContent(row, meta, preview);
                state.convRowEls.set(it.id, row);
                wrap.append(row);
                if (!state.convMeta.has(it.id)) state.convMeta.set(it.id, defaultMeta);
                if (!state.convMeta.has(it.id)) fetchConvMeta(it.id).catch(() => { });
            });
            applySelectedHighlight();
        }
        function applyConvFilter() {
            const q = $('conv-q').value.trim().toLowerCase();
            state.filteredConvs = !q ? [...state.allConvs]
                : state.allConvs.filter(c => {
                    const name = (state.convMeta.get(c.id)?.name || c.title || 'Direct Message').toLowerCase();
                    return name.includes(q) || (c.preview || '').toLowerCase().includes(q);
                });
            renderConvs(state.filteredConvs);
        }
        async function loadConversations({ blockingMeta = false } = {}) {
            const j = await api('/dm/conversations');
            state.allConvs = j.items || [];
            state.allConvs.forEach(it => state.convItems.set(it.id, it));

            for (const it of state.allConvs) {
                if (!state.convMeta.has(it.id)) {
                    let meta = {
                        name: it.is_group ? (it.title || 'Group') : 'Direct Message',
                        photo: it.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM,
                        is_group: !!it.is_group,
                        color: it.color || null
                    };

                    if (!it.is_group) {
                        let og = state.convUserOg.get(it.id) || extractOgFromConvDetail(it);
                        if (og) {
                            state.convUserOg.set(it.id, og);
                            const cached = state.userCache.get(og);
                            meta.name = pickName(cached?.raw || cached) || og;
                            if (cached?.photo) meta.photo = cached.photo;
                            scheduleSaveMeta();
                        }
                    }
                    state.convMeta.set(it.id, meta);
                }
            }
            scheduleSaveMeta();

            if (blockingMeta) {
                await Promise.allSettled(
                    state.allConvs.map(it => fetchConvMeta(it.id))
                );
            } else {
                state.allConvs.forEach(it => {
                    if (!state.convMeta.has(it.id)) fetchConvMeta(it.id).catch(() => { });
                });
            }
            renderConvs(state.allConvs);
        }
        $('conv-q').addEventListener('input', applyConvFilter);

        /* ---------------- virtualization ---------------- */
        const MAX_DOM = 140, GAP = 6;
        let bottomPadPx = 0, removedBottom = [];
        function setBottomPad(px) { bottomPadPx = Math.max(0, px | 0); $('pad-bottom').style.height = bottomPadPx + 'px'; }

        function closeAllBubbleMenus() {
            document.querySelectorAll('.bubble-menu').forEach(el => el.style.display = 'none');
        }

        function attachBubbleMenu(root, message) {
            const atts = (message.attachments || []);
            if (!atts.length) return;

            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'bubble-menu-btn';
            btn.textContent = '⋮';

            const menu = document.createElement('div');
            menu.className = 'bubble-menu';
            menu.innerHTML = atts.map(a => {
                const href = `${API}/dm/attachments/${a.id}/download`;
                const filename = esc(a.filename || 'attachment');
                return `<div class="item"><a href="${href}" download="${filename}">Download ${filename}</a></div>`;
            }).join('');

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentlyOpen = menu.style.display === 'block';
                closeAllBubbleMenus();
                menu.style.display = currentlyOpen ? 'none' : 'block';
            });

            root.append(btn, menu);
        }

        function renderMessage(m, showFrom = false) {
            const isSystem = (m.kind === 'system');
            const wrap = document.createElement('div');
            wrap.className = (isSystem ? 'msg sysmsg' : ('msg' + (m.sender_id === state.meId ? ' me' : '')));
            if (!isSystem) wrap.dataset.senderId = m.sender_id || '';

            // optional sender label for group chats
            if (!isSystem && isGroupChat() && showFrom) {
                const label = document.createElement('div');
                label.className = 'from';
                label.textContent = usernameFor(m.sender_id);
                wrap.appendChild(label);
            }

            if (m.text) wrap.insertAdjacentHTML('beforeend', '<div>' + esc(m.text) + '</div>');
            if (!isSystem) {
                (m.attachments || []).forEach(a => {
                    const url = `${API}/dm/attachments/${a.id}/download?inline=1`;
                    if ((a.mime_type || '').startsWith('image/')) {
                        wrap.insertAdjacentHTML('beforeend', `<img class="att" src="${url}">`);
                    } else if ((a.mime_type || '').startsWith('video/')) {
                        wrap.insertAdjacentHTML('beforeend', `<video class="att" src="${url}" controls></video>`);
                    } else if ((a.mime_type || '').startsWith('audio/')) {
                        // Custom player that always knows total duration
                        wrap.insertAdjacentHTML('beforeend', `
                    <div class="audp" data-att-id="${a.id}">
                        <button class="audp-btn" type="button" aria-label="Play">▶</button>
                        <div class="audp-track"><div class="audp-fill"></div></div>
                        <div class="audp-time"><span class="cur">0:00</span> / <span class="tot">0:00</span></div>
                        <audio class="aud-src" preload="metadata" src="${url}"></audio>
                    </div>
                `);
                        const playerRoot = wrap.lastElementChild;
                        // init after it’s in the DOM
                        queueMicrotask(() => {
                            initAudioPlayer(a.id, url, playerRoot);
                            if (Number.isFinite(a.duration_ms) && a.duration_ms > 0) {
                                setPlayerTotal(a.id, a.duration_ms);
                            }
                        });
                    } else {
                        renderAttachmentInline(wrap, a);
                    }
                });

                // timestamp
                wrap.insertAdjacentHTML('beforeend', `<div class="meta">${m.created_at ? fmt(m.created_at) : ''}</div>`);

                // apply per-sender border color (if any)
                const col = (getColorMap(state.convId) || {})[m.sender_id] || null;
                if (col) wrap.style.setProperty('--mbc', col);
            }

            // auto-scroll for media
            wrap.querySelectorAll('img').forEach(img =>
                img.addEventListener('load', () => { if (nearBottom(200)) scrollToBottom(); }, { once: true })
            );
            wrap.querySelectorAll('video').forEach(v =>
                v.addEventListener('loadedmetadata', () => { if (nearBottom(200)) scrollToBottom(); }, { once: true })
            );

            if (!isSystem) attachBubbleMenu(wrap, m);
            return wrap;
        }

        function revokeObjectURLsIn(root) {
            if (!root) return;
            root.querySelectorAll('[data-objurl]').forEach(el => {
                const u = el.dataset.objurl;
                if (u) { try { URL.revokeObjectURL(u); } catch { } }
                delete el.dataset.objurl;
            });
        }

        function revokeAudioURLsIn(root) {
            if (!root) return;
            root.querySelectorAll('audio').forEach(a => {
                const u = a.dataset.objurl;
                if (u) {
                    try { URL.revokeObjectURL(u); } catch { }
                    delete a.dataset.objurl;
                }
            });
        }

        function appendMessagesAscending(items) {
            items = (items || []).filter(m => !state.renderedMsgIds.has(m.id));
            if (!items.length) return;
            // if we had a cutoff and new stuff arrived, clear it so previews can show again
            const cut = getHideBeforeId(state.convId);
            if (cut && items.some(m => (m.id | 0) > cut)) clearHideBeforeId(state.convId);

            const anchor = $('pad-bottom');
            items.forEach(m => {
                state.renderedMsgIds.add(m.id);

                // look at the message immediately before where we're inserting (chronological previous)
                let prev = anchor.previousElementSibling;
                while (prev && !prev.classList.contains('msg')) prev = prev.previousElementSibling;
                const prevSender = (prev && !prev.classList.contains('sysmsg')) ? (+prev.dataset.senderId || null) : null;
                const showFrom = isGroupChat() && prevSender !== (m.sender_id | 0);

                const el = renderMessage(m, showFrom);
                anchor.before(el);

                state.oldestMsgId = state.oldestMsgId === null ? m.id : Math.min(state.oldestMsgId, m.id);
                state.lastMsgId = Math.max(state.lastMsgId, m.id);
            });
            updateAllMessageBorders();
            maybeTrimBottom();
        }
        function prependOlderAscending(items) {
            items = (items || []).filter(m => !state.renderedMsgIds.has(m.id));
            if (!items.length) return;
            const box = $('msgs');
            const prevTop = box.scrollTop, prevH = box.scrollHeight;
            const frag = document.createDocumentFragment();

            let prevSenderInThisBlock = null; // chronological previous inside this batch
            items.forEach(m => {
                state.renderedMsgIds.add(m.id);
                const showFrom = isGroupChat() && prevSenderInThisBlock !== (m.sender_id | 0);
                const el = renderMessage(m, showFrom);
                frag.append(el);
                prevSenderInThisBlock = m.sender_id | 0;

                state.oldestMsgId = state.oldestMsgId === null ? m.id : Math.min(state.oldestMsgId, m.id);
                state.lastMsgId = Math.max(state.lastMsgId, m.id);
            });

            const afterTop = $('pad-top').nextSibling || $('pad-bottom');
            box.insertBefore(frag, afterTop);

            /* fix the label on what USED TO be the first message,
               because its "previous" just changed */
            const newLastInserted = afterTop.previousElementSibling;
            const oldFirst = afterTop; // the element that was first before
            if (oldFirst && newLastInserted &&
                oldFirst.classList.contains('msg') && !oldFirst.classList.contains('sysmsg') &&
                newLastInserted.classList.contains('msg') && !newLastInserted.classList.contains('sysmsg')) {
                const same = (+oldFirst.dataset.senderId || 0) === (+newLastInserted.dataset.senderId || 0);
                const fromEl = oldFirst.querySelector('.from');
                if (same && fromEl) fromEl.remove();
                if (!same && isGroupChat() && !fromEl) {
                    const label = document.createElement('div');
                    label.className = 'from';
                    label.textContent = usernameFor(+oldFirst.dataset.senderId || 0);
                    oldFirst.insertBefore(label, oldFirst.firstChild);
                }
            }

            box.scrollTop = prevTop + (box.scrollHeight - prevH);
            maybeTrimBottom();
        }
        function maybeTrimBottom() {
            const box = $('msgs');
            if (nearBottom(200)) return;
            while (true) {
                const last = $('pad-bottom').previousElementSibling;
                if (!last || !last.classList.contains('msg')) break;
                const count = box.querySelectorAll('.msg').length;
                if (count <= MAX_DOM) break;
                const h = last.offsetHeight + GAP;
                removedBottom.push({ el: last, h });

                // revoke blob URLs
                last.querySelectorAll('audio').forEach(a => {
                    const u = a.dataset.objurl;
                    if (u) {
                        try { URL.revokeObjectURL(u); } catch { }
                        delete a.dataset.objurl;
                    }
                });

                // drop custom player registrations for this subtree
                unregisterPlayersIn(last);

                last.remove();
                setBottomPad(bottomPadPx + h);
            }
        }
        function maybeRestoreBottom(chunk = 24) {
            if (!removedBottom.length) return;
            const box = $('msgs'); const dist = (box.scrollHeight - box.clientHeight - box.scrollTop);
            if (dist > 1200) return;
            let n = 0; while (removedBottom.length && n < chunk) {
                const { el, h } = removedBottom.pop();
                $('pad-bottom').before(el); setBottomPad(bottomPadPx - h); n++;
            }
        }

        const jumpBtn = (() => {
            const el = $('jump');
            function sync() { if (nearBottom(120)) { el.classList.remove('show'); el.style.display = 'none'; } else { el.style.display = ''; el.classList.add('show'); } }
            el.addEventListener('click', () => { while (removedBottom.length) { const { el: n, h } = removedBottom.pop(); $('pad-bottom').before(n); setBottomPad(bottomPadPx - h); } scrollToBottom(); sync(); });
            return { sync };
        })();

        /* ---------------- open/paging/realtime ---------------- */
        async function openConversation(id) {
            if (state.es) { try { state.es.close(); } catch { } state.es = null; }
            if (state.poll) { clearInterval(state.poll); state.poll = null; }

            state.convId = id;
            saveLastDM();
            state.currentConvDetail = state.convDetailById.get(id) || null;
            applySelectedHighlight();

            // Seed (very brief) fallback meta if needed
            if (!state.convMeta.has(id)) {
                const seed = state.convItems.get(id) || {};
                state.convMeta.set(id, {
                    name: seed.title || 'Direct Message',
                    photo: seed.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM,
                    is_group: !!seed.is_group,
                    color: seed.color || null
                });
            }

            // ⬇️ Wait for fresh server meta so header ring & list chips have the real color
            try { await fetchConvMeta(id); } catch { }

            // Now render messages
            revokeAudioURLsIn($('msgs'));
            revokeObjectURLsIn($('msgs'));
            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
            state.audioPlayers.clear(); // <— add this
            state.renderedMsgIds.clear();
            setBottomPad(0);
            removedBottom = [];
            state.lastMsgId = 0;
            state.oldestMsgId = null;
            state.nextBefore = null;

            const j = await api(`/dm/conversations/${id}/messages?limit=30`);
            appendMessagesAscending(filterHidden(j.items, id));
            state.nextBefore = j.next_before;

            try { await (document.fonts && document.fonts.ready); } catch { }
            await afterPaint(); await afterPaint();
            scrollToBottom();

            jumpBtn.sync();
            openStream(id);
            startCatchup();

            // ⬇️ do a color map fetch with retry (see next section)
            await syncMsgColors(id, { retry: 3 });
            updateAllMessageBorders();
        }

        $('msgs').addEventListener('scroll', async () => {
            jumpBtn.sync(); maybeRestoreBottom();
            const box = $('msgs');
            if (box.scrollTop <= 20 && state.nextBefore) {
                const j = await api(`/dm/conversations/${state.convId}/messages?before=${state.nextBefore}&limit=20`);
                prependOlderAscending(filterHidden(j.items));
                state.nextBefore = j.next_before;
            }
        });

        function openStream(id) {
            const es = new EventSource(`${API}/dm/conversations/${id}/stream`, { withCredentials: true });
            state.es = es;
            es.addEventListener('new', async () => { await fetchAfter(state.lastMsgId); });
        }
        function openGlobalStream() {
            if (state.esGlobal) { try { state.esGlobal.close(); } catch { } }
            const es = new EventSource(`${API}/dm/stream`, { withCredentials: true });
            state.esGlobal = es;

            let reloadTimer = null;
            function scheduleConvsReload() {
                clearTimeout(reloadTimer);
                reloadTimer = setTimeout(() => { loadConversations().catch(() => { }); }, 200);
            }

            es.addEventListener('conv_new', (e) => {
                try {
                    const d = JSON.parse(e.data || '{}');
                    const cid = d.conversation_id || d.id;
                    if (cid) {
                        // clear any stale local color map and refresh meta ASAP
                        state.msgColorsByConv.delete(cid);
                        fetchConvMeta(cid).catch(() => { });
                    }
                } catch { }
                scheduleConvsReload();
            });

            es.addEventListener('message', (e) => {
                // New message in some conversation (not necessarily open)
                const d = JSON.parse(e.data || '{}');
                if ((d.conversation_id | 0) !== (state.convId | 0)) scheduleConvsReload();
            });

            es.addEventListener('conv_meta', (e) => {
                // Group color/icon changed; update meta and header/list without refresh
                const d = JSON.parse(e.data || '{}');
                const cid = d.conversation_id | 0;
                const prev = state.convMeta.get(cid) || {};
                const newPhoto = d.photo_ts ? `${API}/dm/conversations/${cid}/icon?ts=${encodeURIComponent(d.photo_ts)}` : prev.photo;
                const next = {
                    ...prev,
                    is_group: true,
                    color: (typeof d.color === 'string' && d.color) ? d.color : prev.color || null,
                    photo: newPhoto || prev.photo
                };
                state.convMeta.set(cid, next);
                updateEverywhere(cid);
                if ((cid | 0) === (state.convId | 0)) updateTopBar(next);
            });

            es.addEventListener('color_change', (e) => {
                const d = JSON.parse(e.data || '{}');
                const cid = d.conversation_id | 0;
                const uid = d.user_id | 0;
                const cmap = { ...getColorMap(cid) };
                if (d.color) cmap[uid] = d.color; else delete cmap[uid];
                setColorMap(cid, cmap);
                if ((cid | 0) === (state.convId | 0)) updateAllMessageBorders();
            });

            es.onerror = () => { /* keep alive is handled server-side; browser will retry */ };
        }
        function startCatchup() { state.poll = setInterval(() => { fetchAfter(state.lastMsgId).catch(() => { }); }, 30000); }
        async function fetchAfter(lastId) {
            if (state.fetchingAfter) return;
            state.fetchingAfter = true;
            try {
                const j = await api(`/dm/conversations/${state.convId}/messages?after=${lastId}&limit=100`);
                const filtered = filterHidden(j.items);
                if (!filtered || !filtered.length) return;
                const stick = nearBottom(80);
                appendMessagesAscending(filtered);
                if (stick) { await afterPaint(); scrollToBottom(); }

                loadConversations().catch(() => { });
                jumpBtn.sync();
            } finally {
                state.fetchingAfter = false;
            }
        }

        /* ---------------- attachments + voice ---------------- */
        const chips = $('att-chips'); const recWarn = $('rec-warn');

        // Predict a single-pass transcode that lands under 1MB
        function refreshChips() {
            chips.innerHTML = '';
            state.pendingFiles.forEach((f, i) => {
                const c = document.createElement('div');
                c.className = 'chip';

                if (f.status === 'compressing') {
                    const pct = Math.round((f.progress || 0) * 100);
                    c.innerHTML = `
        <div style="display:flex;flex-direction:column;gap:6px;min-width:260px">
          <div>${esc(f.name)} <span class="muted">· ${esc(f.phase || 'compressing')}… ${pct}%</span></div>
          <div class="prog-wrap" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${pct}">
            <div class="prog ${pct >= 100 ? 'done' : ''}" style="width:${pct}%"></div>
          </div>
        </div>`;
                    // no ✕ while compressing
                } else {
                    c.innerHTML = `<span>${esc(f.name)} · ${(f.size / 1024 | 0)} KB</span><span class="x">✕</span>`;
                    c.querySelector('.x').onclick = () => { state.pendingFiles.splice(i, 1); refreshChips(); };
                }

                chips.append(c);
            });
        }

        function addCompressingPlaceholder(fileName) {
            const tempId = 'tmp_' + Math.random().toString(36).slice(2);
            state.pendingFiles.push({ tempId, status: 'compressing', name: fileName, progress: 0, phase: 'starting' });
            refreshChips();
            syncSendUI();                  // <— add
            return tempId;
        }
        const setCompressProgress = (() => {
            let raf = null;
            const pending = new Map(); // tempId -> {p, phase}
            return (tempId, p, phase) => {
                pending.set(tempId, { p: Math.max(0, Math.min(1, p || 0)), phase });
                if (raf) return;
                raf = requestAnimationFrame(() => {
                    raf = null;
                    pending.forEach((v, id) => {
                        const it = state.pendingFiles.find(x => x.tempId === id && x.status === 'compressing');
                        if (it) { it.progress = v.p; if (v.phase) it.phase = v.phase; }
                    });
                    pending.clear();
                    refreshChips();
                });
            };
        })();
        function replaceCompressingWith(tempId, obj) {
            const idx = state.pendingFiles.findIndex(x => x.tempId === tempId);
            if (idx !== -1) state.pendingFiles.splice(idx, 1, obj);
            else state.pendingFiles.push(obj);
            refreshChips();
            syncSendUI();                  // <— add
        }
        function addPendingFile(o) { state.pendingFiles.push(o); refreshChips(); syncSendUI(); } // <— add

        async function handleFileInput(files) {
            for (const file of files) {
                if (file.size > 10000 * 1024 * 1024) {
                    throw new Error('Look pal, the file limit is ONE MB. I can compress stuff, sure, but I cant compress THAT.');
                }
                const tempId = addCompressingPlaceholder(file.name);
                try {
                    const { blob, encoding } = await compressFileSmart(file, (p, phase) => setCompressProgress(tempId, p, phase));
                    const u8 = new Uint8Array(await blob.arrayBuffer());

                    const btype = (blob.type || '');
                    const ftype = (file.type || '');
                    const isVid = btype.startsWith('video/');
                    const isAud = btype.startsWith('audio/');
                    const isImg = ftype.startsWith('image/'); // we renamed images to .jpg based on original input

                    const safeName =
                        (isVid || isAud)
                            ? file.name.replace(/\.[^.]+$/, '') + (isVid ? '.webm' : '.webm')
                            : (isImg
                                ? file.name.replace(/\.[^.]+$/, '') + '.jpg'
                                : file.name + (encoding === 'gzip' ? '.gz' : ''));

                    replaceCompressingWith(tempId, {
                        name: safeName,
                        type: btype || 'application/octet-stream',
                        buf: u8,
                        size: u8.length,
                        encoding: encoding || null // <-- PRESERVE THIS
                    });
                } catch (e) {
                    const idx = state.pendingFiles.findIndex(x => x.tempId === tempId);
                    if (idx !== -1) state.pendingFiles.splice(idx, 1);
                    refreshChips();
                    alert(`${file.name}: ${errMsg(e)}`);
                }
            }
        }

        /* ---------------- overlay (friends / group create/edit/view) ---------------- */
        const overlay = $('overlay'), userList = $('user-list');

        async function fetchFriends() {
            let arr = [];
            try {
                const j1 = await api(`/users/me/friends`);
                arr = j1.items || j1.friends || [];
            } catch { }
            if ((!arr || !arr.length) && state.meSlug) {
                try {
                    const j2 = await api(`/users/${encodeURIComponent(state.meSlug)}/friends?offset=0&limit=500`);
                    arr = j2.items || j2.friends || [];
                } catch { }
            }
            const norm = (arr || []).map(u => {
                const nu = u.user || u;
                const id = nu.id ?? nu.user_id ?? nu.friend_id ?? null;
                const username = nu.username ?? nu.first_username ?? null;
                const first_username = nu.first_username ?? nu.username ?? null;
                const profile_photo = nu.profile_photo ?? null;
                const bio = nu.bio ?? nu.bio_html ?? '';
                return { id, username, first_username, profile_photo, bio };
            }).filter(x => x.id);
            return norm;
        }

        function friendDisplay(u) {
            const raw = u.display_name || u.name || u.first_username || u.username || 'User';
            return String(raw);
        }

        function refreshSelectedChips() {
            const chipBox = $('selected-chips'); chipBox.innerHTML = '';
            const ids = [...state.selectedIds];
            ids.forEach(uid => {
                const u = state.idToFriend.get(uid) || {};
                const label = friendDisplay(u);
                const el = document.createElement('div');
                el.className = 'chip';
                el.innerHTML = `<span>${esc(label)}</span><span class="x" title="Remove">✕</span>`;
                el.querySelector('.x').onclick = (e) => { e.stopPropagation(); state.selectedIds.delete(uid); renderFriends(state.friendsCache); refreshSelectedChips(); refreshGroupSubmitState(); };
                chipBox.append(el);
            });
        }

        function refreshGroupSubmitState() {
            const btn = $('btn-group-submit');
            const mode = state.pickerMode;
            if (mode === 'group-create') {
                btn.textContent = 'Create Group';
                btn.disabled = (state.selectedIds.size < 2);
            } else if (mode === 'group-edit') {
                btn.textContent = 'Save Changes';
                const changed = !eqSets(state.selectedIds, state.initialSelectedIds);
                btn.disabled = !changed;
            } else {
                btn.textContent = 'Close';
                btn.disabled = false;
            }
            $('group-cta').style.display = (mode === 'group-create' || mode === 'group-edit') ? '' : 'none';
        }

        function eqSets(a, b) { if (a.size !== b.size) return false; for (const v of a) if (!b.has(v)) return false; return true; }

        function renderFriends(list) {
            state.friendsCache = list || [];
            state.idToFriend.clear();
            list.forEach(u => state.idToFriend.set(u.id, u));

            userList.innerHTML = '';
            const q = $('user-q').value.trim().toLowerCase();
            let items = list.filter(u => {
                if (!q) return true;
                return (u.username || '').toLowerCase().includes(q) ||
                    (u.first_username || '').toLowerCase().includes(q) ||
                    (u.bio || '').toLowerCase().includes(q);
            });

            const mode = state.pickerMode;
            items.forEach(u => {
                const row = document.createElement('div'); row.className = 'person';
                const label = friendDisplay(u);
                const checked = state.selectedIds.has(u.id);
                const isDefaultAvatar = !u.profile_photo; // <-- add this line

                let right = '';
                if (mode === 'dm') {
                    right = `<div class="act"><button class="btn person-message">Message</button></div>`;
                } else if (mode === 'group-create' || mode === 'group-edit') {
                    right = `<div class="act">
                    <input type="checkbox" class="checkbox person-check" ${checked ? 'checked' : ''}/>
                </div>`;
                } else {
                    right = `<div class="act"></div>`;
                }

                row.innerHTML = `
                <img class="pfp ${isDefaultAvatar ? 'pixel' : ''}" src="${u.profile_photo || DEFAULT_PFP_DM}" alt="">
                <div>
                    <div class="name">${esc(label)}</div>
                    <div class="bio">${esc(u.bio || '')}</div>
                </div>
                ${right}
            `;

                if (mode === 'dm') {
                    row.onclick = (e) => { if (e.target.closest('.person-message')) return; startDmWith(u); };
                    row.querySelector('.person-message').onclick = async (e) => { e.stopPropagation(); await startDmWith(u); };
                } else if (mode === 'group-create' || mode === 'group-edit') {
                    const toggle = () => {
                        if (state.selectedIds.has(u.id)) state.selectedIds.delete(u.id);
                        else state.selectedIds.add(u.id);
                        renderFriends(state.friendsCache);
                        refreshSelectedChips();
                        refreshGroupSubmitState();
                    };
                    row.onclick = toggle;
                    const cb = row.querySelector('.person-check');
                    if (cb) cb.addEventListener('click', (e) => { e.stopPropagation(); toggle(); });
                } else {
                    row.onclick = () => { };
                }

                userList.append(row);
            });

            refreshSelectedChips();
        }

        function isGroupChat() { return !!(state.currentConvDetail?.is_group); }

        function usernameFor(userId) {
            const det = state.currentConvDetail || {};
            const m = (det.members || []).find(u => (u.id | 0) === (userId | 0));
            const u = m || {};
            return pickName(u) || 'user';
        }

        function borderColorKey(convId) { return `dp:msgColors:${convId}`; }
        function getBorderColorMap(convId) {
            try { return JSON.parse(localStorage.getItem(borderColorKey(convId)) || '{}'); } catch { return {}; }
        }
        function updateAllMessageBorders() {
            const cmap = getColorMap(state.convId);
            document.querySelectorAll('.msgs .msg:not(.sysmsg)').forEach(el => {
                const uid = +el.dataset.senderId || 0;
                const col = cmap[uid] || null;
                if (col) el.style.setProperty('--mbc', col);
                else el.style.removeProperty('--mbc');
            });
        }

        let myColorOverlay = null;
        function ensureMyColorOverlay() {
            if (myColorOverlay) return myColorOverlay;
            myColorOverlay = document.createElement('div');
            myColorOverlay.id = 'my-color-overlay';
            myColorOverlay.className = 'overlay';
            myColorOverlay.innerHTML = `
    <div class="sheet" style="width:min(460px,94vw)">
      <h3>My Message Color</h3>
      <div class="person" style="cursor:default">
        <img class="pfp" id="my-color-pfp" src="" alt="">
        <div style="display:flex;flex-direction:column;gap:6px">
          <div class="name" id="my-color-name">@me</div>
          <div class="bio">Change the border color of <b>your</b> messages in this group.</div>
        </div>
        <div class="act" style="display:flex;gap:8px;align-items:center">
          <input class="colorpick" id="my-color-input" type="color" value="#e6e6e6">
          <button class="btn" id="my-color-clear" type="button" title="Use default">Use default</button>
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button class="btn" id="my-color-cancel" type="button">Cancel</button>
        <button class="btn" id="my-color-save" type="button">Save</button>
      </div>
    </div>`;
            document.body.append(myColorOverlay);
            myColorOverlay.addEventListener('click', e => { if (e.target === myColorOverlay) myColorOverlay.style.display = 'none'; });
            return myColorOverlay;
        }

        async function openMyColorOverlay() {
            const det = state.currentConvDetail || {};
            if (!det.is_group) return;

            const ov = ensureMyColorOverlay();
            const nameEl = ov.querySelector('#my-color-name');
            const pfpEl = ov.querySelector('#my-color-pfp');
            const input = ov.querySelector('#my-color-input');
            const btnClr = ov.querySelector('#my-color-clear');
            const btnSav = ov.querySelector('#my-color-save');
            const btnCan = ov.querySelector('#my-color-cancel');

            // Fill in my display bits
            const me = (det.members || []).find(u => (u.id | 0) === (state.meId | 0)) || {};
            nameEl.textContent = pickName(me) || 'Me';
            const isDefaultAvatar = !me.profile_photo;
            pfpEl.classList.toggle('pixel', isDefaultAvatar);
            pfpEl.src = me.profile_photo || DEFAULT_PFP_DM;

            // Ensure we have the latest map
            await syncMsgColors(state.convId);
            const map = getColorMap(state.convId);
            const current = map[state.meId] || '#e6e6e6';
            input.value = /^#[0-9a-f]{6}$/i.test(current) ? current : '#e6e6e6';

            btnClr.onclick = () => { input.value = '#e6e6e6'; };

            btnSav.onclick = async () => {
                const val = input.value.toLowerCase();
                // treat default as "clear" (null)
                const toSet = (val === '#e6e6e6') ? null : val;
                try {
                    await setMyMsgColor(state.convId, toSet);
                    // reflect locally
                    const m = { ...getColorMap(state.convId) };
                    if (toSet) m[state.meId] = toSet; else delete m[state.meId];
                    setColorMap(state.convId, m);
                    updateAllMessageBorders();
                    myColorOverlay.style.display = 'none';
                } catch (e) {
                    alert(e.detail || errMsg(e));
                }
            };
            btnCan.onclick = () => { myColorOverlay.style.display = 'none'; };

            myColorOverlay.style.display = 'flex';
        }

        async function openPicker(mode = 'dm', opts = {}) {
            state.pickerMode = mode;
            state.selectedIds = new Set(opts.preselectIds || []);
            state.initialSelectedIds = new Set(opts.preselectIds || []);
            $('overlay').style.display = 'flex';
            $('user-q').value = '';
            $('sheet-title').textContent =
                mode === 'dm' ? 'Start a conversation'
                    : mode === 'group-create' ? 'Create a Group'
                        : mode === 'group-edit' ? 'Edit Group Members'
                            : 'Group Members';

            $('group-cta').style.display = (mode === 'group-create' || mode === 'group-edit') ? '' : 'none';
            refreshGroupSubmitState();

            const friends = await fetchFriends();
            renderFriends(friends);
        }
        function closePicker() { $('overlay').style.display = 'none'; }

        async function maybeAutoRenameGroup() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            if (!det?.is_group) return;

            const meta = state.convMeta.get(state.convId) || {};
            // only auto-manage title if user hasn't custom-named it
            if (meta.auto_title === false) return;

            const desired = computeDefaultGroupTitle(det.members || []);
            const current = (det.title || meta.name || '').trim();
            const stripAts = s => s.replace(/@/g, '');
            const sameIgnoringAts = (a, b) => stripAts(a) === stripAts(b);

            const isAutoNow = (current === '' || sameIgnoringAts(current, computeDefaultGroupTitle(det.members || [])));
            if (isAutoNow && !sameIgnoringAts(current, desired)) {
                await api(`/dm/conversations/${state.convId}/title`, { method: 'PATCH', body: { title: desired } });
                setConvMeta(state.convId, { name: desired, auto_title: true });
            }
        }

        $('btn-newdm').onclick = () => openPicker('dm');
        $('btn-newgroup').onclick = () => openPicker('group-create');

        overlay.addEventListener('click', e => { if (e.target === overlay) closePicker(); });
        document.addEventListener('keydown', e => { if (e.key === 'Escape') { closePicker(); hideChatMenu(); hideRestyle(); } });

        $('user-q').addEventListener('input', async () => renderFriends(state.friendsCache));
        $('btn-cancel').onclick = () => closePicker();

        $('btn-group-submit').onclick = async () => {
            if (state.pickerMode === 'group-create') {
                if (state.selectedIds.size < 2) return;
                const ids = [...state.selectedIds]; // others (in pick order)
                const others = ids.map(id => state.idToFriend.get(id)).filter(Boolean);
                const meLabel = state.meSlug || 'Me'; // username is fine; no @
                const names = [meLabel, ...others.map(u => friendDisplay(u) || 'User')];
                const title = joinNames(names);
                try {
                    const rc = randomGroupColor();
                    const res = await api('/dm/conversations', { method: 'POST', body: { user_ids: ids, title, color: rc.val } });
                    // mark this conversation as using the default/auto title scheme
                    setConvMeta(res.id, { name: title, is_group: true, auto_title: true });

                    // Assign distinct colors to everyone (me + others)
                    const allIds = [state.meId, ...ids];
                    const initial = chooseUniqueColorsForUsers(allIds, {}); // fresh set
                    try { await patchMsgColors(res.id, initial); } catch { }
                    setColorMap(res.id, { ...initial });

                    closePicker();
                    await loadConversations({ blockingMeta: true });
                    if (res?.id) await openConversation(res.id);
                } catch (e) { alert(e.detail || errMsg(e)); }
            } else if (state.pickerMode === 'group-edit') {
                const detail = state.currentConvDetail || {};
                const before = new Set(state.initialSelectedIds);
                const after = new Set(state.selectedIds);
                const add = [...after].filter(x => !before.has(x));
                const remove = [...before].filter(x => !after.has(x));
                if (add.length === 0 && remove.length === 0) return;
                try {
                    const resp = await api(`/dm/conversations/${state.convId}/members`, {
                        method: 'PATCH',
                        body: { add_user_ids: add, remove_user_ids: remove }
                    });

                    // keep this client-side nicety (server also assigns colors)
                    if (add.length) {
                        let existing = {};
                        try { existing = await fetchMsgColors(state.convId); } catch { }
                        const newOnes = chooseUniqueColorsForUsers(add, existing);
                        if (Object.keys(newOnes).length) {
                            try { await patchMsgColors(state.convId, newOnes); } catch { }
                        }
                    }

                    closePicker();

                    if (resp?.deleted) {
                        state.convId = null;
                        state.currentConvDetail = null;
                        $('chat-title').textContent = 'Pick a conversation';
                        $('chat-pfp').src = DEFAULT_PFP_DM;
                        $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                        state.audioDurEls.clear();
                        await loadConversations({ blockingMeta: true });
                        return;
                    }

                    await fetchConvMeta(state.convId);
                    await maybeAutoRenameGroup();
                    await syncMsgColors(state.convId);
                    await fetchAfter(state.lastMsgId);
                    await loadConversations({ blockingMeta: true });
                } catch (e) { alert(e.detail || errMsg(e)); }
            } else {
                closePicker();
            }
        };

        async function startDmWith(u) {
            try {
                const og = u.first_username || u.username;
                const res = await api(`/dm/with/${encodeURIComponent(og)}`, { method: 'POST' });
                closePicker(); await loadConversations({ blockingMeta: true });
                const cid = res?.conversation_id || res?.id;
                if (cid) {
                    const meta = { name: friendDisplay(u), photo: u.profile_photo || DEFAULT_PFP_DM, is_group: false };
                    setConvMeta(cid, meta);
                    state.userCache.set(og, { username: og, photo: u.profile_photo || DEFAULT_PFP_DM, display_name: null, raw: u });
                    scheduleSaveMeta();
                    openConversation(cid);
                } else if (state.allConvs[0]) {
                    openConversation(state.allConvs[0].id);
                }
            } catch (e) { alert(errMsg(e)); }
        }

        /* ---------------- 3-dots chat menu ---------------- */
        const chatMenu = $('chat-menu');
        const chatMenuBtn = $('chat-menu-btn');

        function hideChatMenu() { chatMenu.style.display = 'none'; }
        function toggleChatMenu() {
            if (chatMenu.style.display === 'none' || !chatMenu.style.display) { renderChatMenu(); chatMenu.style.display = 'block'; }
            else chatMenu.style.display = 'none';
        }
        chatMenuBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleChatMenu(); });
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.bubble-menu') && !e.target.closest('.bubble-menu-btn')) {
                closeAllBubbleMenus();
            }
        });
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.menu') && e.target !== chatMenuBtn) hideChatMenu();
        });

        function renderChatMenu() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            const isGroup = !!det.is_group;
            const isOwner = !!det.is_owner;

            chatMenuBtn.style.display = '';

            const items = [];
            if (isGroup) {
                if (isOwner) {
                    items.push({ id: 'rename', label: 'Rename group' });
                    items.push({ id: 'manage', label: 'Manage members' });
                } else {
                    items.push({ id: 'view-members', label: 'View members' });
                }
                items.push({ id: 'restyle', label: 'Restyle Group' });
                items.push({ id: 'my-color', label: 'My Message Color' });
                items.push({ id: 'leave', label: 'Leave group' });
                items.push({ id: 'block-group', label: 'Block this group' });
            } else {
                items.push({ id: 'delete-dm', label: 'Delete chat (for me)' });
                items.push({ id: 'block-user', label: 'Block user' });
            }

            chatMenu.innerHTML = items.map(i => `<div class="item" data-id="${i.id}">${esc(i.label)}</div>`).join('');

            chatMenu.querySelectorAll('.item').forEach(el => {
                el.onclick = async () => {
                    const id = el.dataset.id;
                    hideChatMenu();
                    if (id === 'rename') {
                        const current = state.currentConvDetail?.title || state.convMeta.get(state.convId)?.name || '';
                        const name = prompt('New group name:', current) || '';
                        const trimmed = name.trim();
                        if (!trimmed) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/title`, { method: 'PATCH', body: { title: trimmed } });
                            setConvMeta(state.convId, { auto_title: false });
                            await fetchConvMeta(state.convId);
                            await fetchAfter(state.lastMsgId);
                            await loadConversations({ blockingMeta: true });
                            await afterPaint();
                            renderChatMenu();
                        } catch (e) { alert(e.detail || errMsg(e)); }
                    } else if (id === 'manage') {
                        await openManageMembers();
                    } else if (id === 'view-members') {
                        state.pickerMode = 'view-members';
                        $('sheet-title').textContent = 'Group Members';
                        $('group-cta').style.display = 'none';
                        $('overlay').style.display = 'flex';
                        $('user-q').value = '';
                        const members = (state.currentConvDetail?.members || []).map(u => ({
                            id: u.id, username: u.username, first_username: u.first_username, profile_photo: u.profile_photo, bio: ''
                        }));
                        renderFriends(members);
                    } else if (id === 'restyle') {
                        openRestyleOverlay();
                    } else if (id === 'leave') {
                        if (!confirm('Leave this group?')) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/leave`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || errMsg(e)); }
                    } else if (id === 'block-group') {
                        if (!confirm('Block this group? You will also leave it and won’t be added again.')) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/block`, { method: 'POST' });
                            await api(`/dm/conversations/${state.convId}/leave`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || errMsg(e)); }
                    } else if (id === 'delete-dm') {
                        if (!confirm('Delete this chat for you? The other person will still see it.')) return;
                        try {
                            // mark cutoff BEFORE we delete (so we hide everything up to current last)
                            setHideBeforeId(state.convId, state.lastMsgId || Number.MAX_SAFE_INTEGER);

                            // Personal delete on the backend (no system message)
                            await api(`/dm/conversations/${state.convId}/delete_for_me`, { method: 'POST' });

                            // Reset UI
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || errMsg(e)); }
                    } else if (id === 'block-user') {
                        try {
                            const other = (state.currentConvDetail?.members || []).find(u => (u.id | 0) !== (state.meId | 0));
                            if (!other) { alert('Could not find user to block.'); return; }
                            await api(`/blocks/users`, { method: 'POST', body: { user_id: other.id } });
                            alert('User blocked.');
                        } catch (e) { alert(e.detail || errMsg(e)); }
                    } else if (id === 'my-color') {
                        openMyColorOverlay();
                    }
                };
            });
        }

        /* ---------------- Manage members (owner only) ---------------- */
        async function openManageMembers() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            if (!det?.is_group || !det?.members?.length) return;
            state.pickerMode = 'view-members';
            $('sheet-title').textContent = 'Manage Group';
            $('group-cta').style.display = 'none';
            $('overlay').style.display = 'flex';
            $('user-q').value = '';
            const members = (det.members || []).map(u => ({
                id: u.id, username: u.username, first_username: u.first_username, profile_photo: u.profile_photo, bio: ''
            }));
            renderFriends(members);
            Array.from(document.querySelectorAll('#user-list .person')).forEach((row, idx) => {
                const m = members[idx];
                const act = document.createElement('div');
                act.className = 'act';
                act.style.display = 'flex';
                act.style.gap = '8px';
                const makeOwner = document.createElement('button');
                makeOwner.className = 'btn';
                makeOwner.textContent = 'Make owner';
                makeOwner.onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        await api(`/dm/conversations/${state.convId}/owner`, { method: 'PATCH', body: { owner_id: m.id } });
                        await fetchConvMeta(state.convId);
                        await loadConversations({ blockingMeta: true });
                        alert('Owner updated.');
                    } catch (e) { alert(e.detail || errMsg(e)); }
                };
                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn';
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!confirm('Remove this person from the group?')) return;
                    try {
                        await api(`/dm/conversations/${state.convId}/members`, { method: 'PATCH', body: { add_user_ids: [], remove_user_ids: [m.id] } });
                        await fetchConvMeta(state.convId);
                        await loadConversations({ blockingMeta: true });
                        row.remove();
                    } catch (e) { alert(e.detail || errMsg(e)); }
                };
                act.append(makeOwner, removeBtn);
                row.append(act);
            });
        }

        /* ---------------- Restyle Group (color + icon) ---------------- */
        let restyleEl = null;

        function ensureRestyle() {
            if (restyleEl) return restyleEl;
            restyleEl = document.createElement('div');
            restyleEl.id = 'restyle-overlay';
            restyleEl.className = 'overlay';
            restyleEl.innerHTML = `
    <div class="sheet" style="width:min(720px,94vw)">
      <h3>Restyle Group</h3>

      <div class="pf-preview">
        <div class="thumb"><img id="restyle-preview" alt="preview"></div>
        <div class="muted">PNG will be generated at up to <b>512px</b> (longest side). Final file must be ≤ <b>1&nbsp;MB</b>.</div>
      </div>

      <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;margin:8px 0 10px">
        <div style="font-weight:700">Color</div>
        <div id="restyle-color-choices" style="display:flex;flex-wrap:wrap;gap:8px"></div>
      </div>

      <div class="file-row">
        <label class="pill">
          <span>Choose image</span>
          <input id="restyle-file" type="file" accept="image/png,image/jpeg,image/webp,image/gif,image/svg+xml" style="display:none">
        </label>
        <span class="muted">or drag & drop onto the canvas</span>
        <div id="restyle-filename" class="muted" style="font-size:13px"></div>
        <button class="btn" id="restyle-clear" type="button">Use default</button>
      </div>

      <div class="editor" style="margin-top:10px">
        <div class="stage" id="restyle-drop">
          <canvas id="restyle-canvas" width="320" height="320"></canvas>
        </div>

        <div class="controls">
          <div class="ctl">
            <div class="muted" style="margin-bottom:6px">Zoom</div>
            <input id="restyle-zoom" type="range" min="0" max="1" step="0.01" value="0.5">
          </div>
          <div class="ctl">
            <div class="muted" style="margin-bottom:6px">Rotate</div>
            <input id="restyle-rot" type="range" min="-180" max="180" step="1" value="0">
          </div>
        </div>

        <div class="actions" style="display:flex;gap:10px;margin-top:4px;justify-content:flex-end">
          <button class="btn secondary" id="restyle-cancel" type="button">Cancel</button>
          <button class="btn" id="restyle-save" disabled>Save changes</button>
        </div>
        <div class="note">Tips: drag the image to reposition. Use zoom/rotate. Output is PNG with transparency preserved.</div>
      </div>
    </div>`;
            document.body.append(restyleEl);
            restyleEl.addEventListener('click', (e) => { if (e.target === restyleEl) hideRestyle(); });
            return restyleEl;
        }

        function hideRestyle() { if (restyleEl) restyleEl.style.display = 'none'; }
        function openRestyleOverlay() {
            const meta = state.convMeta.get(state.convId) || {};
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            if (!det.is_group) return;

            // ensure white knobs override (once)
            if (!document.getElementById('restyle-white-range')) {
                const st = document.createElement('style');
                st.id = 'restyle-white-range';
                st.textContent = `
#restyle-overlay input[type="range"]::-webkit-slider-thumb { background:#fff !important; }
#restyle-overlay input[type="range"]::-moz-range-thumb { background:#fff !important; }
#restyle-overlay input[type="range"]:active::-webkit-slider-thumb { background:#fff !important; }
#restyle-overlay input[type="range"]:active::-moz-range-thumb { background:#fff !important; }`;
                document.head.appendChild(st);
            }

            const el = ensureRestyle();
            el.style.display = 'flex';

            const preview = el.querySelector('#restyle-preview');
            const fileIn = el.querySelector('#restyle-file');
            const fileName = el.querySelector('#restyle-filename');
            const clearBtn = el.querySelector('#restyle-clear');
            const saveBtn = el.querySelector('#restyle-save');
            const cancelBtn = el.querySelector('#restyle-cancel');

            const colorBox = el.querySelector('#restyle-color-choices');
            colorBox.innerHTML = '';

            const canvas = el.querySelector('#restyle-canvas');
            const ctx = canvas.getContext('2d');
            const drop = el.querySelector('#restyle-drop');
            const zoomEl = el.querySelector('#restyle-zoom');
            const rotEl = el.querySelector('#restyle-rot');

            const hadCustomIcon = !!meta.photo && meta.photo !== DEFAULT_PFP_GROUP;
            let clearedToDefault = false;
            let imgBitmap = null;
            let imgW = 0, imgH = 0;
            let pos = { x: 0, y: 0 };
            let dragging = false, last = { x: 0, y: 0 };
            let zoom = parseFloat(zoomEl.value);
            let rot = parseFloat(rotEl.value) * Math.PI / 180;
            let selectedColor = meta.color || '#ffffff';
            let selectedColorKey = (GROUP_COLORS.find(c => c.val === selectedColor)?.key) || null;

            let dirty = false;
            function markDirty() { dirty = true; saveBtn.disabled = false; }
            saveBtn.disabled = true;

            // color chips
            GROUP_COLORS.forEach(c => {
                const b = document.createElement('button');
                b.type = 'button';
                b.className = 'btn';
                b.style.cssText = `border-color:${c.val};background:${c.val};color:#000`;
                b.textContent = c.key;
                if (c.val === selectedColor) b.style.outline = '2px solid #fff';
                b.onclick = () => {
                    selectedColor = c.val;
                    selectedColorKey = c.key;
                    colorBox.querySelectorAll('.btn').forEach(x => x.style.outline = '');
                    b.style.outline = '2px solid #fff';
                    paintPreview();
                    markDirty();
                };
                colorBox.append(b);
            });

            function setImgSafe(img, src, fallback) {
                img.onerror = () => { img.src = fallback; };
                img.src = src || fallback;
            }

            function paintPreview() {
                const showDefault = (!hadCustomIcon || clearedToDefault) && !imgBitmap;
                preview.classList.toggle('is-default', showDefault);

                const activeSrc = showDefault ? DEFAULT_PFP_GROUP : (meta.photo || DEFAULT_PFP_GROUP);
                setImgSafe(preview, activeSrc, DEFAULT_PFP_GROUP);

                const thumb = el.querySelector('.pf-preview .thumb');
                // border should reflect the chosen color (was stuck white)
                thumb.style.borderColor = selectedColor;
                // background stays tinted only when using the default icon
                thumb.style.background = showDefault ? selectedColor : '#000';
            }

            paintPreview();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // stronger zoom range
            function scaleForZoom() {
                const MIN = 0.25, MAX_BYTES = 6; // was 0.5..3; now 0.25..6
                return MIN + zoom * (MAX_BYTES - MIN);
            }

            function redraw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!imgBitmap) return;
                ctx.save();
                ctx.translate(canvas.width / 2 + pos.x, canvas.height / 2 + pos.y);
                ctx.rotate(rot);
                const s = scaleForZoom();
                const dw = imgW * s, dh = imgH * s;
                ctx.drawImage(imgBitmap, -dw / 2, -dh / 2, dw, dh);
                ctx.restore();
            }

            function loadBitmapFromFile(file) {
                return new Promise((resolve, reject) => {
                    const r = new FileReader();
                    r.onload = async () => {
                        try { resolve(await createImageBitmap(new Blob([r.result]))); }
                        catch (e) { reject(e); }
                    };
                    r.onerror = () => reject(r.error);
                    r.readAsArrayBuffer(file);
                });
            }

            async function setImageFile(file) {
                if (!file) return;
                try {
                    imgBitmap = await loadBitmapFromFile(file);
                    imgW = imgBitmap.width; imgH = imgBitmap.height;
                    pos = { x: 0, y: 0 };
                    zoom = 0.5; zoomEl.value = '0.5';
                    rot = 0; rotEl.value = '0';
                    fileName.textContent = file.name;
                    clearedToDefault = false;
                    redraw();
                    const url = URL.createObjectURL(file);
                    preview.src = url;
                    const thumb = el.querySelector('.pf-preview .thumb');
                    thumb.style.background = '#000';
                    markDirty();
                } catch (e) {
                    alert('Could not read image: ' + (errMsg(e)));
                }
            }

            // dnd
            drop.addEventListener('dragover', e => { e.preventDefault(); });
            drop.addEventListener('drop', e => {
                e.preventDefault();
                const f = e.dataTransfer?.files?.[0];
                if (f) setImageFile(f);
            });

            // choose
            fileIn.onchange = () => {
                const f = fileIn.files?.[0];
                if (f) setImageFile(f);
            };

            // clear to default
            clearBtn.onclick = () => {
                imgBitmap = null; imgW = imgH = 0;
                pos = { x: 0, y: 0 };
                zoom = 0.5; zoomEl.value = '0.5';
                rot = 0; rotEl.value = '0';
                fileIn.value = ''; fileName.textContent = '';
                clearedToDefault = true;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                paintPreview();
                markDirty();
            };

            // pan
            canvas.addEventListener('pointerdown', e => {
                dragging = true; last = { x: e.clientX, y: e.clientY };
                canvas.setPointerCapture(e.pointerId);
            });
            canvas.addEventListener('pointermove', e => {
                if (!dragging) return;
                const dx = e.clientX - last.x, dy = e.clientY - last.y;
                last = { x: e.clientX, y: e.clientY };
                pos.x += dx; pos.y += dy;
                redraw();
                markDirty();
            });
            const endDrag = e => { dragging = false; try { canvas.releasePointerCapture(e.pointerId); } catch { } };
            canvas.addEventListener('pointerup', endDrag);
            canvas.addEventListener('pointercancel', endDrag);
            canvas.addEventListener('pointerleave', endDrag);

            // sliders
            zoomEl.oninput = () => { zoom = parseFloat(zoomEl.value); redraw(); markDirty(); };
            rotEl.oninput = () => { rot = parseFloat(rotEl.value) * Math.PI / 180; redraw(); markDirty(); };

            cancelBtn.onclick = () => hideRestyle();

            async function exportPNGMax512() {
                const BYTES_MAX = 1024 * 1024;
                let size = 512;

                async function renderTo(px) {
                    const out = ('OffscreenCanvas' in window) ? new OffscreenCanvas(px, px)
                        : Object.assign(document.createElement('canvas'), { width: px, height: px });
                    const octx = out.getContext('2d');
                    octx.clearRect(0, 0, px, px);

                    if (imgBitmap) {
                        const s = scaleForZoom();
                        octx.save();
                        octx.translate(px / 2 + (pos.x * (px / canvas.width)), px / 2 + (pos.y * (px / canvas.height)));
                        octx.rotate(rot);
                        const dw = imgW * s * (px / canvas.width);
                        const dh = imgH * s * (px / canvas.height);
                        octx.drawImage(imgBitmap, -dw / 2, -dh / 2, dw, dh);
                        octx.restore();
                    }

                    let blob;
                    if (out.convertToBlob) blob = await out.convertToBlob({ type: 'image/png' });
                    else blob = await new Promise(res => out.toBlob(res, 'image/png'));
                    return new Uint8Array(await blob.arrayBuffer());
                }

                let png = imgBitmap ? await renderTo(size) : null;
                while (png && png.length > BYTES_MAX && size > 192) {
                    size = Math.floor(size * 0.85);
                    png = await renderTo(size);
                }
                if (png && png.length > BYTES_MAX) throw new Error('Icon too large even after resizing');
                return { png, size };
            }

            saveBtn.onclick = async () => {
                try {
                    const fd = new FormData();
                    const beforeColor = meta.color || '#ffffff';
                    if (selectedColor && selectedColor !== beforeColor) fd.append('color', selectedColor);

                    if (imgBitmap) {
                        const { png } = await exportPNGMax512();
                        if (png) fd.append('icon', new Blob([png], { type: 'image/png' }), 'group-icon.png');
                    } else if (clearedToDefault) {
                        fd.append('use_default_icon', '1');
                    }

                    await fetch(`${API}/dm/conversations/${state.convId}/appearance`, { method: 'PATCH', credentials: 'include', body: fd });

                    // Local UI polish; server will broadcast conv_meta + system messages
                    if (selectedColor && selectedColor !== beforeColor) {
                        setConvMeta(state.convId, { color: selectedColor });
                    }

                    await fetchConvMeta(state.convId);
                    await loadConversations({ blockingMeta: true });
                    hideRestyle();
                } catch (e) {
                    alert(e.detail || errMsg(e));
                }
            };
        }

        /* ---------------- wire UI ---------------- */
        $('btn-attach').onclick = () => $('file').click();
        $('file').onchange = async e => { await handleFileInput(e.target.files); e.target.value = ''; };
        $('btn-send').onclick = sendMessage;
        $('text').addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

        const voice = $('btn-voice');
        const startRec = e => { e.preventDefault(); voice.textContent = 'Recording… release to stop'; startRecording(); };
        const stopRec = e => { e.preventDefault(); voice.textContent = 'Hold to record'; stopRecording(false); };
        voice.addEventListener('pointerdown', startRec);
        voice.addEventListener('pointerup', stopRec);
        voice.addEventListener('pointercancel', stopRec);
        voice.addEventListener('mouseleave', () => { if (state.recording.active) stopRec(new Event('pointerup')); });

        async function sendMessage() {
            if (!state.convId || state.uploading) return;
            let text = $('text').value;
            if (!text && state.pendingFiles.length === 0) return;
            if (text.length > 10000) { alert('Message is over 10,000 characters. Please shorten it.'); return; }
            text = text.trim();

            // log what we "think" before upload
            const auds = state.pendingFiles.filter(f => (f.type || '').startsWith('audio/'))
                .map(f => ({ name: f.name, bytes: f.size, mime: f.type, client_est_ms: f.durationMs || null }));
            if (auds.length) console.debug('[aud][send] about to upload audio attachments:', auds);

            const fd = new FormData();
            fd.append('text', text);
            state.pendingFiles.forEach((f, i) => {
                const blob = new Blob([f.buf], { type: f.type || 'application/octet-stream' });
                const name = f.name || `file-${i}`;
                fd.append('files', blob, name);
                if (f.encoding) fd.append(`encoding_${name}`, f.encoding); // now works for gzipped files
            });

            state.uploading = true;
            syncSendUI();
            try {
                console.debug('[aud][send] POST /messages with', { files: state.pendingFiles.length, textLen: text.length });
                const r = await fetch(`${API}/dm/conversations/${state.convId}/messages`, { method: 'POST', credentials: 'include', body: fd });
                const t = await r.text();
                if (!r.ok) throw new Error(t || r.statusText);
                let j = {};
                try { j = JSON.parse(t); } catch { }
                console.debug('[aud][send] server acknowledged message:', j);
                if (j && j.id) state.lastMsgId = Math.max(state.lastMsgId, j.id | 0);
                $('text').value = ''; state.pendingFiles = []; refreshChips();
                await fetchAfter(state.lastMsgId);
                loadConversations().catch(() => { });
                if (nearBottom()) { await afterPaint(); scrollToBottom(); }
            } catch (e) {
                alert(errMsg(e));
            } finally {
                state.uploading = false;
                syncSendUI();                        // <— add
            }
        }

        /* ---------------- boot ---------------- */
        (async () => {
            await getMe();
            loadMetaCache();

            const urlMatch = location.pathname.match(/\/user\/([^\/]+)\/messages/i);
            const urlSlug = urlMatch ? decodeURIComponent(urlMatch[1]) : '';
            if (state.meSlug && urlSlug && urlSlug.toLowerCase() !== state.meSlug.toLowerCase()) {
                history.replaceState(null, '', `/user/${encodeURIComponent(state.meSlug)}/messages`);
            }

            await loadConversations({ blockingMeta: true });
            openGlobalStream();
            const last = loadLastDM();
            if (last && (last.meId | 0) === (state.meId | 0)) {
                const exists = state.allConvs.find(c => (c.id | 0) === (last.convId | 0));
                if (exists) { await openConversation(exists.id); return; }
            }
        })();

        /* ---------------- recording impl ---------------- */
        // One shared AudioContext (saves battery; avoids "Too many contexts")
        const AC = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AC();

        // Simple buffer-backed player: always seekable
        class BufferPlayer {
            constructor(url, { onTick, onReady, onEnded } = {}) {
                this.url = url;
                this.onTick = onTick || (() => { });
                this.onReady = onReady || (() => { });
                this.onEnded = onEnded || (() => { });

                this.buffer = null;      // AudioBuffer
                this.src = null;         // AudioBufferSourceNode (one-shot)
                this.gain = audioCtx.createGain();
                this.gain.connect(audioCtx.destination);

                this.offset = 0;         // seconds (where paused)
                this.startedAt = 0;      // audioCtx.currentTime when play() called
                this._raf = null;
                this._playing = false;
            }

            get duration() { return this.buffer ? this.buffer.duration : 0; }
            get currentTime() {
                return this._playing
                    ? this.offset + (audioCtx.currentTime - this.startedAt)
                    : this.offset;
            }

            async load() {
                const res = await fetch(this.url, { credentials: 'include' });
                const ab = await res.arrayBuffer();
                // decodeAudioData throws on unsupported codecs/containers
                this.buffer = await audioCtx.decodeAudioData(ab.slice(0));
                this.onReady(this.duration);
            }

            _tick = () => {
                this.onTick(this.currentTime, this.duration);
                if (this._playing) this._raf = requestAnimationFrame(this._tick);
            };

            _stopSource() {
                if (this.src) {
                    try { this.src.onended = null; this.src.stop(); } catch { }
                    this.src.disconnect();
                    this.src = null;
                }
                if (this._raf) { cancelAnimationFrame(this._raf); this._raf = null; }
                this._playing = false;
            }

            _spawn(startAtSec) {
                const node = audioCtx.createBufferSource();
                node.buffer = this.buffer;
                node.connect(this.gain);
                node.onended = () => {
                    // treat natural end as pause at end, not reset to 0
                    this._stopSource();
                    this.offset = Math.min(this.duration, startAtSec + (audioCtx.currentTime - this.startedAt));
                    if (this.offset >= this.duration - 1e-3) this.onEnded();
                };
                return node;
            }

            play() {
                if (!this.buffer) return;
                if (audioCtx.state === 'suspended') audioCtx.resume();

                // If already playing, ignore
                if (this._playing) return;

                // Guard: clamp offset
                this.offset = Math.max(0, Math.min(this.offset, Math.max(0, this.duration - 1e-6)));

                this.src = this._spawn(this.offset);
                this.startedAt = audioCtx.currentTime;
                this.src.start(0, this.offset);
                this._playing = true;
                this._tick();
            }

            pause() {
                if (!this._playing) return;
                // capture where we are, then stop node
                this.offset = this.currentTime;
                this._stopSource();
            }

            // Seek to absolute seconds
            seekTo(sec) {
                if (!this.buffer) return;
                const clamped = Math.max(0, Math.min(sec, this.duration || 0));
                const wasPlaying = this._playing;
                this.pause();
                this.offset = clamped;
                if (wasPlaying) this.play();
                else this.onTick(this.currentTime, this.duration);
            }

            // Seek by ratio 0..1 (handy for your scrub bar)
            seekRatio(r) { this.seekTo((this.duration || 0) * Math.min(1, Math.max(0, r))); }

            setVolume(v01) { this.gain.gain.value = Math.min(1, Math.max(0, v01)); }
        }

        function setPlayerTotal(attId, ms) {
            const p = state.audioPlayers.get(attId);
            if (!p) return;
            p.totalMs = ms | 0;
            if (p.totEl) p.totEl.textContent = msToClock(p.totalMs);
        }

        function unregisterPlayersIn(root) {
            root.querySelectorAll('.audp').forEach(el => {
                const id = +el.dataset.attId || 0;
                if (id) {
                    console.debug('[aud][ui] unregister player:', id);
                    state.audioPlayers.delete(id);
                }
            });
        }

        function msToClock(ms) {
            ms = Math.max(0, ms | 0);
            const s = Math.round(ms / 1000);
            const m = (s / 60) | 0;
            const r = s % 60;
            return m + ':' + String(r).padStart(2, '0');
        }

        function fallbackHTMLAudio(attId, root, btn, track, fill, curEl, totEl) {
            const tag = root.querySelector('.aud-src');
            if (!tag) return;

            tag.addEventListener('loadedmetadata', () => {
                if (totEl && Number.isFinite(tag.duration)) {
                    totEl.textContent = msToClock(tag.duration * 1000);
                }
            });

            btn.addEventListener('click', () => {
                if (tag.paused) { tag.play(); btn.textContent = '⏸'; }
                else { tag.pause(); btn.textContent = '▶'; }
            });

            tag.addEventListener('timeupdate', () => {
                if (Number.isFinite(tag.duration) && tag.duration > 0) {
                    fill.style.width = `${(tag.currentTime / tag.duration) * 100}%`;
                    if (curEl) curEl.textContent = msToClock(tag.currentTime * 1000);
                }
            });

            tag.addEventListener('ended', () => { btn.textContent = '▶'; fill.style.width = '0%'; });

            // keep it in the map for cleanup symmetry
            const p = state.audioPlayers.get(attId) || {};
            p.tag = tag;
            state.audioPlayers.set(attId, p);
        }

        async function initAudioPlayer(attId, url, root) {
            const btn = root.querySelector('.audp-btn');
            const track = root.querySelector('.audp-track');
            const fill = root.querySelector('.audp-fill');
            const curEl = root.querySelector('.cur');
            const totEl = root.querySelector('.tot');

            const player = new BufferPlayer(url, {
                onTick: (t, d) => {
                    if (d > 0) fill.style.width = `${(t / d) * 100}%`;
                    if (curEl) curEl.textContent = msToClock(t * 1000);
                },
                onReady: (d) => { if (totEl) totEl.textContent = msToClock(d * 1000); },
                onEnded: () => { btn.textContent = '▶'; fill.style.width = '0%'; }
            });

            // NEW: keep a handle so setPlayerTotal/unregister can find it
            state.audioPlayers.set(attId, {
                root, btn, track, fill, curEl, totEl,
                player, totalMs: 0, pendingSeekRatio: null
            });

            try {
                await player.load();
            } catch (e) {
                // see fallback below
                return fallbackHTMLAudio(attId, root, btn, track, fill, curEl, totEl);
            }

            btn.addEventListener('click', () => {
                if (btn.textContent === '▶') { player.play(); btn.textContent = '⏸'; }
                else { player.pause(); btn.textContent = '▶'; }
            });

            const clamp01 = x => Math.min(1, Math.max(0, x));
            const ratioFromX = (x) => {
                const r = track.getBoundingClientRect();
                return clamp01((x - r.left) / r.width);
            };

            let dragging = false;
            track.addEventListener('pointerdown', (e) => {
                dragging = true;
                track.setPointerCapture?.(e.pointerId);
                player.seekRatio(ratioFromX(e.clientX));
            });
            track.addEventListener('pointermove', (e) => {
                if (!dragging) return;
                player.seekRatio(ratioFromX(e.clientX));
            });
            const end = (e) => { dragging = false; try { track.releasePointerCapture(e.pointerId); } catch { } };
            track.addEventListener('pointerup', end);
            track.addEventListener('pointercancel', end);
        }
        function canonicalAudioMime(mt) {
            return (mt || '').split(';')[0] || 'audio/webm';
        }
        function pickAudioMimeType() {
            const cands = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/mp4'];
            if (!('MediaRecorder' in window)) return '';
            for (const t of cands) {
                try { if (!MediaRecorder.isTypeSupported || MediaRecorder.isTypeSupported(t)) return t; } catch { }
            }
            return '';
        }
        function extForMime(mt) {
            if ((mt || '').includes('ogg')) return 'ogg';
            if ((mt || '').includes('mp4')) return 'm4a';
            return 'webm';
        }
        async function probeAudioBlobMs(blob) {
            return new Promise((resolve) => {
                try {
                    const a = document.createElement('audio');
                    a.preload = 'metadata';
                    const url = URL.createObjectURL(blob);
                    a.src = url;
                    const finish = (ms) => { try { URL.revokeObjectURL(url); } catch { } resolve(ms | 0); };
                    a.onloadedmetadata = () => {
                        const ms = Number.isFinite(a.duration) ? Math.round(a.duration * 1000) : 0;
                        console.debug('[rec] client probe loadedmetadata duration_ms=', ms);
                        finish(ms);
                    };
                    a.onerror = () => { console.debug('[rec] client probe failed to decode for duration'); finish(0); };
                } catch {
                    resolve(0);
                }
            });
        }
        async function startRecording() {
            if (state.recording.active) return;
            try {
                console.debug('[rec] requesting microphone…');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                const mime = pickAudioMimeType();
                const opts = mime ? { mimeType: mime, audioBitsPerSecond: 64000 } : {};
                console.debug('[rec] MediaRecorder opts:', opts);

                const rec = new MediaRecorder(stream, opts);
                state.recording = { active: true, chunks: [], size: 0, rec, warnShown: false, mime };
                syncSendUI();

                rec.onstart = () => console.debug('[rec] onstart');
                rec.onerror = (e) => console.error('[rec] error', e);

                rec.ondataavailable = (e) => {
                    const sz = (e?.data?.size) || 0;
                    if (!sz) return;
                    state.recording.chunks.push(e.data);
                    state.recording.size += sz;
                    console.debug('[rec] chunk', { chunkBytes: sz, totalBytes: state.recording.size });

                    if (!state.recording.warnShown && state.recording.size > 850 * 1024) {
                        recWarn.style.display = '';
                        recWarn.textContent = 'Approaching 1MB limit…';
                        state.recording.warnShown = true;
                    }
                    if (state.recording.size > 990 * 1024) {
                        console.debug('[rec] forcing stop to keep under 1MB');
                        stopRecording(true);
                    }
                };

                rec.onstop = async () => {
                    console.debug('[rec] onstop, totalBytes=', state.recording.size);
                    try { recWarn.style.display = 'none'; } catch { }

                    try {
                        const mt = canonicalAudioMime(state.recording.mime || 'audio/webm');
                        let blob;
                        try {
                            blob = new Blob(state.recording.chunks, { type: mt });
                        } catch (e) {
                            console.error('[rec] Blob() failed', e);
                            alert('Could not finalize recording.');
                            return;
                        }
                        if (!blob.size) {
                            console.warn('[rec] empty blob; nothing to attach');
                            return;
                        }

                        // client-side best-effort duration probe
                        const estMs = await probeAudioBlobMs(blob);

                        const ab = await blob.arrayBuffer();
                        const buf = new Uint8Array(ab);
                        if (buf.length > MAX_BYTES) {
                            alert('Voice message too large');
                            return;
                        }

                        const ext = extForMime(mt);
                        const name = `voice.${ext}`;
                        const ftype = mt;
                        console.debug('[rec] attached file (client estimate):', { name, bytes: buf.length, mime: ftype, client_est_ms: estMs });
                        addPendingFile({ name, type: ftype, buf, size: buf.length, encoding: null, durationMs: estMs });
                    } catch (e) {
                        console.error('[rec] finalize failed', e);
                        alert(errMsg(e));
                    } finally {
                        try { stream.getTracks().forEach(t => t.stop()); } catch { }
                        state.recording = { active: false, chunks: [], size: 0, rec: null, warnShown: false, mime: state.recording.mime };
                        syncSendUI();
                        try { $('btn-voice').textContent = 'Hold to record'; } catch { }
                    }
                };

                rec.start(200);
                console.debug('[rec] started with timeslice 200ms');
            } catch (err) {
                console.error('[rec] start failed', err);
                alert('Could not start recording: ' + (err.message || err));
            }
        }
        function stopRecording(force = false) {
            const r = state.recording.rec;
            console.debug('[rec] stopRecording called', { force, hasRecorder: !!r });
            if (r && r.state !== 'inactive') { try { r.stop(); } catch (e) { console.error('[rec] stop error', e); } }
            state.recording.active = false;
            if (force) recWarn.textContent = 'Stopped to keep under 1MB.';
        }

        // === sending lock: block while compressing or uploading ===
        function uploadsInFlight() {
            return state.uploading || state.pendingFiles.some(f => f.status === 'compressing');
        }
        function syncSendUI() {
            const btn = $('btn-send');
            const busy = uploadsInFlight() || state.recording.active;
            btn.disabled = busy;
            btn.textContent = state.uploading ? 'Sending…' : 'Send';
            btn.title = busy
                ? (state.uploading ? 'Uploading message…' : 'Waiting for attachments to finish…')
                : '';
        }

        // Try to gunzip a blob/stream when the name or type suggests gzip
        async function maybeGunzipBlob(blob, name = '') {
            const isGzName = /\.gz$/i.test(name);
            const isGzType = /application\/(x-)?gzip/i.test(blob?.type || '');
            if (!(isGzName || isGzType)) return blob;
            if (!('DecompressionStream' in window)) return blob;
            try {
                const ds = new DecompressionStream('gzip');
                const s = blob.stream().pipeThrough(ds);
                return await new Response(s).blob();
            } catch { return blob; }
        }
        // Same-origin fetch → (maybe) gunzip → Blob
        async function fetchBlobMaybeGunzip(url, name = '') {
            const res = await fetch(url, { credentials: 'include' });
            let b = await res.blob();
            b = await maybeGunzipBlob(b, name);
            return b;
        }
        function blobDownload(name, blob) {
            const a = document.createElement('a');
            const url = URL.createObjectURL(blob);
            a.href = url;
            a.download = name || 'download';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
        }
        // turns a regular <a> into a safe downloader that gunzips if needed
        function fixDownloadLink(anchorEl, url, name, mime) {
            anchorEl.addEventListener('click', async (e) => {
                // Only intercept left-click / keyboard activate
                if (e.defaultPrevented || e.button !== 0 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
                e.preventDefault();
                try {
                    let b = await fetchBlobMaybeGunzip(url, name);
                    // Ensure MIME if the server sent a generic one
                    if (mime && b.type !== mime) b = new Blob([await b.arrayBuffer()], { type: mime });
                    blobDownload(name, b);
                } catch (err) {
                    console.error('[att] safe download failed; falling back', err);
                    // Fallback: let the browser try the raw URL
                    window.open(url, '_blank');
                }
            }, { passive: false });
        }

        function niceBytes(n) {
            const u = ['B', 'KB', 'MB']; let i = 0; while (n >= 1024 && i < u.length - 1) { n /= 1024; i++; }
            return `${Math.round(n)} ${u[i]}`;
        }
        function baseMime(mt = '') { return (mt || '').split(';')[0].trim().toLowerCase(); }
        function extOf(name = '') { const m = name.match(/\.([^.]+)$/); return m ? m[1].toLowerCase() : ''; }
        function isTextLike(name, mt) {
            const e = extOf(name);
            if ((mt || '').startsWith('text/')) return true;
            const codeish = ['txt', 'md', 'markdown', 'log', 'csv', 'tsv', 'json', 'yml', 'yaml', 'xml', 'html', 'css', 'js', 'ts', 'tsx', 'jsx', 'c', 'cc', 'cpp', 'h', 'hpp', 'go', 'rs', 'py', 'rb', 'php', 'java', 'kt', 'swift', 'sql', 'sh', 'bat', 'ps1'];
            return codeish.includes(e);
        }

        /* ====== 8) INLINE RENDERERS FOR ATTACHMENTS ====== */
        /* Call this from renderMessage(...) fallback branch for non-image/video/audio */
        function renderAttachmentInline(rootEl, a) {
            const url = `${API}/dm/attachments/${a.id}/download?inline=1`;
            const mt = baseMime(a.mime_type || '');
            const name = a.filename || 'attachment';

            // PDF
            if (mt === 'application/pdf' || extOf(name) === 'pdf') {
                const wrap = document.createElement('div');
                const frame = document.createElement('iframe');
                frame.className = 'att';
                frame.title = name;
                frame.loading = 'lazy';
                frame.style.width = '100%';
                frame.style.height = '420px';
                wrap.appendChild(frame);
                rootEl.appendChild(wrap);

                (async () => {
                    try {
                        const blob = await fetchBlobMaybeGunzip(url, name);
                        const obj = URL.createObjectURL(blob);
                        frame.src = obj;
                        // DO NOT revoke onload. Keep alive while the iframe exists.
                        frame.dataset.objurl = obj; // let revokeObjectURLsIn() clean it up later
                    } catch {
                        // graceful fallback: plain link (your 3-dot menu still has the real download)
                        const aEl = document.createElement('a');
                        aEl.className = 'att';
                        aEl.href = url; aEl.download = name;
                        aEl.textContent = `📎 ${name} (${niceBytes(a.size || 0)})`;
                        wrap.replaceWith(aEl);
                        fixDownloadLink(aEl, url, name, mt);
                    }
                })();
                return;
            }

            // DOCX/DOC (best-effort via docx-preview; otherwise link)
            if (['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword'].includes(mt) ||
                ['docx', 'doc'].includes(extOf(name))) {
                const box = document.createElement('div');
                box.className = 'att';
                box.style.border = '1px solid var(--border)';
                box.style.background = '#0e1116';
                box.style.padding = '10px';
                box.innerHTML = `<div class="muted" style="margin-bottom:6px">Previewing ${esc(name)}…</div><div class="docx"></div>`;
                rootEl.appendChild(box);
                (async () => {
                    try {
                        await ensureDocxPreviewLoaded();
                        const ab = await (await fetch(url, { credentials: 'include' })).arrayBuffer();
                        const container = box.querySelector('.docx');
                        await window.docx.renderAsync(ab, container);
                    } catch (e) {
                        // graceful fallback
                        box.innerHTML = `<a class="att" href="${url}" download="${esc(name)}">📎 ${esc(name)} (${niceBytes(a.size || 0)})</a>`;
                    }
                })();
                return;
            }

            // TEXT / CODE (fetch small preview then <pre>)
            if (isTextLike(name, mt)) {
                (async () => {
                    try {
                        // note: auto-gunzip, so .js.gz will still show text
                        const blob0 = await fetchBlobMaybeGunzip(url, name);

                        // Show up to ~256KB inline
                        const maxShow = 256 * 1024;
                        if (blob0.size > maxShow) {
                            const aEl = document.createElement('a');
                            aEl.className = 'att';
                            aEl.href = url; aEl.download = name;
                            aEl.textContent = `📎 ${name} (${niceBytes(blob0.size)} — too large to preview)`;
                            rootEl.appendChild(aEl);
                            fixDownloadLink(aEl, url, name, mt);
                            return;
                        }
                        const text = await blob0.text();
                        const pre = document.createElement('pre');
                        pre.className = 'att att-text';
                        pre.style.maxHeight = '420px';
                        pre.style.overflow = 'auto';
                        pre.textContent = text;
                        rootEl.appendChild(pre);
                    } catch {
                        const aEl = document.createElement('a');
                        aEl.className = 'att';
                        aEl.href = url; aEl.download = name;
                        aEl.textContent = `📎 ${name}`;
                        rootEl.appendChild(aEl);
                        fixDownloadLink(aEl, url, name, mt);
                    }
                })();
                return;
            }

            // Unknown types: just a download link (allowed as long as size ≤ 1MB on upload)
            const aEl = document.createElement('a');
            aEl.className = 'att';
            aEl.href = url; aEl.download = name;
            aEl.textContent = `📎 ${name} (${niceBytes(a.size || 0)})`;
            rootEl.appendChild(aEl);
            fixDownloadLink(aEl, url, name, mt);
        }

        /* Lazy-load docx-preview only if needed */
        let __docxLoaded = false;
        async function ensureDocxPreviewLoaded() {
            if (__docxLoaded) return;
            await new Promise((res, rej) => {
                const s = document.createElement('script');
                s.src = 'https://unpkg.com/docx-preview@0.3.4/dist/docx-preview.min.js';
                s.onload = res; s.onerror = rej; document.head.appendChild(s);
            });
            __docxLoaded = true;
        }
    })();
</script>

<script>
    const API = 'http://localhost:3000/api';
    /* ---------- SAFETY: prevent auto-downloads from media tags ---------- */
    (() => {
        // Escape a string for use inside a new RegExp
        const escRe = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        // Any direct media src at this endpoint will be intercepted
        const ATT_RX = new RegExp('^' + escRe(API) + '/dm/attachments/\\d+/download');

        // Wrap setAttribute on IMG/VIDEO/AUDIO to turn "src" → safe blob URL
        const targets = [window.HTMLImageElement, window.HTMLVideoElement, window.HTMLAudioElement].filter(Boolean);

        async function safeSwapSrc(el, url) {
            try {
                // Use your existing helper that also auto-gunzips when needed
                const blob = await fetchBlobMaybeGunzip(url, el.getAttribute('data-filename') || '');
                const obj = URL.createObjectURL(blob);
                el.src = obj;
                el.dataset.objurl = obj; // revokeObjectURLsIn() already cleans these up
            } catch {
                // If we can’t fetch safely, leave src unset.
                // Your renderers/menus already provide explicit download links.
            }
        }

        for (const Ctor of targets) {
            const _setAttr = Ctor.prototype.setAttribute;
            Ctor.prototype.setAttribute = function (name, value) {
                if (name === 'src' && typeof value === 'string' && ATT_RX.test(value)) {
                    // Prevent direct navigation to the download URL
                    // (which can trigger auto-save on some browsers)
                    // Use a data attr as a breadcrumb for debugging
                    _setAttr.call(this, 'data-safe-src', value);
                    // Ensure src is blank until we swap to a blob URL
                    try { this.removeAttribute('src'); } catch { }
                    // Kick off the safe fetch → object URL
                    safeSwapSrc(this, value);
                    return;
                }
                return _setAttr.call(this, name, value);
            };
        }
    })();
</script>