<!doctype html>
<meta charset="utf-8">
<title>Messages</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/web/site.css">

<style>
    :root {
        color-scheme: dark;
        --bg: #0a0b0d;
        --panel: #0e1116;
        --panel-2: #12161c;
        --border: #e6e6e6;
        --soft: rgba(255,255,255,.12);
        --text: #fff;
        --muted: #b8b8b8;
        --bw: 2px;
    }

    /* Font */
    @font-face {
        font-family: 'Voice1';
        src: url('/fonts/Voice1.woff2') format('woff2'), url('/fonts/Voice1.woff') format('woff'), url('/fonts/Voice1.ttf') format('truetype');
        font-weight: 100 900;
        font-style: normal;
        font-display: swap;
    }

    html, body {
        font-family: 'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
    }

    *, :before, :after {
        border-radius: 0 !important;
        box-sizing: border-box;
    }

    input, textarea, button, select {
        font-family: 'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
        -webkit-appearance: none;
        appearance: none;
        color: var(--text);
        border: var(--bw) solid var(--border);
        background: #0e1116;
    }

    ::placeholder {
        color: var(--muted);
        opacity: 1;
    }

    body {
        margin: 0;
        color: var(--text);
        background: #0a0b0d;
        height: 100vh;
        overflow: hidden;
    }

    .wrap {
        height: 100vh;
        display: grid;
        grid-template-columns: 320px 1fr;
    }

    /* LEFT */
    .left {
        background: linear-gradient(180deg,#12161c,#0e1116);
        border-right: var(--bw) solid var(--border);
        display: grid;
        grid-template-rows: auto auto 1fr;
        min-height: 0;
    }

        .left .head {
            padding: 12px 14px;
            border-bottom: var(--bw) solid var(--border);
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .left .tools {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: var(--bw) solid var(--border);
        }

    #convs {
        overflow: auto;
        padding-bottom: 10px;
    }

    .search-input {
        width: 100%;
        height: 40px;
        padding: 9px 12px;
        border: var(--bw) solid var(--border);
        background: #0e1116;
        color: #fff;
        box-shadow: 0 1px 0 var(--soft) inset;
    }

    .btn {
        padding: 10px 14px;
        border: var(--bw) solid var(--border);
        background: #0e1116;
        color: #fff;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 1px 0 var(--soft) inset;
        line-height: 1;
        white-space: nowrap;
        transition: background-color .12s ease, color .12s ease, border-color .12s ease;
    }

        .btn[disabled] {
            opacity: .5;
            cursor: not-allowed;
        }

        .btn:hover {
            background: #fff !important;
            color: #000 !important;
            border-color: #fff !important;
        }

    .iconbtn {
        border: var(--bw) solid var(--border);
        background: #0e1116;
        cursor: pointer;
        opacity: .9;
        display: grid;
        place-items: center;
        width: 38px;
        height: 38px;
        transition: background-color .12s ease;
    }

        .iconbtn:hover {
            background: #151921;
        }

        .iconbtn img {
            width: 22px;
            height: 22px;
            display: block;
            image-rendering: pixelated;
        }

    .conv {
        display: grid;
        grid-template-columns: 44px 1fr;
        gap: 10px;
        padding: 10px 12px;
        border-bottom: 1px solid var(--soft);
        cursor: pointer;
    }

        .conv:hover {
            background: rgba(255,255,255,.06);
        }

        .conv.active {
            background: rgba(255,255,255,.10);
            outline: 2px solid #fff;
        }

        .left .conv > div { min-width: 0; }

    .avatar {
        width: 44px;
        height: 44px;
        border: 2px solid #fff;
        background: #000;
        object-fit: cover;
    }

    .conv .name {
        font-weight: 700;
    }

    .conv .preview {
        color: var(--muted);
        font-size: 13px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    /* RIGHT */
    .right {
        display: grid;
        grid-template-rows: auto 1fr auto;
        min-height: 0;
        position: relative;
    }

    .chat-head {
        padding: 10px 14px;
        border-bottom: var(--bw) solid var(--border);
        background: linear-gradient(180deg,#12161c,#0e1116);
        display: flex;
        align-items: center;
        gap: 10px;
        position: relative;
    }

        .chat-head .spacer {
            flex: 1;
        }

    .chat-pfp {
        width: 28px;
        height: 28px;
        border: var(--bw) solid var(--border);
        object-fit: cover;
        background: #000;
        border-radius: 999px !important;
    }

    .chat-title {
        font-weight: 700;
    }

    /* 3-dots menu */
    .menu {
        position: absolute;
        right: 10px;
        top: 48px;
        background: var(--panel);
        border: var(--bw) solid var(--border);
        box-shadow: 0 8px 18px rgba(0,0,0,.35);
        padding: 6px;
        display: none;
        min-width: 220px;
        z-index: 20;
    }

        .menu .item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .menu .item:hover {
                background: rgba(255,255,255,.06);
            }

    .msgs {
        background: #000;
        padding: 12px 14px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-height: 0;
        position: relative;
    }

    #pad-top, #pad-bottom {
        height: 0;
    }

    .msg {
        max-width: 70%;
        padding: 10px 12px;
        margin: 0;
        border: var(--bw) solid var(--border);
        background: #0b0e12;
        box-shadow: 0 1px 0 var(--soft) inset;
        word-break: break-word;
        overflow-wrap: anywhere;
    }

        .msg > div {
            white-space: pre-wrap;
        }

    .me {
        align-self: flex-end;
        background: #0f1216;
    }

    /* system/command message */
    .sysmsg {
        align-self: center;
        max-width: 84%;
        border: none;
        background: transparent;
        box-shadow: none;
        color: var(--muted);
        font-style: italic;
        text-align: center;
        padding: 6px 8px;
    }

    .meta {
        color: var(--muted);
        font-size: 12px;
        margin-top: 4px;
    }

    .att {
        margin-top: 6px;
    }

    .composer {
        border-top: var(--bw) solid var(--border);
        background: #0b0e12;
        padding: 10px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
    }

        .composer > * {
            min-width: 0;
        }

        .composer textarea {
            width: 100%;
            min-height: 48px;
            max-height: 200px;
            resize: vertical;
            background: #0e1116;
            color: #fff;
            border: var(--bw) solid var(--border);
            padding: 12px;
            caret-color: #fff;
            line-height: 1.25;
        }

    .col {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        flex-wrap: wrap;
    }

    .chips {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 6px;
    }

    .chip {
        display: flex;
        align-items: center;
        gap: 6px;
        border: 1px solid var(--soft);
        padding: 6px 8px;
        font-size: 13px;
    }

        .chip .x {
            cursor: pointer;
            opacity: .85;
        }

    .warn {
        color: #ffdb74;
        font-size: 12px;
    }

    .jump {
        position: sticky;
        bottom: 12px;
        align-self: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity .18s ease;
        z-index: 5;
    }

        .jump.show {
            opacity: 1;
            pointer-events: auto;
        }

    @media (max-width:520px) {
        .msg {
            max-width: 100%;
        }
    }

    /* Overlay */
    .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
    }

    .sheet {
        width: min(720px,94vw);
        max-height: 82vh;
        overflow: auto;
        background: linear-gradient(180deg,var(--panel-2),var(--panel));
        border: var(--bw) solid var(--border);
        box-shadow: 0 8px 18px rgba(0,0,0,.35);
        padding: 12px;
    }

        .sheet h3 {
            margin: 0 0 10px;
        }

    .picker-bar {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin-bottom: 10px;
    }

    .list {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
    }

    .person {
        display: grid;
        grid-template-columns: 44px 1fr auto;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border: var(--bw) solid var(--border);
        background: #0c0f13;
        box-shadow: 0 1px 0 var(--soft) inset;
        cursor: pointer;
    }

    .pfp {
        width: 44px;
        height: 44px;
        border: 2px solid #fff;
        background: #000;
        object-fit: cover;
        border-radius: 999px !important;
    }

    .person .name {
        font-weight: 700;
    }

    .person .bio {
        color: var(--muted);
        font-size: 13px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    .sheet .bottom-center {
        position: sticky;
        bottom: 0;
        display: flex;
        align-items: center;
        gap: 10px;
        padding-top: 10px;
        margin-top: 10px;
        background: linear-gradient(180deg,transparent,rgba(0,0,0,.35));
    }

    /* Checkbox — white hollow square when off; filled white when on */
    .checkbox {
        appearance: none;
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border: 2px solid #fff;
        background: transparent;
        display: inline-block;
        vertical-align: middle;
        margin: 0;
        cursor: pointer;
    }

        .checkbox:hover:not(:checked) {
            opacity: .5;
        }

        .checkbox:checked {
            background: #fff;
        }

        .checkbox:disabled {
            opacity: .3;
            cursor: not-allowed;
        }

        .checkbox:focus-visible {
            outline: 2px solid #fff;
            outline-offset: 2px;
        }

    .avatar, .pfp, .chat-pfp {
        border-radius: 999px !important;
        aspect-ratio: 1 / 1;
        object-fit: cover;
    }

        .chat-pfp.tinted-default {
            box-shadow: 0 0 0 2px var(--gc, #fff) inset;
        }

    #selected-chips {
        flex: 1;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
    }

    /* === Restyle Group editor (scoped) === */
    #restyle-overlay .editor {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
    }

    #restyle-overlay .stage {
        background: #0d1520;
        border: 1px dashed #2a3646;
        border-radius: 12px;
        display: grid;
        place-items: center;
        padding: 10px;
        position: relative;
    }

        #restyle-overlay .stage canvas {
            width: 100%;
            max-width: 480px;
            background: transparent;
        }

    #restyle-overlay .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }

        #restyle-overlay .controls .ctl {
            background: #0d1520;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px;
        }

        #restyle-overlay .controls input[type="range"] {
            width: 100%;
            background: transparent;
            cursor: pointer;
        }

    /* Square knobs + same track look as profile editor */
    #restyle-overlay input[type="range"]::-webkit-slider-runnable-track {
        height: 6px;
        border-radius: 999px;
        background: #1f2a37;
    }

    #restyle-overlay input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 0 !important; /* ⬅︎ square */
        background: #3b82f6;
        border: 2px solid transparent;
        margin-top: -6px;
    }

    #restyle-overlay input[type="range"]::-moz-range-track {
        height: 6px;
        border-radius: 999px;
        background: #1f2a37;
    }

    #restyle-overlay input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 0 !important; /* ⬅︎ square */
        background: #3b82f6;
        border: 2px solid transparent;
    }
    /* hover invert */
    #restyle-overlay input[type="range"]:hover::-webkit-slider-runnable-track {
        background: #fff !important;
    }

    #restyle-overlay input[type="range"]:hover::-moz-range-track {
        background: #fff !important;
    }

    #restyle-overlay input[type="range"]:hover::-webkit-slider-thumb {
        background: #000 !important;
    }

    #restyle-overlay input[type="range"]:hover::-moz-range-thumb {
        background: #000 !important;
    }
    /* active revert */
    #restyle-overlay input[type="range"]:active::-webkit-slider-runnable-track {
        background: #1f2a37 !important;
    }

    #restyle-overlay input[type="range"]:active::-moz-range-track {
        background: #1f2a37 !important;
    }

    #restyle-overlay input[type="range"]:active::-webkit-slider-thumb {
        background: #3b82f6 !important;
    }

    #restyle-overlay input[type="range"]:active::-moz-range-thumb {
        background: #3b82f6 !important;
    }

    #restyle-overlay .file-row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
    }

    #restyle-overlay label.pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 6px 10px;
        border-radius: 999px;
        background: #0d1520;
        border: 1px solid var(--border);
        cursor: pointer;
        transition: background-color .12s ease, color .12s ease, border-color .12s ease;
    }

    #restyle-overlay .pf-preview {
        display: grid;
        grid-template-columns: 88px auto;
        gap: 12px;
        align-items: center;
        background: #0d1520;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 10px;
    }

        #restyle-overlay .pf-preview .thumb {
            width: 88px;
            height: 88px;
            border-radius: 999px !important; /* ⬅︎ force round despite global reset */
            overflow: hidden;
            background: #0e1622;
            border: var(--bw) solid #fff; /* thick white ring */
            display: grid;
            place-items: center;
        }

        #restyle-overlay .pf-preview img {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        #restyle-overlay .pf-preview .thumb img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* or 'cover' if you prefer a tighter crop */
            display: block;
        }

        #restyle-overlay .pf-preview .thumb img.is-default {
            transform: scale(1.12); /* tweak 1.05–1.2 to taste */
        }

    .msg img.att,
    .msg video.att {
        max-width: 100%;
        width: 100%;
        height: auto;
        display: block;
    }

    .msg audio.att {
        width: 100%;
    }

    /* Custom audio player */
    .audp {
        display: grid;
        grid-template-columns: 38px 1fr auto;
        gap: 10px;
        align-items: center;
        width: 100%;
        border: 1px solid var(--border);
        background: #0e1116;
        padding: 8px;
        box-shadow: 0 1px 0 var(--soft) inset;
    }

    .audp-btn {
        width: 34px;
        height: 34px;
        border: var(--bw) solid var(--border);
        background: #0e1116;
        color: var(--text);
        font-weight: 700;
        cursor: pointer;
        display: grid;
        place-items: center;
    }

        .audp-btn:hover {
            background: #151921;
        }

    .audp-track {
        position: relative;
        height: 6px;
        border: 1px solid var(--border);
        background: rgba(255,255,255,.08);
        cursor: pointer;
    }

    .audp-fill {
        position: absolute;
        inset: 0 auto 0 0;
        width: 0%;
        height: 100%;
        background: #fff;
    }

    .audp-time {
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
    }

    .audp audio {
        display: none;
    }


    /* Audio duration chip overlay */
    .att-audio {
        position: relative;
    }

    .att-audio .aud-dur {
        position: absolute;
        right: 8px;
        bottom: 8px;
        padding: 2px 6px;
        font-size: 12px;
        background: rgba(0,0,0,.7);
        border: 1px solid var(--border);
        color: var(--text);
        pointer-events: none;
        user-select: none;
    }

    .msg .from {
        font-weight: 700;
        font-size: 12px;
        color: var(--muted);
        margin: -2px 0 6px;
    }

    /* let each bubble opt-in to its own border color via a CSS var */
    .msg {
        border-color: var(--mbc, var(--border));
    }

    .pixel {
        image-rendering: pixelated;
        image-rendering: crisp-edges; /* fallback */
        image-rendering: -moz-crisp-edges; /* Firefox */
    }

    /* also ensure the default preview is pixelated */
    #restyle-overlay .pf-preview .thumb img.is-default {
        image-rendering: pixelated;
    }
</style>

<div class="wrap">
    <aside class="left">
        <div class="head">Direct Messages</div>
        <div class="tools">
            <input id="conv-q" class="search-input" placeholder="Search conversations…">
            <button id="btn-newdm" class="iconbtn" title="Start a conversation"><img src="/web/icons/new-dm.png" alt="+"></button>
            <button id="btn-newgroup" class="iconbtn" title="Create a group"><img src="/web/icons/new-group.png" alt="◎"></button>
        </div>
        <div id="convs"></div>
    </aside>

    <main class="right">
        <div class="chat-head">
            <img id="chat-pfp" class="chat-pfp" src="/web/default-avatar.png" alt="">
            <div class="chat-title" id="chat-title">Pick a conversation</div>
            <div class="spacer"></div>
            <button id="chat-menu-btn" class="iconbtn" title="Options">⋮</button>
            <div id="chat-menu" class="menu"></div>
        </div>

        <div class="msgs" id="msgs">
            <div id="pad-top"></div>
            <button id="jump" class="jump btn" style="display:none">Jump to present ↓</button>
            <div id="pad-bottom"></div>
        </div>

        <div class="composer">
            <div>
                <textarea id="text" maxlength="10000" placeholder="Message…"></textarea>
                <div class="chips" id="att-chips"></div>
                <div class="warn" id="rec-warn" style="display:none"></div>
            </div>
            <div class="col">
                <button class="btn" id="btn-attach">Attach</button>
                <button class="btn" id="btn-voice">Hold to record</button>
                <button class="btn" id="btn-send">Send</button>
                <input type="file" id="file" multiple style="display:none">
            </div>
        </div>
    </main>
</div>

<!-- People picker overlay (DM / group create / edit / view) -->
<div id="overlay" class="overlay" role="dialog" aria-modal="true">
    <div class="sheet" id="sheet">
        <h3 id="sheet-title">Start a conversation</h3>
        <div class="picker-bar">
            <input id="user-q" class="search-input" placeholder="Search friends…">
        </div>
        <div id="user-list" class="list"></div>
        <div class="bottom-center" id="group-cta" style="display:none">
            <div id="selected-chips"></div>
            <div style="display:flex; gap:8px;">
                <button class="btn" id="btn-cancel">Cancel</button>
                <button class="btn" id="btn-group-submit" disabled>Create Group</button>
            </div>
        </div>
    </div>
</div>

<script>
    (() => {
        const API = 'http://localhost:3000/api';
        const $ = id => document.getElementById(id);

        /* ---------------- state ---------------- */
        const state = {
            convId: null, meId: 0,
            allConvs: [], filteredConvs: [],
            lastMsgId: 0, oldestMsgId: null, nextBefore: null,
            es: null, poll: null,
            uploading: false,
            pendingFiles: [],
            recording: { active: false, chunks: [], size: 0, rec: null, warnShown: false },

            // convo + meta
            convMeta: new Map(),         // convId -> { name, photo, is_group, color }
            convRowEls: new Map(),       // convId -> DOM div.conv
            convUserOg: new Map(),       // convId -> other @username (1:1)
            userCache: new Map(),        // og -> { username, photo, display_name, raw }
            convItems: new Map(),        // convId -> raw item

            // group/menu
            audioPlayers: new Map(), // attId -> { root, audio, btn, track, fill, curEl, totEl, totalMs, dragging }
            audioDurEls: new Map(), // attId -> { audio: HTMLAudioElement, chip: HTMLElement }
            msgColorsByConv: new Map(),
            convDetailById: new Map(),
            currentConvDetail: null,     // {id,is_group,title,owner_id,is_owner,members:[]}
            pickerMode: 'dm',            // 'dm' | 'group-create' | 'group-edit' | 'view-members'
            selectedIds: new Set(),      // picked user_ids (others)
            initialSelectedIds: new Set(),
            friendsCache: [],
            idToFriend: new Map(),

            renderedMsgIds: new Set(),
            fetchingAfter: false,
            meSlug: '',
        };

        const LASTDM_KEY = 'dp:lastdm';
        const META_CACHE_KEY = 'dp:metaCache';
        let _metaSaveTimer = null;

        /* ---------------- defaults & helpers ---------------- */
        const DEFAULT_PFP_DM = '/web/default-avatar.png';
        const DEFAULT_PFP_GROUP = '/web/default-groupavatar.png';

        const GROUP_COLORS = [
            { key: 'blue', val: '#3b82f6' },
            { key: 'green', val: '#22c55e' },
            { key: 'purple', val: '#a855f7' },
            { key: 'orange', val: '#f97316' },
            { key: 'pink', val: '#ec4899' },
            { key: 'teal', val: '#14b8a6' },
            { key: 'yellow', val: '#eab308' },
            { key: 'red', val: '#ef4444' },
        ];
        function randomGroupColor() { return GROUP_COLORS[(Math.random() * GROUP_COLORS.length) | 0]; }

        const afterPaint = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        function esc(s) { return String(s || '').replace(/[&<>]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m])) }
        function fmt(t) { try { return new Date(t).toLocaleString() } catch { return '' } }
        function saveLastDM() { try { localStorage.setItem(LASTDM_KEY, JSON.stringify({ meId: state.meId | 0, convId: state.convId | 0, at: Date.now() })) } catch { } }
        function loadLastDM() { try { return JSON.parse(localStorage.getItem(LASTDM_KEY) || 'null') } catch { return null } }
        function nearBottom(px = 60) { const el = $('msgs'); return (el.scrollHeight - el.scrollTop - el.clientHeight) < px }
        function scrollToBottom() { const el = $('msgs'); el.scrollTop = el.scrollHeight + 9999 }

        const pickDisplay = o => o?.display_name || o?.name || null;
        const pickUsername = o => o?.first_username || o?.username || o?.handle || null;
        const pickPhoto = o => o?.profile_photo || o?.profile_photo_url || o?.photo || o?.photo_url || o?.avatar || o?.avatar_url || o?.picture || o?.image || o?.image_url || null;
        const pickName = o => o?.display_name || o?.name || o?.username || o?.first_username || o?.handle || o?.title || null;

        const HIDE_BEFORE_KEY = 'dp:hideBefore';
        function _getHideMap() { try { return JSON.parse(localStorage.getItem(HIDE_BEFORE_KEY) || '{}'); } catch { return {}; } }
        function _setHideMap(m) { try { localStorage.setItem(HIDE_BEFORE_KEY, JSON.stringify(m)); } catch { } }
        function getHideBeforeId(convId) { const m = _getHideMap(); return m[convId] | 0; }
        function setHideBeforeId(convId, id) { const m = _getHideMap(); m[convId] = id | 0; _setHideMap(m); }
        function clearHideBeforeId(convId) { const m = _getHideMap(); delete m[convId]; _setHideMap(m); }

        function filterHidden(items, convId = state.convId) {
            const cut = getHideBeforeId(convId) | 0;
            if (!cut) return items || [];
            return (items || []).filter(m => (m.id | 0) > cut);
        }

        function joinNames(arr) {
            const a = (arr || []).filter(Boolean);
            if (a.length === 0) return 'Group';
            if (a.length === 1) return a[0];
            if (a.length === 2) return a[0] + ' & ' + a[1];
            return a.slice(0, -1).join(', ') + ' & ' + a[a.length - 1];
        }
        function labelForMember(u) {
            return pickName(u) || 'user';
        }
        function computeDefaultGroupTitle(members) {
            return joinNames((members || []).map(labelForMember));
        }

        function saveMetaCache() {
            const out = {
                convUserOg: Array.from(state.convUserOg.entries()),
                userCache: Array.from(state.userCache.entries()),
                convMeta: Array.from(state.convMeta.entries()),
            };
            try { localStorage.setItem(META_CACHE_KEY, JSON.stringify(out)); } catch { }
        }
        function scheduleSaveMeta() {
            clearTimeout(_metaSaveTimer);
            _metaSaveTimer = setTimeout(saveMetaCache, 120);
        }
        function loadMetaCache() {
            try {
                const j = JSON.parse(localStorage.getItem(META_CACHE_KEY) || 'null');
                if (!j) return;
                (j.convUserOg || []).forEach(([k, v]) => state.convUserOg.set(+k || k, v));
                (j.userCache || []).forEach(([k, v]) => state.userCache.set(k, v));
                (j.convMeta || []).forEach(([k, v]) => state.convMeta.set(+k || k, v));
            } catch { }
        }

        /* ---------------- API core ---------------- */
        async function api(path, opts = {}) {
            const headers = Object.assign({ 'Accept': 'application/json' }, opts.headers || {});
            const isJSON = opts.body && !(opts.body instanceof FormData);
            if (isJSON && !headers['Content-Type']) headers['Content-Type'] = 'application/json';
            const url = API + path;
            const r = await fetch(url, { credentials: 'include', method: opts.method || 'GET', headers, body: isJSON ? JSON.stringify(opts.body) : opts.body });
            const t = await r.text(); let d; try { d = t ? JSON.parse(t) : {} } catch { d = { raw: t } }
            if (!r.ok) { const e = new Error(d?.error || r.statusText); e.status = r.status; e.detail = d?.detail || t; throw e; }
            return d;
        }
        async function getMe() {
            const j = await api('/auth/me');
            state.meId = j?.user?.id || 0;
            state.meSlug = j?.user?.first_username || j?.user?.username || '';
            return state.meId;
        }
        // ---- Server-backed message color helpers ----
        async function fetchMsgColors(convId) {
            const j = await api(`/dm/conversations/${convId}/message_colors`);
            return j?.colors || {}; // { [user_id]: '#hex' }
        }

        // Set ONLY my color (server infers me from auth)
        async function setMyMsgColor(convId, color /* '#hex' or null to clear */) {
            return api(`/dm/conversations/${convId}/message_colors/me`, {
                method: 'PATCH',
                body: { color }
            });
        }

        // Patch multiple users' colors at once (used on create/add)
        async function patchMsgColors(convId, colors /* { [user_id]: '#hex' } */) {
            return api(`/dm/conversations/${convId}/message_colors`, {
                method: 'PATCH',
                body: { colors }
            });
        }

        // In-memory utilities
        function setColorMap(convId, map) { state.msgColorsByConv.set(convId, map || {}); }
        function getColorMap(convId) { return state.msgColorsByConv.get(convId) || {}; }
        function getBorderColorLS(convId, userId) {
            const m = getBorderColorMap(convId);
            return (m && m[userId]) || null;
        }

        async function syncMsgColors(convId, { retry = 0, backoff = 300 } = {}) {
            try {
                let map = await fetchMsgColors(convId);
                let tries = retry;
                let delay = backoff;
                while ((!map || Object.keys(map).length === 0) && tries-- > 0) {
                    await new Promise(r => setTimeout(r, delay));
                    delay *= 2; // exponential backoff
                    map = await fetchMsgColors(convId);
                }
                setColorMap(convId, map || {});
                updateAllMessageBorders();
                return map || {};
            } catch {
                setColorMap(convId, {});
                return {};
            }
        }

        // Choose distinct colors for given user IDs, avoiding already-used colors
        function chooseUniqueColorsForUsers(userIds, existingMap = {}) {
            const used = new Set(Object.values(existingMap || {}));
            const palette = GROUP_COLORS.map(c => c.val);
            const available = palette.filter(c => !used.has(c));
            const out = {};
            for (const uid of userIds) {
                if (existingMap[uid]) continue;
                let color = available.length ? available.splice((Math.random() * available.length) | 0, 1)[0]
                    : palette[(Math.random() * palette.length) | 0];
                out[uid] = color;
                used.add(color);
            }
            return out; // only the newly-assigned entries
        }


        /* ---------------- meta resolution ---------------- */
        async function fetchConvMeta(id) {
            const prev = state.convMeta.get(id);
            try {
                const j = await api(`/dm/conversations/${id}`);

                let meta = { name: 'Direct Message', photo: DEFAULT_PFP_DM, is_group: !!j.is_group, color: (j.color || null) };
                if (j.is_group) {
                    const members = j.members || [];
                    const autoDefault = computeDefaultGroupTitle(members);
                    const serverTitle = (j.title || '').trim();
                    const hasCustom = !!(serverTitle && serverTitle !== autoDefault);

                    meta.name = hasCustom ? serverTitle : autoDefault;
                    meta.photo = j.photo || j.avatar || DEFAULT_PFP_GROUP;
                    meta.color = j.color || meta.color || '#ffffff';
                    meta.auto_title = !hasCustom;
                } else {
                    const other = j.other || (Array.isArray(j.members) ? j.members.find(u => (u.id | 0) !== (state.meId | 0)) : null);
                    meta.name = pickName(other) || meta.name;
                    meta.photo = pickPhoto(other) || DEFAULT_PFP_DM;
                }

                const detail = { id: j.id, is_group: !!j.is_group, title: j.title || null, owner_id: j.owner_id || null, is_owner: !!j.is_owner, members: j.members || [] };
                state.convDetailById.set(id, detail);
                if ((state.convId | 0) === (id | 0)) state.currentConvDetail = detail;

                const best = { ...(prev || {}), ...meta };
                state.convMeta.set(id, best);
                if ((state.convId | 0) === (id | 0)) updateEverywhere(id);
                return best;
            } catch (e) {
                if (prev) return prev;
                const fallback = { name: 'Direct Message', photo: DEFAULT_PFP_DM, is_group: false };
                state.convMeta.set(id, fallback);
                return fallback;
            }
        }

        function setConvMeta(id, meta) {
            const prev = state.convMeta.get(id) || {};
            const next = { ...prev, ...meta };
            state.convMeta.set(id, next);
            updateEverywhere(id);
            scheduleSaveMeta();
        }

        function setImgSafe(img, src, fallback = DEFAULT_PFP_DM) {
            if (!img) return;
            const want = src || fallback;
            if (img.dataset.srcApplied === want) return;
            img.onerror = () => { img.src = fallback; img.dataset.srcApplied = fallback; };
            img.src = want; img.dataset.srcApplied = want;
        }

        function updateTopBar(meta) {
            if (!meta) return;
            $('chat-title').textContent = meta.name || 'Direct Message';
            const pfp = $('chat-pfp');
            setImgSafe(pfp, meta.photo, meta?.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM);
            if (meta.is_group) {
                const gc = meta.color || '#ffffff';
                pfp.style.borderColor = gc;
                pfp.style.setProperty('--gc', gc);
                const isDefaultGroup = (meta.photo === DEFAULT_PFP_GROUP);
                pfp.classList.toggle('tinted-default', isDefaultGroup);
                pfp.classList.toggle('pixel', isDefaultGroup);
                pfp.style.background = isDefaultGroup ? gc : '#000';
            } else {
                const isDefaultDm = (meta.photo === DEFAULT_PFP_DM);
                pfp.style.borderColor = 'var(--border)';
                pfp.classList.remove('tinted-default');
                pfp.classList.toggle('pixel', isDefaultDm);
                pfp.style.background = '#000';
            }
            renderChatMenu();
        }

        function updateEverywhere(id) {
            const meta = state.convMeta.get(id);
            if (!meta) return;
            const row = state.convRowEls.get(id);
            if (row) setConvRowContent(row, meta, row.querySelector('.preview')?.textContent || '');
            if (state.convId === id) updateTopBar(meta);
        }

        function setConvRowContent(row, meta, preview) {
            const photo = meta?.photo || (meta?.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM);
            const border = meta?.is_group ? (meta?.color || '#fff') : '#fff';
            const isDefault = (photo === DEFAULT_PFP_GROUP) || (photo === DEFAULT_PFP_DM);
            row.innerHTML = `
    <img class="avatar ${photo === DEFAULT_PFP_GROUP ? 'tinted-default' : ''} ${isDefault ? 'pixel' : ''}"
         src="${photo}" alt=""
         style="border-color:${border}; background:${photo === DEFAULT_PFP_GROUP ? border : '#000'}">
    <div>
      <div class="name">${esc(meta?.name || 'Direct Message')}</div>
      <div class="preview">${esc(preview || '…')}</div>
    </div>`;
        }

        function applySelectedHighlight() {
            document.querySelectorAll('.conv.active').forEach(el => el.classList.remove('active'));
            const el = state.convRowEls.get(state.convId);
            if (el) el.classList.add('active');
        }

        function extractOgFromConvDetail(j) {
            const direct = j?.other_username || j?.other?.first_username || j?.other?.username ||
                j?.with?.first_username || j?.with?.username || null;
            if (direct) return direct;
            const arr = j?.members || j?.participants || j?.users || j?.people || [];
            if (Array.isArray(arr) && arr.length) {
                const other = arr.find(p => {
                    const pid = (p?.id ?? p?.user?.id);
                    return pid == null || (pid | 0) !== (state.meId | 0);
                }) || arr[0];
                const u = other?.user || other || {};
                return pickUsername(u) || null;
            }
            return null;
        }

        async function fetchUserByOg(og) {
            if (!og) throw new Error('no-og');
            if (state.userCache.has(og)) return state.userCache.get(og);
            const tries = [
                `/users/${encodeURIComponent(og)}`,
                `/users/${encodeURIComponent(og)}?view=basic`,
                `/profiles/${encodeURIComponent(og)}`,
                `/users/by_username/${encodeURIComponent(og)}`,
                `/user/${encodeURIComponent(og)}`
            ];
            for (const path of tries) {
                try {
                    const j = await api(path);
                    const username = pickUsername(j) || og;
                    const photo = pickPhoto(j);
                    const display = pickDisplay(j);
                    const result = { username, photo, display_name: display, raw: j };
                    state.userCache.set(og, result);
                    scheduleSaveMeta();
                    return result;
                } catch { }
            }
            throw new Error('user-not-found:' + og);
        }
        function metaFromUser(u) {
            const nm = pickName(u) || 'Direct Message';
            const ph = pickPhoto(u) || DEFAULT_PFP_DM;
            return { name: nm, photo: ph, is_group: false };
        }

        /* ---------------- conversations list ---------------- */
        function renderConvs(list) {
            const wrap = $('convs'); wrap.innerHTML = '';
            state.convRowEls.clear();
            list.forEach(it => {
                const row = document.createElement('div'); row.className = 'conv'; row.dataset.id = it.id;
                const defaultMeta = { name: (it.is_group ? (it.title || 'Group') : (it.title || 'Direct Message')), photo: it.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM, is_group: !!it.is_group, color: it.color || null };
                const meta = state.convMeta.get(it.id) || defaultMeta;
                row.onclick = () => openConversation(it.id, meta?.name || defaultMeta.name);

                // If we have a cutoff for this convo, suppress the server preview (it points to old history)
                const hasCut = !!getHideBeforeId(it.id);
                const preview = hasCut ? '' : (it.preview || '');

                setConvRowContent(row, meta, preview);
                state.convRowEls.set(it.id, row);
                wrap.append(row);
                if (!state.convMeta.has(it.id)) state.convMeta.set(it.id, defaultMeta);
                if (!state.convMeta.has(it.id)) fetchConvMeta(it.id).catch(() => { });
            });
            applySelectedHighlight();
        }
        function applyConvFilter() {
            const q = $('conv-q').value.trim().toLowerCase();
            state.filteredConvs = !q ? [...state.allConvs]
                : state.allConvs.filter(c => {
                    const name = (state.convMeta.get(c.id)?.name || c.title || 'Direct Message').toLowerCase();
                    return name.includes(q) || (c.preview || '').toLowerCase().includes(q);
                });
            renderConvs(state.filteredConvs);
        }
        async function loadConversations({ blockingMeta = false } = {}) {
            const j = await api('/dm/conversations');
            state.allConvs = j.items || [];
            state.allConvs.forEach(it => state.convItems.set(it.id, it));

            for (const it of state.allConvs) {
                if (!state.convMeta.has(it.id)) {
                    let meta = {
                        name: it.is_group ? (it.title || 'Group') : 'Direct Message',
                        photo: it.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM,
                        is_group: !!it.is_group,
                        color: it.color || null
                    };

                    if (!it.is_group) {
                        let og = state.convUserOg.get(it.id) || extractOgFromConvDetail(it);
                        if (og) {
                            state.convUserOg.set(it.id, og);
                            const cached = state.userCache.get(og);
                            meta.name = pickName(cached?.raw || cached) || og;
                            if (cached?.photo) meta.photo = cached.photo;
                            scheduleSaveMeta();
                        }
                    }
                    state.convMeta.set(it.id, meta);
                }
            }
            scheduleSaveMeta();

            if (blockingMeta) {
                await Promise.allSettled(
                    state.allConvs.map(it => fetchConvMeta(it.id))
                );
            } else {
                state.allConvs.forEach(it => {
                    if (!state.convMeta.has(it.id)) fetchConvMeta(it.id).catch(() => { });
                });
            }
            renderConvs(state.allConvs);
        }
        $('conv-q').addEventListener('input', applyConvFilter);

        /* ---------------- virtualization ---------------- */
        const MAX_DOM = 140, GAP = 6;
        let bottomPadPx = 0, removedBottom = [];
        function setBottomPad(px) { bottomPadPx = Math.max(0, px | 0); $('pad-bottom').style.height = bottomPadPx + 'px'; }

        function renderMessage(m, showFrom = false) {
            const isSystem = (m.kind === 'system');
            const wrap = document.createElement('div');
            wrap.className = (isSystem ? 'msg sysmsg' : ('msg' + (m.sender_id === state.meId ? ' me' : '')));
            if (!isSystem) wrap.dataset.senderId = m.sender_id || '';

            // optional sender label for group chats
            if (!isSystem && isGroupChat() && showFrom) {
                const label = document.createElement('div');
                label.className = 'from';
                label.textContent = usernameFor(m.sender_id);
                wrap.appendChild(label);
            }

            if (m.text) wrap.insertAdjacentHTML('beforeend', '<div>' + esc(m.text) + '</div>');
            if (!isSystem) {
                (m.attachments || []).forEach(a => {
                    const url = `${API}/dm/attachments/${a.id}/download?inline=1`;
                    if ((a.mime_type || '').startsWith('image/')) {
                        wrap.insertAdjacentHTML('beforeend', `<img class="att" src="${url}">`);
                    } else if ((a.mime_type || '').startsWith('video/')) {
                        wrap.insertAdjacentHTML('beforeend', `<video class="att" src="${url}" controls></video>`);
                    } else if ((a.mime_type || '').startsWith('audio/')) {
                        // Custom player that always knows total duration
                        wrap.insertAdjacentHTML('beforeend', `
                    <div class="audp" data-att-id="${a.id}">
                        <button class="audp-btn" type="button" aria-label="Play">▶</button>
                        <div class="audp-track"><div class="audp-fill"></div></div>
                        <div class="audp-time"><span class="cur">0:00</span> / <span class="tot">0:00</span></div>
                        <audio class="aud-src" preload="metadata" data-src="${url}"></audio>
                    </div>
                `);
                        const playerRoot = wrap.lastElementChild;
                        // init after it’s in the DOM
                        queueMicrotask(() => {
                            initAudioPlayer(a.id, url, playerRoot);
                            if (Number.isFinite(a.duration_ms) && a.duration_ms > 0) {
                                setPlayerTotal(a.id, a.duration_ms);
                            }
                        });
                    } else {
                        wrap.insertAdjacentHTML('beforeend', `<a class="att" href="${url}">📎 ${esc(a.filename)}</a>`);
                    }
                });

                // timestamp
                wrap.insertAdjacentHTML('beforeend', `<div class="meta">${m.created_at ? fmt(m.created_at) : ''}</div>`);

                // apply per-sender border color (if any)
                const col = (getColorMap(state.convId) || {})[m.sender_id] || null;
                if (col) wrap.style.setProperty('--mbc', col);
            }

            // auto-scroll for media
            wrap.querySelectorAll('img').forEach(img =>
                img.addEventListener('load', () => { if (nearBottom(200)) scrollToBottom(); }, { once: true })
            );
            wrap.querySelectorAll('video').forEach(v =>
                v.addEventListener('loadedmetadata', () => { if (nearBottom(200)) scrollToBottom(); }, { once: true })
            );

            return wrap;
        }

        function ensureFiniteDuration(audio) {
            // If we already injected a server duration, skip any hacks.
            if (audio?.dataset?.serverMs) return;

            if (Number.isFinite(audio.duration) && audio.duration > 0) return;

            const onTU = () => {
                if (Number.isFinite(audio.duration) && audio.duration > 0) {
                    audio.removeEventListener('timeupdate', onTU);
                    if (audio.paused) audio.currentTime = 0;
                }
            };

            audio.addEventListener('timeupdate', onTU);
            try { audio.currentTime = 1e101; } catch { }
        }

        function revokeAudioURLsIn(root) {
            if (!root) return;
            root.querySelectorAll('audio').forEach(a => {
                const u = a.dataset.objurl;
                if (u) {
                    try { URL.revokeObjectURL(u); } catch { }
                    delete a.dataset.objurl;
                }
            });
        }

        async function prepareFiniteAudio(attId, audio) {
            try {
                const original = audio.dataset.src || audio.src || '';
                if (!original) return;

                console.debug('[aud][dl] fetching audio for header probe:', { url: original });
                const res = await fetch(original, { credentials: 'include' });
                if (!res.ok) throw new Error(`bad status ${res.status}`);

                const hdr = res.headers.get('X-Audio-Duration-Ms') || res.headers.get('x-audio-duration-ms');
                console.debug('[aud][dl] response header X-Audio-Duration-Ms:', hdr);
                const ms = hdr != null ? parseInt(hdr, 10) : NaN;
                if (Number.isFinite(ms) && ms > 0) {
                    audio.dataset.serverMs = String(ms);
                    if (attId) setPlayerTotal(attId, ms);
                } else {
                    console.debug('[aud][dl] header missing or not a number.');
                }

                // Get the bytes once, use for both objectURL and WebAudio decode
                const blob = await res.blob();

                // Set playable src
                const u = URL.createObjectURL(blob);
                audio.src = u;
                audio.dataset.objurl = u;
                console.debug('[aud][dl] objectURL set for audio element');

                // Ensure browsers with weird duration behavior settle to a finite value
                audio.addEventListener('loadedmetadata', () => ensureFiniteDuration(audio), { once: true });
                audio.addEventListener('play', () => ensureFiniteDuration(audio), { once: true });

                // If server/header didn’t provide duration, decode to get it up-front
                if (attId && (!audio.dataset.serverMs || audio.dataset.serverMs === '0')) {
                    try {
                        const ac = new (window.AudioContext || window.webkitAudioContext)();
                        const ab = await blob.arrayBuffer();
                        // Safari sometimes needs a copy; ab.slice(0) keeps it safe across engines
                        const buf = await ac.decodeAudioData(ab.slice(0));
                        const ms2 = Math.round(buf.duration * 1000);
                        if (Number.isFinite(ms2) && ms2 > 0) setPlayerTotal(attId, ms2);
                        try { ac.close(); } catch { }
                    } catch (e) {
                        console.debug('[aud][dl] decodeAudioData failed:', e);
                    }
                }
            } catch (err) {
                console.debug('[aud][dl] fallback path due to error:', err);
                if (!audio.src && audio.dataset.src) audio.src = audio.dataset.src;
                audio.addEventListener('loadedmetadata', () => ensureFiniteDuration(audio), { once: true });
                audio.addEventListener('play', () => ensureFiniteDuration(audio), { once: true });
            }
        }

        function appendMessagesAscending(items) {
            items = (items || []).filter(m => !state.renderedMsgIds.has(m.id));
            if (!items.length) return;
            // if we had a cutoff and new stuff arrived, clear it so previews can show again
            const cut = getHideBeforeId(state.convId);
            if (cut && items.some(m => (m.id | 0) > cut)) clearHideBeforeId(state.convId);

            const anchor = $('pad-bottom');
            items.forEach(m => {
                state.renderedMsgIds.add(m.id);

                // look at the message immediately before where we're inserting (chronological previous)
                let prev = anchor.previousElementSibling;
                while (prev && !prev.classList.contains('msg')) prev = prev.previousElementSibling;
                const prevSender = (prev && !prev.classList.contains('sysmsg')) ? (+prev.dataset.senderId || null) : null;
                const showFrom = isGroupChat() && prevSender !== (m.sender_id | 0);

                const el = renderMessage(m, showFrom);
                anchor.before(el);

                state.oldestMsgId = state.oldestMsgId === null ? m.id : Math.min(state.oldestMsgId, m.id);
                state.lastMsgId = Math.max(state.lastMsgId, m.id);
            });
            updateAllMessageBorders();
            maybeTrimBottom();
        }
        function prependOlderAscending(items) {
            items = (items || []).filter(m => !state.renderedMsgIds.has(m.id));
            if (!items.length) return;
            const box = $('msgs');
            const prevTop = box.scrollTop, prevH = box.scrollHeight;
            const frag = document.createDocumentFragment();

            let prevSenderInThisBlock = null; // chronological previous inside this batch
            items.forEach(m => {
                state.renderedMsgIds.add(m.id);
                const showFrom = isGroupChat() && prevSenderInThisBlock !== (m.sender_id | 0);
                const el = renderMessage(m, showFrom);
                frag.append(el);
                prevSenderInThisBlock = m.sender_id | 0;

                state.oldestMsgId = state.oldestMsgId === null ? m.id : Math.min(state.oldestMsgId, m.id);
                state.lastMsgId = Math.max(state.lastMsgId, m.id);
            });

            const afterTop = $('pad-top').nextSibling || $('pad-bottom');
            box.insertBefore(frag, afterTop);

            /* fix the label on what USED TO be the first message,
               because its "previous" just changed */
            const newLastInserted = afterTop.previousElementSibling;
            const oldFirst = afterTop; // the element that was first before
            if (oldFirst && newLastInserted &&
                oldFirst.classList.contains('msg') && !oldFirst.classList.contains('sysmsg') &&
                newLastInserted.classList.contains('msg') && !newLastInserted.classList.contains('sysmsg')) {
                const same = (+oldFirst.dataset.senderId || 0) === (+newLastInserted.dataset.senderId || 0);
                const fromEl = oldFirst.querySelector('.from');
                if (same && fromEl) fromEl.remove();
                if (!same && isGroupChat() && !fromEl) {
                    const label = document.createElement('div');
                    label.className = 'from';
                    label.textContent = usernameFor(+oldFirst.dataset.senderId || 0);
                    oldFirst.insertBefore(label, oldFirst.firstChild);
                }
            }

            box.scrollTop = prevTop + (box.scrollHeight - prevH);
            maybeTrimBottom();
        }
        function maybeTrimBottom() {
            const box = $('msgs');
            if (nearBottom(200)) return;
            while (true) {
                const last = $('pad-bottom').previousElementSibling;
                if (!last || !last.classList.contains('msg')) break;
                const count = box.querySelectorAll('.msg').length;
                if (count <= MAX_DOM) break;
                const h = last.offsetHeight + GAP;
                removedBottom.push({ el: last, h });

                // revoke blob URLs
                last.querySelectorAll('audio').forEach(a => {
                    const u = a.dataset.objurl;
                    if (u) {
                        try { URL.revokeObjectURL(u); } catch { }
                        delete a.dataset.objurl;
                    }
                });

                // drop custom player registrations for this subtree
                unregisterPlayersIn(last);

                last.remove();
                setBottomPad(bottomPadPx + h);
            }
        }
        function maybeRestoreBottom(chunk = 24) {
            if (!removedBottom.length) return;
            const box = $('msgs'); const dist = (box.scrollHeight - box.clientHeight - box.scrollTop);
            if (dist > 1200) return;
            let n = 0; while (removedBottom.length && n < chunk) {
                const { el, h } = removedBottom.pop();
                $('pad-bottom').before(el); setBottomPad(bottomPadPx - h); n++;
            }
        }

        const jumpBtn = (() => {
            const el = $('jump');
            function sync() { if (nearBottom(120)) { el.classList.remove('show'); el.style.display = 'none'; } else { el.style.display = ''; el.classList.add('show'); } }
            el.addEventListener('click', () => { while (removedBottom.length) { const { el: n, h } = removedBottom.pop(); $('pad-bottom').before(n); setBottomPad(bottomPadPx - h); } scrollToBottom(); sync(); });
            return { sync };
        })();

        /* ---------------- open/paging/realtime ---------------- */
        async function openConversation(id) {
            if (state.es) { try { state.es.close(); } catch { } state.es = null; }
            if (state.poll) { clearInterval(state.poll); state.poll = null; }

            state.convId = id;
            saveLastDM();
            state.currentConvDetail = state.convDetailById.get(id) || null;
            applySelectedHighlight();

            // Seed (very brief) fallback meta if needed
            if (!state.convMeta.has(id)) {
                const seed = state.convItems.get(id) || {};
                state.convMeta.set(id, {
                    name: seed.title || 'Direct Message',
                    photo: seed.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM,
                    is_group: !!seed.is_group,
                    color: seed.color || null
                });
            }

            // ⬇️ Wait for fresh server meta so header ring & list chips have the real color
            try { await fetchConvMeta(id); } catch { }

            // Now render messages
            revokeAudioURLsIn($('msgs'));
            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
            state.audioPlayers.clear(); // <— add this
            state.renderedMsgIds.clear();
            setBottomPad(0);
            removedBottom = [];
            state.lastMsgId = 0;
            state.oldestMsgId = null;
            state.nextBefore = null;

            const j = await api(`/dm/conversations/${id}/messages?limit=30`);
            appendMessagesAscending(filterHidden(j.items, id));
            state.nextBefore = j.next_before;

            try { await (document.fonts && document.fonts.ready); } catch { }
            await afterPaint(); await afterPaint();
            scrollToBottom();

            jumpBtn.sync();
            openStream(id);
            startCatchup();

            // ⬇️ do a color map fetch with retry (see next section)
            await syncMsgColors(id, { retry: 3 });
            updateAllMessageBorders();
        }

        $('msgs').addEventListener('scroll', async () => {
            jumpBtn.sync(); maybeRestoreBottom();
            const box = $('msgs');
            if (box.scrollTop <= 20 && state.nextBefore) {
                const j = await api(`/dm/conversations/${state.convId}/messages?before=${state.nextBefore}&limit=20`);
                prependOlderAscending(filterHidden(j.items));
                state.nextBefore = j.next_before;
            }
        });

        function openStream(id) {
            const es = new EventSource(`${API}/dm/conversations/${id}/stream`, { withCredentials: true });
            state.es = es;
            es.addEventListener('new', async () => { await fetchAfter(state.lastMsgId); });
            es.addEventListener('audio_meta', (e) => {
                try {
                    const d = JSON.parse(e.data || '{}');
                    console.debug('[aud][sse] audio_meta received:', d);
                    if (d?.attachment_id && Number.isFinite(d.duration_ms)) {
                        setPlayerTotal(d.attachment_id, d.duration_ms | 0);
                    } else {
                        console.debug('[aud][sse] audio_meta ignored (missing fields).');
                    }
                } catch (err) {
                    console.debug('[aud][sse] audio_meta parse error:', err);
                }
            });
        }
        function openGlobalStream() {
            if (state.esGlobal) { try { state.esGlobal.close(); } catch { } }
            const es = new EventSource(`${API}/dm/stream`, { withCredentials: true });
            state.esGlobal = es;

            let reloadTimer = null;
            function scheduleConvsReload() {
                clearTimeout(reloadTimer);
                reloadTimer = setTimeout(() => { loadConversations().catch(() => { }); }, 200);
            }

            es.addEventListener('conv_new', (e) => {
                try {
                    const d = JSON.parse(e.data || '{}');
                    const cid = d.conversation_id || d.id;
                    if (cid) {
                        // clear any stale local color map and refresh meta ASAP
                        state.msgColorsByConv.delete(cid);
                        fetchConvMeta(cid).catch(() => { });
                    }
                } catch { }
                scheduleConvsReload();
            });

            es.addEventListener('message', (e) => {
                // New message in some conversation (not necessarily open)
                const d = JSON.parse(e.data || '{}');
                if ((d.conversation_id | 0) !== (state.convId | 0)) scheduleConvsReload();
            });

            es.addEventListener('conv_meta', (e) => {
                // Group color/icon changed; update meta and header/list without refresh
                const d = JSON.parse(e.data || '{}');
                const cid = d.conversation_id | 0;
                const prev = state.convMeta.get(cid) || {};
                const newPhoto = d.photo_ts ? `${API}/dm/conversations/${cid}/icon?ts=${encodeURIComponent(d.photo_ts)}` : prev.photo;
                const next = {
                    ...prev,
                    is_group: true,
                    color: (typeof d.color === 'string' && d.color) ? d.color : prev.color || null,
                    photo: newPhoto || prev.photo
                };
                state.convMeta.set(cid, next);
                updateEverywhere(cid);
                if ((cid | 0) === (state.convId | 0)) updateTopBar(next);
            });

            es.addEventListener('color_change', (e) => {
                const d = JSON.parse(e.data || '{}');
                const cid = d.conversation_id | 0;
                const uid = d.user_id | 0;
                const cmap = { ...getColorMap(cid) };
                if (d.color) cmap[uid] = d.color; else delete cmap[uid];
                setColorMap(cid, cmap);
                if ((cid | 0) === (state.convId | 0)) updateAllMessageBorders();
            });

            es.onerror = () => { /* keep alive is handled server-side; browser will retry */ };
        }
        function startCatchup() { state.poll = setInterval(() => { fetchAfter(state.lastMsgId).catch(() => { }); }, 30000); }
        async function fetchAfter(lastId) {
            if (state.fetchingAfter) return;
            state.fetchingAfter = true;
            try {
                const j = await api(`/dm/conversations/${state.convId}/messages?after=${lastId}&limit=100`);
                const filtered = filterHidden(j.items);
                if (!filtered || !filtered.length) return;
                const stick = nearBottom(80);
                appendMessagesAscending(filtered);
                if (stick) { await afterPaint(); scrollToBottom(); }

                loadConversations().catch(() => { });
                jumpBtn.sync();
            } finally {
                state.fetchingAfter = false;
            }
        }

        /* ---------------- attachments + voice ---------------- */
        const MAX = 1024 * 1024;
        const chips = $('att-chips'); const recWarn = $('rec-warn');

        function refreshChips() {
            chips.innerHTML = '';
            state.pendingFiles.forEach((f, i) => {
                const c = document.createElement('div'); c.className = 'chip';
                c.innerHTML = `<span>${esc(f.name)} · ${(f.size / 1024 | 0)} KB</span><span class="x">✕</span>`;
                c.querySelector('.x').onclick = () => { state.pendingFiles.splice(i, 1); refreshChips(); };
                chips.append(c);
            });
        }
        function addPendingFile(o) { state.pendingFiles.push(o); refreshChips(); }

        async function gzipBytes(uint8) {
            if (!('CompressionStream' in window)) return { buf: uint8, encoding: null };
            const cs = new CompressionStream('gzip'); const w = cs.writable.getWriter(); await w.write(uint8); await w.close();
            const res = await new Response(cs.readable).arrayBuffer(); return { buf: new Uint8Array(res), encoding: 'gzip' };
        }
        async function compressImage(file, maxSide = 1280, q = .75) {
            const img = await createImageBitmap(file);
            let { width: w, height: h } = img; const s = Math.min(1, maxSide / Math.max(w, h)); w = (w * s) | 0; h = (h * s) | 0;
            const canvas = new OffscreenCanvas(w, h); const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, w, h);
            let blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: q });
            while (blob.size > MAX && q > 0.4) { q -= 0.1; blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: q }); }
            if (blob.size > MAX) throw new Error('Image too large even after compression');
            return new Uint8Array(await blob.arrayBuffer());
        }
        async function compressGeneric(file) {
            const uint = new Uint8Array(await file.arrayBuffer());
            const { buf, encoding } = await gzipBytes(uint);
            if (buf.length > MAX) throw new Error('File too large after compression');
            return { buf, encoding };
        }
        async function handleFileInput(files) {
            for (const file of files) {
                try {
                    const type = (file.type || '').toLowerCase();
                    if (type.startsWith('image/')) {
                        const buf = await compressImage(file);
                        addPendingFile({ name: file.name.replace(/\.(png|webp|jpeg|jpg)$/i, '.jpg'), type: 'image/jpeg', buf, size: buf.length, encoding: null });
                    } else {
                        const { buf, encoding } = await compressGeneric(file);
                        addPendingFile({ name: (encoding === 'gzip' && !/\.gz$/i.test(file.name)) ? file.name + '.gz' : file.name, type: file.type || 'application/octet-stream', buf, size: buf.length, encoding });
                    }
                } catch (e) { alert(`${file.name}: ${e.message || e}`); }
            }
        }

        /* ---------------- overlay (friends / group create/edit/view) ---------------- */
        const overlay = $('overlay'), userList = $('user-list');

        async function fetchFriends() {
            let arr = [];
            try {
                const j1 = await api(`/users/me/friends`);
                arr = j1.items || j1.friends || [];
            } catch { }
            if ((!arr || !arr.length) && state.meSlug) {
                try {
                    const j2 = await api(`/users/${encodeURIComponent(state.meSlug)}/friends?offset=0&limit=500`);
                    arr = j2.items || j2.friends || [];
                } catch { }
            }
            const norm = (arr || []).map(u => {
                const nu = u.user || u;
                const id = nu.id ?? nu.user_id ?? nu.friend_id ?? null;
                const username = nu.username ?? nu.first_username ?? null;
                const first_username = nu.first_username ?? nu.username ?? null;
                const profile_photo = nu.profile_photo ?? null;
                const bio = nu.bio ?? nu.bio_html ?? '';
                return { id, username, first_username, profile_photo, bio };
            }).filter(x => x.id);
            return norm;
        }

        function friendDisplay(u) {
            const raw = u.display_name || u.name || u.first_username || u.username || 'User';
            return String(raw);
        }

        function refreshSelectedChips() {
            const chipBox = $('selected-chips'); chipBox.innerHTML = '';
            const ids = [...state.selectedIds];
            ids.forEach(uid => {
                const u = state.idToFriend.get(uid) || {};
                const label = friendDisplay(u);
                const el = document.createElement('div');
                el.className = 'chip';
                el.innerHTML = `<span>${esc(label)}</span><span class="x" title="Remove">✕</span>`;
                el.querySelector('.x').onclick = (e) => { e.stopPropagation(); state.selectedIds.delete(uid); renderFriends(state.friendsCache); refreshSelectedChips(); refreshGroupSubmitState(); };
                chipBox.append(el);
            });
        }

        function refreshGroupSubmitState() {
            const btn = $('btn-group-submit');
            const mode = state.pickerMode;
            if (mode === 'group-create') {
                btn.textContent = 'Create Group';
                btn.disabled = (state.selectedIds.size < 2);
            } else if (mode === 'group-edit') {
                btn.textContent = 'Save Changes';
                const changed = !eqSets(state.selectedIds, state.initialSelectedIds);
                btn.disabled = !changed;
            } else {
                btn.textContent = 'Close';
                btn.disabled = false;
            }
            $('group-cta').style.display = (mode === 'group-create' || mode === 'group-edit') ? '' : 'none';
        }

        function eqSets(a, b) { if (a.size !== b.size) return false; for (const v of a) if (!b.has(v)) return false; return true; }

        function renderFriends(list) {
            state.friendsCache = list || [];
            state.idToFriend.clear();
            list.forEach(u => state.idToFriend.set(u.id, u));

            userList.innerHTML = '';
            const q = $('user-q').value.trim().toLowerCase();
            let items = list.filter(u => {
                if (!q) return true;
                return (u.username || '').toLowerCase().includes(q) ||
                    (u.first_username || '').toLowerCase().includes(q) ||
                    (u.bio || '').toLowerCase().includes(q);
            });

            const mode = state.pickerMode;
            items.forEach(u => {
                const row = document.createElement('div'); row.className = 'person';
                const label = friendDisplay(u);
                const checked = state.selectedIds.has(u.id);
                const isDefaultAvatar = !u.profile_photo; // <-- add this line

                let right = '';
                if (mode === 'dm') {
                    right = `<div class="act"><button class="btn person-message">Message</button></div>`;
                } else if (mode === 'group-create' || mode === 'group-edit') {
                    right = `<div class="act">
                    <input type="checkbox" class="checkbox person-check" ${checked ? 'checked' : ''}/>
                </div>`;
                } else {
                    right = `<div class="act"></div>`;
                }

                row.innerHTML = `
                <img class="pfp ${isDefaultAvatar ? 'pixel' : ''}" src="${u.profile_photo || DEFAULT_PFP_DM}" alt="">
                <div>
                    <div class="name">${esc(label)}</div>
                    <div class="bio">${esc(u.bio || '')}</div>
                </div>
                ${right}
            `;

                if (mode === 'dm') {
                    row.onclick = (e) => { if (e.target.closest('.person-message')) return; startDmWith(u); };
                    row.querySelector('.person-message').onclick = async (e) => { e.stopPropagation(); await startDmWith(u); };
                } else if (mode === 'group-create' || mode === 'group-edit') {
                    const toggle = () => {
                        if (state.selectedIds.has(u.id)) state.selectedIds.delete(u.id);
                        else state.selectedIds.add(u.id);
                        renderFriends(state.friendsCache);
                        refreshSelectedChips();
                        refreshGroupSubmitState();
                    };
                    row.onclick = toggle;
                    const cb = row.querySelector('.person-check');
                    if (cb) cb.addEventListener('click', (e) => { e.stopPropagation(); toggle(); });
                } else {
                    row.onclick = () => { };
                }

                userList.append(row);
            });

            refreshSelectedChips();
        }

        function isGroupChat() { return !!(state.currentConvDetail?.is_group); }

        function usernameFor(userId) {
            const det = state.currentConvDetail || {};
            const m = (det.members || []).find(u => (u.id | 0) === (userId | 0));
            const u = m || {};
            return pickName(u) || 'user';
        }

        function borderColorKey(convId) { return `dp:msgColors:${convId}`; }
        function getBorderColorMap(convId) {
            try { return JSON.parse(localStorage.getItem(borderColorKey(convId)) || '{}'); } catch { return {}; }
        }
        function setBorderColorMap(convId, map) {
            try { localStorage.setItem(borderColorKey(convId), JSON.stringify(map)); } catch { }
        }
        function getBorderColor(convId, userId) {
            const m = getBorderColorMap(convId);
            return m && m[userId] || null;
        }
        function updateAllMessageBorders() {
            const cmap = getColorMap(state.convId);
            document.querySelectorAll('.msgs .msg:not(.sysmsg)').forEach(el => {
                const uid = +el.dataset.senderId || 0;
                const col = cmap[uid] || null;
                if (col) el.style.setProperty('--mbc', col);
                else el.style.removeProperty('--mbc');
            });
        }

        let myColorOverlay = null;
        function ensureMyColorOverlay() {
            if (myColorOverlay) return myColorOverlay;
            myColorOverlay = document.createElement('div');
            myColorOverlay.id = 'my-color-overlay';
            myColorOverlay.className = 'overlay';
            myColorOverlay.innerHTML = `
    <div class="sheet" style="width:min(460px,94vw)">
      <h3>My Message Color</h3>
      <div class="person" style="cursor:default">
        <img class="pfp" id="my-color-pfp" src="" alt="">
        <div style="display:flex;flex-direction:column;gap:6px">
          <div class="name" id="my-color-name">@me</div>
          <div class="bio">Change the border color of <b>your</b> messages in this group.</div>
        </div>
        <div class="act" style="display:flex;gap:8px;align-items:center">
          <input class="colorpick" id="my-color-input" type="color" value="#e6e6e6">
          <button class="btn" id="my-color-clear" type="button" title="Use default">Use default</button>
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button class="btn" id="my-color-cancel" type="button">Cancel</button>
        <button class="btn" id="my-color-save" type="button">Save</button>
      </div>
    </div>`;
            document.body.append(myColorOverlay);
            myColorOverlay.addEventListener('click', e => { if (e.target === myColorOverlay) myColorOverlay.style.display = 'none'; });
            return myColorOverlay;
        }

        async function openMyColorOverlay() {
            const det = state.currentConvDetail || {};
            if (!det.is_group) return;

            const ov = ensureMyColorOverlay();
            const nameEl = ov.querySelector('#my-color-name');
            const pfpEl = ov.querySelector('#my-color-pfp');
            const input = ov.querySelector('#my-color-input');
            const btnClr = ov.querySelector('#my-color-clear');
            const btnSav = ov.querySelector('#my-color-save');
            const btnCan = ov.querySelector('#my-color-cancel');

            // Fill in my display bits
            const me = (det.members || []).find(u => (u.id | 0) === (state.meId | 0)) || {};
            nameEl.textContent = pickName(me) || 'Me';
            const isDefaultAvatar = !me.profile_photo;
            pfpEl.classList.toggle('pixel', isDefaultAvatar);
            pfpEl.src = me.profile_photo || DEFAULT_PFP_DM;

            // Ensure we have the latest map
            await syncMsgColors(state.convId);
            const map = getColorMap(state.convId);
            const current = map[state.meId] || '#e6e6e6';
            input.value = /^#[0-9a-f]{6}$/i.test(current) ? current : '#e6e6e6';

            btnClr.onclick = () => { input.value = '#e6e6e6'; };

            btnSav.onclick = async () => {
                const val = input.value.toLowerCase();
                // treat default as "clear" (null)
                const toSet = (val === '#e6e6e6') ? null : val;
                try {
                    await setMyMsgColor(state.convId, toSet);
                    // reflect locally
                    const m = { ...getColorMap(state.convId) };
                    if (toSet) m[state.meId] = toSet; else delete m[state.meId];
                    setColorMap(state.convId, m);
                    updateAllMessageBorders();
                    myColorOverlay.style.display = 'none';
                } catch (e) {
                    alert(e.detail || e.message || e);
                }
            };
            btnCan.onclick = () => { myColorOverlay.style.display = 'none'; };

            myColorOverlay.style.display = 'flex';
        }

        async function openPicker(mode = 'dm', opts = {}) {
            state.pickerMode = mode;
            state.selectedIds = new Set(opts.preselectIds || []);
            state.initialSelectedIds = new Set(opts.preselectIds || []);
            $('overlay').style.display = 'flex';
            $('user-q').value = '';
            $('sheet-title').textContent =
                mode === 'dm' ? 'Start a conversation'
                    : mode === 'group-create' ? 'Create a Group'
                        : mode === 'group-edit' ? 'Edit Group Members'
                            : 'Group Members';

            $('group-cta').style.display = (mode === 'group-create' || mode === 'group-edit') ? '' : 'none';
            refreshGroupSubmitState();

            const friends = await fetchFriends();
            renderFriends(friends);
        }
        function closePicker() { $('overlay').style.display = 'none'; }

        let colorOverlay = null;
        function ensureColorOverlay() {
            if (colorOverlay) return colorOverlay;
            colorOverlay = document.createElement('div');
            colorOverlay.id = 'color-overlay';
            colorOverlay.className = 'overlay';
            colorOverlay.innerHTML = `
    <div class="sheet" style="width:min(640px,94vw)">
      <h3>Message border colors</h3>
      <div id="color-list" class="list"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button class="btn" id="color-reset" type="button">Reset all</button>
        <button class="btn" id="color-cancel" type="button">Cancel</button>
        <button class="btn" id="color-save" type="button">Save</button>
      </div>
    </div>`;
            document.body.append(colorOverlay);
            colorOverlay.addEventListener('click', e => { if (e.target === colorOverlay) colorOverlay.style.display = 'none'; });
            return colorOverlay;
        }

        function openBorderColorsOverlay() {
            const det = state.currentConvDetail || {};
            if (!det.is_group) return;
            const ov = ensureColorOverlay();
            const list = ov.querySelector('#color-list');
            const map = getBorderColorMap(state.convId);
            list.innerHTML = '';

            (det.members || []).forEach(u => {
                const username = pickName(u) || 'user';
                const value = map[u.id] || '#e6e6e6';
                const isDefault = !map[u.id];
                const row = document.createElement('div');
                row.className = 'person';
                const isDefaultAvatar = !u.profile_photo;
                row.innerHTML = `
      <img class="pfp ${isDefaultAvatar ? 'pixel' : ''}" src="${u.profile_photo || DEFAULT_PFP_DM}" alt="">
      <div>
        <div class="name">${esc(username)}</div>
        <div class="bio">Set a border color for ${esc(username)}’s messages</div>
      </div>
      <div class="act" style="display:flex;gap:8px;align-items:center">
        <input class="colorpick" type="color" value="${value}">
        <button class="btn clear" type="button" title="Use default">✕</button>
      </div>`;
                const colorInput = row.querySelector('.colorpick');
                const clearBtn = row.querySelector('.clear');
                clearBtn.onclick = e => { e.stopPropagation(); delete map[u.id]; colorInput.value = '#e6e6e6'; };
                colorInput.oninput = () => { map[u.id] = colorInput.value; };
                list.append(row);
            });

            ov.querySelector('#color-reset').onclick = () => { setBorderColorMap(state.convId, {}); updateAllMessageBorders(); ov.style.display = 'none'; };
            ov.querySelector('#color-cancel').onclick = () => { ov.style.display = 'none'; };
            ov.querySelector('#color-save').onclick = () => { setBorderColorMap(state.convId, map); updateAllMessageBorders(); ov.style.display = 'none'; };
            ov.style.display = 'flex';
        }

        async function maybeAutoRenameGroup() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            if (!det?.is_group) return;

            const meta = state.convMeta.get(state.convId) || {};
            // only auto-manage title if user hasn't custom-named it
            if (meta.auto_title === false) return;

            const desired = computeDefaultGroupTitle(det.members || []);
            const current = (det.title || meta.name || '').trim();
            const stripAts = s => s.replace(/@/g, '');
            const sameIgnoringAts = (a, b) => stripAts(a) === stripAts(b);

            const isAutoNow = (current === '' || sameIgnoringAts(current, computeDefaultGroupTitle(det.members || [])));
            if (isAutoNow && !sameIgnoringAts(current, desired)) {
                await api(`/dm/conversations/${state.convId}/title`, { method: 'PATCH', body: { title: desired } });
                setConvMeta(state.convId, { name: desired, auto_title: true });
            }
        }

        $('btn-newdm').onclick = () => openPicker('dm');
        $('btn-newgroup').onclick = () => openPicker('group-create');

        overlay.addEventListener('click', e => { if (e.target === overlay) closePicker(); });
        document.addEventListener('keydown', e => { if (e.key === 'Escape') { closePicker(); hideChatMenu(); hideRestyle(); } });

        $('user-q').addEventListener('input', async () => renderFriends(state.friendsCache));
        $('btn-cancel').onclick = () => closePicker();

        $('btn-group-submit').onclick = async () => {
            if (state.pickerMode === 'group-create') {
                if (state.selectedIds.size < 2) return;
                const ids = [...state.selectedIds]; // others (in pick order)
                const others = ids.map(id => state.idToFriend.get(id)).filter(Boolean);
                const meLabel = state.meSlug || 'Me'; // username is fine; no @
                const names = [meLabel, ...others.map(u => friendDisplay(u) || 'User')];
                const title = joinNames(names);
                try {
                    const rc = randomGroupColor();
                    const res = await api('/dm/conversations', { method: 'POST', body: { user_ids: ids, title, color: rc.val } });
                    // mark this conversation as using the default/auto title scheme
                    setConvMeta(res.id, { name: title, is_group: true, auto_title: true });

                    // Assign distinct colors to everyone (me + others)
                    const allIds = [state.meId, ...ids];
                    const initial = chooseUniqueColorsForUsers(allIds, {}); // fresh set
                    try { await patchMsgColors(res.id, initial); } catch { }
                    setColorMap(res.id, { ...initial });

                    closePicker();
                    await loadConversations({ blockingMeta: true });
                    if (res?.id) await openConversation(res.id);
                } catch (e) { alert(e.detail || e.message || e); }
            } else if (state.pickerMode === 'group-edit') {
                const detail = state.currentConvDetail || {};
                const before = new Set(state.initialSelectedIds);
                const after = new Set(state.selectedIds);
                const add = [...after].filter(x => !before.has(x));
                const remove = [...before].filter(x => !after.has(x));
                if (add.length === 0 && remove.length === 0) return;
                try {
                    const resp = await api(`/dm/conversations/${state.convId}/members`, {
                        method: 'PATCH',
                        body: { add_user_ids: add, remove_user_ids: remove }
                    });

                    // keep this client-side nicety (server also assigns colors)
                    if (add.length) {
                        let existing = {};
                        try { existing = await fetchMsgColors(state.convId); } catch { }
                        const newOnes = chooseUniqueColorsForUsers(add, existing);
                        if (Object.keys(newOnes).length) {
                            try { await patchMsgColors(state.convId, newOnes); } catch { }
                        }
                    }

                    closePicker();

                    if (resp?.deleted) {
                        state.convId = null;
                        state.currentConvDetail = null;
                        $('chat-title').textContent = 'Pick a conversation';
                        $('chat-pfp').src = DEFAULT_PFP_DM;
                        $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                        state.audioDurEls.clear();
                        await loadConversations({ blockingMeta: true });
                        return;
                    }

                    await fetchConvMeta(state.convId);
                    await maybeAutoRenameGroup();
                    await syncMsgColors(state.convId);
                    await fetchAfter(state.lastMsgId);
                    await loadConversations({ blockingMeta: true });
                } catch (e) { alert(e.detail || e.message || e); }
            } else {
                closePicker();
            }
        };

        async function startDmWith(u) {
            try {
                const og = u.first_username || u.username;
                const res = await api(`/dm/with/${encodeURIComponent(og)}`, { method: 'POST' });
                closePicker(); await loadConversations({ blockingMeta: true });
                const cid = res?.conversation_id || res?.id;
                if (cid) {
                    const meta = { name: friendDisplay(u), photo: u.profile_photo || DEFAULT_PFP_DM, is_group: false };
                    setConvMeta(cid, meta);
                    state.userCache.set(og, { username: og, photo: u.profile_photo || DEFAULT_PFP_DM, display_name: null, raw: u });
                    scheduleSaveMeta();
                    openConversation(cid);
                } else if (state.allConvs[0]) {
                    openConversation(state.allConvs[0].id);
                }
            } catch (e) { alert(e.message || e); }
        }

        /* ---------------- 3-dots chat menu ---------------- */
        const chatMenu = $('chat-menu');
        const chatMenuBtn = $('chat-menu-btn');

        function hideChatMenu() { chatMenu.style.display = 'none'; }
        function toggleChatMenu() {
            if (chatMenu.style.display === 'none' || !chatMenu.style.display) { renderChatMenu(); chatMenu.style.display = 'block'; }
            else chatMenu.style.display = 'none';
        }
        chatMenuBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleChatMenu(); });
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.menu') && e.target !== chatMenuBtn) hideChatMenu();
        });

        function renderChatMenu() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            const isGroup = !!det.is_group;
            const isOwner = !!det.is_owner;

            chatMenuBtn.style.display = '';

            const items = [];
            if (isGroup) {
                if (isOwner) {
                    items.push({ id: 'rename', label: 'Rename group' });
                    items.push({ id: 'manage', label: 'Manage members' });
                } else {
                    items.push({ id: 'view-members', label: 'View members' });
                }
                items.push({ id: 'restyle', label: 'Restyle Group' });
                items.push({ id: 'my-color', label: 'My Message Color' });
                items.push({ id: 'leave', label: 'Leave group' });
                items.push({ id: 'block-group', label: 'Block this group' });
            } else {
                items.push({ id: 'delete-dm', label: 'Delete chat (for me)' });
                items.push({ id: 'block-user', label: 'Block user' });
            }

            chatMenu.innerHTML = items.map(i => `<div class="item" data-id="${i.id}">${esc(i.label)}</div>`).join('');

            chatMenu.querySelectorAll('.item').forEach(el => {
                el.onclick = async () => {
                    const id = el.dataset.id;
                    hideChatMenu();
                    if (id === 'rename') {
                        const current = state.currentConvDetail?.title || state.convMeta.get(state.convId)?.name || '';
                        const name = prompt('New group name:', current) || '';
                        const trimmed = name.trim();
                        if (!trimmed) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/title`, { method: 'PATCH', body: { title: trimmed } });
                            setConvMeta(state.convId, { auto_title: false });
                            await fetchConvMeta(state.convId);
                            await fetchAfter(state.lastMsgId);
                            await loadConversations({ blockingMeta: true });
                            await afterPaint();
                            renderChatMenu();
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'manage') {
                        await openManageMembers();
                    } else if (id === 'view-members') {
                        state.pickerMode = 'view-members';
                        $('sheet-title').textContent = 'Group Members';
                        $('group-cta').style.display = 'none';
                        $('overlay').style.display = 'flex';
                        $('user-q').value = '';
                        const members = (state.currentConvDetail?.members || []).map(u => ({
                            id: u.id, username: u.username, first_username: u.first_username, profile_photo: u.profile_photo, bio: ''
                        }));
                        renderFriends(members);
                    } else if (id === 'restyle') {
                        openRestyleOverlay();
                    } else if (id === 'leave') {
                        if (!confirm('Leave this group?')) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/leave`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'block-group') {
                        if (!confirm('Block this group? You will also leave it and won’t be added again.')) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/block`, { method: 'POST' });
                            await api(`/dm/conversations/${state.convId}/leave`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'delete-dm') {
                        if (!confirm('Delete this chat for you? The other person will still see it.')) return;
                        try {
                            // mark cutoff BEFORE we delete (so we hide everything up to current last)
                            setHideBeforeId(state.convId, state.lastMsgId || Number.MAX_SAFE_INTEGER);

                            // Personal delete on the backend (no system message)
                            await api(`/dm/conversations/${state.convId}/delete_for_me`, { method: 'POST' });

                            // Reset UI
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'block-user') {
                        try {
                            const other = (state.currentConvDetail?.members || []).find(u => (u.id | 0) !== (state.meId | 0));
                            if (!other) { alert('Could not find user to block.'); return; }
                            await api(`/blocks/users`, { method: 'POST', body: { user_id: other.id } });
                            alert('User blocked.');
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'my-color') {
                        openMyColorOverlay();
                    }
                };
            });
        }

        /* ---------------- Manage members (owner only) ---------------- */
        async function openManageMembers() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            if (!det?.is_group || !det?.members?.length) return;
            state.pickerMode = 'view-members';
            $('sheet-title').textContent = 'Manage Group';
            $('group-cta').style.display = 'none';
            $('overlay').style.display = 'flex';
            $('user-q').value = '';
            const members = (det.members || []).map(u => ({
                id: u.id, username: u.username, first_username: u.first_username, profile_photo: u.profile_photo, bio: ''
            }));
            renderFriends(members);
            Array.from(document.querySelectorAll('#user-list .person')).forEach((row, idx) => {
                const m = members[idx];
                const act = document.createElement('div');
                act.className = 'act';
                act.style.display = 'flex';
                act.style.gap = '8px';
                const makeOwner = document.createElement('button');
                makeOwner.className = 'btn';
                makeOwner.textContent = 'Make owner';
                makeOwner.onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        await api(`/dm/conversations/${state.convId}/owner`, { method: 'PATCH', body: { owner_id: m.id } });
                        await fetchConvMeta(state.convId);
                        await loadConversations({ blockingMeta: true });
                        alert('Owner updated.');
                    } catch (e) { alert(e.detail || e.message || e); }
                };
                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn';
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!confirm('Remove this person from the group?')) return;
                    try {
                        await api(`/dm/conversations/${state.convId}/members`, { method: 'PATCH', body: { add_user_ids: [], remove_user_ids: [m.id] } });
                        await fetchConvMeta(state.convId);
                        await loadConversations({ blockingMeta: true });
                        row.remove();
                    } catch (e) { alert(e.detail || e.message || e); }
                };
                act.append(makeOwner, removeBtn);
                row.append(act);
            });
        }

        /* ---------------- Restyle Group (color + icon) ---------------- */
        let restyleEl = null;

        function ensureRestyle() {
            if (restyleEl) return restyleEl;
            restyleEl = document.createElement('div');
            restyleEl.id = 'restyle-overlay';
            restyleEl.className = 'overlay';
            restyleEl.innerHTML = `
    <div class="sheet" style="width:min(720px,94vw)">
      <h3>Restyle Group</h3>

      <div class="pf-preview">
        <div class="thumb"><img id="restyle-preview" alt="preview"></div>
        <div class="muted">PNG will be generated at up to <b>512px</b> (longest side). Final file must be ≤ <b>1&nbsp;MB</b>.</div>
      </div>

      <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;margin:8px 0 10px">
        <div style="font-weight:700">Color</div>
        <div id="restyle-color-choices" style="display:flex;flex-wrap:wrap;gap:8px"></div>
      </div>

      <div class="file-row">
        <label class="pill">
          <span>Choose image</span>
          <input id="restyle-file" type="file" accept="image/png,image/jpeg,image/webp,image/gif,image/svg+xml" style="display:none">
        </label>
        <span class="muted">or drag & drop onto the canvas</span>
        <div id="restyle-filename" class="muted" style="font-size:13px"></div>
        <button class="btn" id="restyle-clear" type="button">Use default</button>
      </div>

      <div class="editor" style="margin-top:10px">
        <div class="stage" id="restyle-drop">
          <canvas id="restyle-canvas" width="320" height="320"></canvas>
        </div>

        <div class="controls">
          <div class="ctl">
            <div class="muted" style="margin-bottom:6px">Zoom</div>
            <input id="restyle-zoom" type="range" min="0" max="1" step="0.01" value="0.5">
          </div>
          <div class="ctl">
            <div class="muted" style="margin-bottom:6px">Rotate</div>
            <input id="restyle-rot" type="range" min="-180" max="180" step="1" value="0">
          </div>
        </div>

        <div class="actions" style="display:flex;gap:10px;margin-top:4px;justify-content:flex-end">
          <button class="btn secondary" id="restyle-cancel" type="button">Cancel</button>
          <button class="btn" id="restyle-save" disabled>Save changes</button>
        </div>
        <div class="note">Tips: drag the image to reposition. Use zoom/rotate. Output is PNG with transparency preserved.</div>
      </div>
    </div>`;
            document.body.append(restyleEl);
            restyleEl.addEventListener('click', (e) => { if (e.target === restyleEl) hideRestyle(); });
            return restyleEl;
        }

        function hideRestyle() { if (restyleEl) restyleEl.style.display = 'none'; }
        function openRestyleOverlay() {
            const meta = state.convMeta.get(state.convId) || {};
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            if (!det.is_group) return;

            // ensure white knobs override (once)
            if (!document.getElementById('restyle-white-range')) {
                const st = document.createElement('style');
                st.id = 'restyle-white-range';
                st.textContent = `
#restyle-overlay input[type="range"]::-webkit-slider-thumb { background:#fff !important; }
#restyle-overlay input[type="range"]::-moz-range-thumb { background:#fff !important; }
#restyle-overlay input[type="range"]:active::-webkit-slider-thumb { background:#fff !important; }
#restyle-overlay input[type="range"]:active::-moz-range-thumb { background:#fff !important; }`;
                document.head.appendChild(st);
            }

            const el = ensureRestyle();
            el.style.display = 'flex';

            const preview = el.querySelector('#restyle-preview');
            const fileIn = el.querySelector('#restyle-file');
            const fileName = el.querySelector('#restyle-filename');
            const clearBtn = el.querySelector('#restyle-clear');
            const saveBtn = el.querySelector('#restyle-save');
            const cancelBtn = el.querySelector('#restyle-cancel');

            const colorBox = el.querySelector('#restyle-color-choices');
            colorBox.innerHTML = '';

            const canvas = el.querySelector('#restyle-canvas');
            const ctx = canvas.getContext('2d');
            const drop = el.querySelector('#restyle-drop');
            const zoomEl = el.querySelector('#restyle-zoom');
            const rotEl = el.querySelector('#restyle-rot');

            const hadCustomIcon = !!meta.photo && meta.photo !== DEFAULT_PFP_GROUP;
            let clearedToDefault = false;
            let imgBitmap = null;
            let imgW = 0, imgH = 0;
            let pos = { x: 0, y: 0 };
            let dragging = false, last = { x: 0, y: 0 };
            let zoom = parseFloat(zoomEl.value);
            let rot = parseFloat(rotEl.value) * Math.PI / 180;
            let selectedColor = meta.color || '#ffffff';
            let selectedColorKey = (GROUP_COLORS.find(c => c.val === selectedColor)?.key) || null;

            let dirty = false;
            function markDirty() { dirty = true; saveBtn.disabled = false; }
            saveBtn.disabled = true;

            // color chips
            GROUP_COLORS.forEach(c => {
                const b = document.createElement('button');
                b.type = 'button';
                b.className = 'btn';
                b.style.cssText = `border-color:${c.val};background:${c.val};color:#000`;
                b.textContent = c.key;
                if (c.val === selectedColor) b.style.outline = '2px solid #fff';
                b.onclick = () => {
                    selectedColor = c.val;
                    selectedColorKey = c.key;
                    colorBox.querySelectorAll('.btn').forEach(x => x.style.outline = '');
                    b.style.outline = '2px solid #fff';
                    paintPreview();
                    markDirty();
                };
                colorBox.append(b);
            });

            function setImgSafe(img, src, fallback) {
                img.onerror = () => { img.src = fallback; };
                img.src = src || fallback;
            }

            function paintPreview() {
                const showDefault = (!hadCustomIcon || clearedToDefault) && !imgBitmap;
                preview.classList.toggle('is-default', showDefault);

                const activeSrc = showDefault ? DEFAULT_PFP_GROUP : (meta.photo || DEFAULT_PFP_GROUP);
                setImgSafe(preview, activeSrc, DEFAULT_PFP_GROUP);

                const thumb = el.querySelector('.pf-preview .thumb');
                // border should reflect the chosen color (was stuck white)
                thumb.style.borderColor = selectedColor;
                // background stays tinted only when using the default icon
                thumb.style.background = showDefault ? selectedColor : '#000';
            }

            paintPreview();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // stronger zoom range
            function scaleForZoom() {
                const MIN = 0.25, MAX = 6; // was 0.5..3; now 0.25..6
                return MIN + zoom * (MAX - MIN);
            }

            function redraw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!imgBitmap) return;
                ctx.save();
                ctx.translate(canvas.width / 2 + pos.x, canvas.height / 2 + pos.y);
                ctx.rotate(rot);
                const s = scaleForZoom();
                const dw = imgW * s, dh = imgH * s;
                ctx.drawImage(imgBitmap, -dw / 2, -dh / 2, dw, dh);
                ctx.restore();
            }

            function loadBitmapFromFile(file) {
                return new Promise((resolve, reject) => {
                    const r = new FileReader();
                    r.onload = async () => {
                        try { resolve(await createImageBitmap(new Blob([r.result]))); }
                        catch (e) { reject(e); }
                    };
                    r.onerror = () => reject(r.error);
                    r.readAsArrayBuffer(file);
                });
            }

            async function setImageFile(file) {
                if (!file) return;
                try {
                    imgBitmap = await loadBitmapFromFile(file);
                    imgW = imgBitmap.width; imgH = imgBitmap.height;
                    pos = { x: 0, y: 0 };
                    zoom = 0.5; zoomEl.value = '0.5';
                    rot = 0; rotEl.value = '0';
                    fileName.textContent = file.name;
                    clearedToDefault = false;
                    redraw();
                    const url = URL.createObjectURL(file);
                    preview.src = url;
                    const thumb = el.querySelector('.pf-preview .thumb');
                    thumb.style.background = '#000';
                    markDirty();
                } catch (e) {
                    alert('Could not read image: ' + (e.message || e));
                }
            }

            // dnd
            drop.addEventListener('dragover', e => { e.preventDefault(); });
            drop.addEventListener('drop', e => {
                e.preventDefault();
                const f = e.dataTransfer?.files?.[0];
                if (f) setImageFile(f);
            });

            // choose
            fileIn.onchange = () => {
                const f = fileIn.files?.[0];
                if (f) setImageFile(f);
            };

            // clear to default
            clearBtn.onclick = () => {
                imgBitmap = null; imgW = imgH = 0;
                pos = { x: 0, y: 0 };
                zoom = 0.5; zoomEl.value = '0.5';
                rot = 0; rotEl.value = '0';
                fileIn.value = ''; fileName.textContent = '';
                clearedToDefault = true;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                paintPreview();
                markDirty();
            };

            // pan
            canvas.addEventListener('pointerdown', e => {
                dragging = true; last = { x: e.clientX, y: e.clientY };
                canvas.setPointerCapture(e.pointerId);
            });
            canvas.addEventListener('pointermove', e => {
                if (!dragging) return;
                const dx = e.clientX - last.x, dy = e.clientY - last.y;
                last = { x: e.clientX, y: e.clientY };
                pos.x += dx; pos.y += dy;
                redraw();
                markDirty();
            });
            const endDrag = e => { dragging = false; try { canvas.releasePointerCapture(e.pointerId); } catch { } };
            canvas.addEventListener('pointerup', endDrag);
            canvas.addEventListener('pointercancel', endDrag);
            canvas.addEventListener('pointerleave', endDrag);

            // sliders
            zoomEl.oninput = () => { zoom = parseFloat(zoomEl.value); redraw(); markDirty(); };
            rotEl.oninput = () => { rot = parseFloat(rotEl.value) * Math.PI / 180; redraw(); markDirty(); };

            cancelBtn.onclick = () => hideRestyle();

            async function exportPNGMax512() {
                const BYTES_MAX = 1024 * 1024;
                let size = 512;

                async function renderTo(px) {
                    const out = ('OffscreenCanvas' in window) ? new OffscreenCanvas(px, px)
                        : Object.assign(document.createElement('canvas'), { width: px, height: px });
                    const octx = out.getContext('2d');
                    octx.clearRect(0, 0, px, px);

                    if (imgBitmap) {
                        const s = scaleForZoom();
                        octx.save();
                        octx.translate(px / 2 + (pos.x * (px / canvas.width)), px / 2 + (pos.y * (px / canvas.height)));
                        octx.rotate(rot);
                        const dw = imgW * s * (px / canvas.width);
                        const dh = imgH * s * (px / canvas.height);
                        octx.drawImage(imgBitmap, -dw / 2, -dh / 2, dw, dh);
                        octx.restore();
                    }

                    let blob;
                    if (out.convertToBlob) blob = await out.convertToBlob({ type: 'image/png' });
                    else blob = await new Promise(res => out.toBlob(res, 'image/png'));
                    return new Uint8Array(await blob.arrayBuffer());
                }

                let png = imgBitmap ? await renderTo(size) : null;
                while (png && png.length > BYTES_MAX && size > 192) {
                    size = Math.floor(size * 0.85);
                    png = await renderTo(size);
                }
                if (png && png.length > BYTES_MAX) throw new Error('Icon too large even after resizing');
                return { png, size };
            }

            saveBtn.onclick = async () => {
                try {
                    const fd = new FormData();
                    const beforeColor = meta.color || '#ffffff';
                    if (selectedColor && selectedColor !== beforeColor) fd.append('color', selectedColor);

                    if (imgBitmap) {
                        const { png } = await exportPNGMax512();
                        if (png) fd.append('icon', new Blob([png], { type: 'image/png' }), 'group-icon.png');
                    } else if (clearedToDefault) {
                        fd.append('use_default_icon', '1');
                    }

                    await fetch(`${API}/dm/conversations/${state.convId}/appearance`, { method: 'PATCH', credentials: 'include', body: fd });

                    // Local UI polish; server will broadcast conv_meta + system messages
                    if (selectedColor && selectedColor !== beforeColor) {
                        setConvMeta(state.convId, { color: selectedColor });
                    }

                    await fetchConvMeta(state.convId);
                    await loadConversations({ blockingMeta: true });
                    hideRestyle();
                } catch (e) {
                    alert(e.detail || e.message || e);
                }
            };
        }

        /* ---------------- wire UI ---------------- */
        $('btn-attach').onclick = () => $('file').click();
        $('file').onchange = async e => { await handleFileInput(e.target.files); e.target.value = ''; };
        $('btn-send').onclick = sendMessage;
        $('text').addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

        const voice = $('btn-voice');
        const startRec = e => { e.preventDefault(); voice.textContent = 'Recording… release to stop'; startRecording(); };
        const stopRec = e => { e.preventDefault(); voice.textContent = 'Hold to record'; stopRecording(false); };
        voice.addEventListener('pointerdown', startRec);
        voice.addEventListener('pointerup', stopRec);
        voice.addEventListener('pointercancel', stopRec);
        voice.addEventListener('mouseleave', () => { if (state.recording.active) stopRec(new Event('pointerup')); });

        async function sendMessage() {
            if (!state.convId || state.uploading) return;
            let text = $('text').value;
            if (!text && state.pendingFiles.length === 0) return;
            if (text.length > 10000) { alert('Message is over 10,000 characters. Please shorten it.'); return; }
            text = text.trim();

            // log what we "think" before upload
            const auds = state.pendingFiles.filter(f => (f.type || '').startsWith('audio/'))
                .map(f => ({ name: f.name, bytes: f.size, mime: f.type, client_est_ms: f.durationMs || null }));
            if (auds.length) console.debug('[aud][send] about to upload audio attachments:', auds);

            const fd = new FormData();
            fd.append('text', text);
            state.pendingFiles.forEach((f, i) => {
                const blob = new Blob([f.buf], { type: f.type || 'application/octet-stream' });
                const name = f.name || `file-${i}`;
                fd.append('files', blob, name);
                if (f.encoding) fd.append(`encoding_${name}`, f.encoding);
            });

            state.uploading = true;
            try {
                console.debug('[aud][send] POST /messages with', { files: state.pendingFiles.length, textLen: text.length });
                const r = await fetch(`${API}/dm/conversations/${state.convId}/messages`, { method: 'POST', credentials: 'include', body: fd });
                const t = await r.text();
                if (!r.ok) throw new Error(t || r.statusText);
                let j = {};
                try { j = JSON.parse(t); } catch { }
                console.debug('[aud][send] server acknowledged message:', j);
                if (j && j.id) state.lastMsgId = Math.max(state.lastMsgId, j.id | 0);
                $('text').value = ''; state.pendingFiles = []; refreshChips();
                await fetchAfter(state.lastMsgId);
                loadConversations().catch(() => { });
                if (nearBottom()) { await afterPaint(); scrollToBottom(); }
            } catch (e) {
                console.debug('[aud][send] failed:', e);
                alert(e.message || e);
            } finally {
                state.uploading = false;
            }
        }

        /* ---------------- boot ---------------- */
        (async () => {
            await getMe();
            loadMetaCache();

            const urlMatch = location.pathname.match(/\/user\/([^\/]+)\/messages/i);
            const urlSlug = urlMatch ? decodeURIComponent(urlMatch[1]) : '';
            if (state.meSlug && urlSlug && urlSlug.toLowerCase() !== state.meSlug.toLowerCase()) {
                history.replaceState(null, '', `/user/${encodeURIComponent(state.meSlug)}/messages`);
            }

            await loadConversations({ blockingMeta: true });
            openGlobalStream();
            const last = loadLastDM();
            if (last && (last.meId | 0) === (state.meId | 0)) {
                const exists = state.allConvs.find(c => (c.id | 0) === (last.convId | 0));
                if (exists) { await openConversation(exists.id); return; }
            }
        })();

        /* ---------------- recording impl ---------------- */
        function formatMs(ms) {
            if (!Number.isFinite(ms) || ms <= 0) return '0:00';
            const s = Math.round(ms / 1000);
            const m = Math.floor(s / 60);
            const ss = String(s % 60).padStart(2, '0');
            return `${m}:${ss}`;
        }

        function setPlayerTotal(attId, ms) {
            const p = state.audioPlayers.get(attId);
            if (!p) return;
            p.totalMs = ms | 0;
            if (p.totEl) p.totEl.textContent = msToClock(p.totalMs);
            const chip = state.audioDurEls.get(attId)?.chip;
            if (chip) chip.textContent = msToClock(p.totalMs);
        }

        async function fetchAudioMeta(attId) {
            try {
                console.debug('[aud][meta] GET /dm/attachments/%s/meta …', attId);
                const j = await api(`/dm/attachments/${attId}/meta`);
                const ms = j?.duration_ms;
                console.debug('[aud][meta] result:', { attId, ms });
                if (Number.isFinite(ms) && ms > 0) setPlayerTotal(attId, ms);
            } catch (err) {
                console.debug('[aud][meta] failed:', err);
            }
        }

        function unregisterPlayersIn(root) {
            root.querySelectorAll('.audp').forEach(el => {
                const id = +el.dataset.attId || 0;
                if (id) {
                    console.debug('[aud][ui] unregister player:', id);
                    state.audioPlayers.delete(id);
                }
            });
        }

        function msToClock(ms) {
            ms = Math.max(0, ms | 0);
            const s = Math.round(ms / 1000);
            const m = (s / 60) | 0;
            const r = s % 60;
            return m + ':' + String(r).padStart(2, '0');
        }

        async function initAudioPlayer(attId, url, root) {
            console.debug('[aud][ui] initAudioPlayer:', { attId, url });
            const audio = root.querySelector('.aud-src');
            const btn = root.querySelector('.audp-btn');
            const track = root.querySelector('.audp-track');
            const fill = root.querySelector('.audp-fill');
            const curEl = root.querySelector('.cur');
            const totEl = root.querySelector('.tot');

            state.audioPlayers.set(attId, { root, audio, btn, track, fill, curEl, totEl, totalMs: 0, dragging: false });

            // Duration header + blob URL
            prepareFiniteAudio(attId, audio).catch(err => console.debug('[aud][ui] prepareFiniteAudio error:', err));

            // Backfill via /meta
            (async () => {
                try {
                    console.debug('[aud][ui] asking server for meta', { attId });
                    const j = await api(`/dm/attachments/${attId}/meta`);
                    const ms = j?.duration_ms;
                    console.debug('[aud][ui] server meta response:', { attId, ms });
                    if (Number.isFinite(ms) && ms > 0) setPlayerTotal(attId, ms | 0);
                } catch (err) {
                    console.debug('[aud][ui] meta fetch failed:', err);
                }
            })();

            // UI wiring
            btn.addEventListener('click', () => {
                if (audio.paused) { audio.play().then(() => { }).catch(e => console.debug('[aud][ui] play error:', e)); btn.textContent = '⏸'; }
                else { audio.pause(); btn.textContent = '▶'; }
            });

            audio.addEventListener('timeupdate', () => {
                const p = state.audioPlayers.get(attId);
                if (!p) return;
                const dur = p.totalMs ? p.totalMs / 1000 : (Number.isFinite(audio.duration) ? audio.duration : 0);
                const t = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;
                if (!p.dragging && dur > 0) fill.style.width = `${Math.min(100, (t / dur) * 100)}%`;
                if (curEl) curEl.textContent = msToClock(t * 1000);
                if (!p.totalMs && Number.isFinite(dur) && dur > 0) setPlayerTotal(attId, Math.round(dur * 1000));
            });

            const seek = (px) => {
                const rect = track.getBoundingClientRect();
                const ratio = Math.min(1, Math.max(0, (px - rect.left) / rect.width));
                const dur = state.audioPlayers.get(attId)?.totalMs || (Number.isFinite(audio.duration) ? Math.round(audio.duration * 1000) : 0);
                if (dur > 0) {
                    audio.currentTime = (ratio * dur) / 1000;
                    fill.style.width = `${ratio * 100}%`;
                }
            };
            track.addEventListener('mousedown', (e) => { const p = state.audioPlayers.get(attId); if (p) p.dragging = true; seek(e.clientX); });
            window.addEventListener('mousemove', (e) => { const p = state.audioPlayers.get(attId); if (p?.dragging) seek(e.clientX); });
            window.addEventListener('mouseup', () => { const p = state.audioPlayers.get(attId); if (p) p.dragging = false; });

            audio.addEventListener('ended', () => { btn.textContent = '▶'; fill.style.width = '0%'; });
        }

        function updateAudioDuration(attId, ms) {
            const ui = state.audioDurEls.get(attId);
            if (!ui) return;
            ui.chip.textContent = formatMs(ms);
            if (ui.audio) {
                ui.audio.dataset.serverMs = String(ms | 0); // lets us skip the heavy duration hack
            }
        }

        function wireAudio(audioEl, attId) {
            if (!attId || state.audioDurEls.has(attId)) return;

            // add overlay chip (… until meta arrives)
            const chip = document.createElement('div');
            chip.className = 'aud-dur';
            chip.textContent = '…';

            // ensure we have a container for absolute-positioned chip
            if (!audioEl.parentElement.classList.contains('att-audio')) {
                const wrap = document.createElement('div');
                wrap.className = 'att-audio';
                audioEl.replaceWith(wrap);
                wrap.append(audioEl, chip);
            } else {
                audioEl.parentElement.appendChild(chip);
            }

            state.audioDurEls.set(attId, { audio: audioEl, chip });

            // fetch server-side duration (fast path—DB-backed or quick probe)
            fetchAudioMeta(attId);

            // fallback: if the browser computes duration later and we still have no server val
            audioEl.addEventListener('loadedmetadata', () => {
                const server = +(audioEl.dataset.serverMs || '0');
                if (!server && Number.isFinite(audioEl.duration) && audioEl.duration > 0) {
                    chip.textContent = formatMs(audioEl.duration * 1000);
                }
            }, { once: true });
        }

        function unregisterAudioIn(root) {
            if (!root) return;
            root.querySelectorAll('audio[data-att-id]').forEach(a => {
                const id = +a.dataset.attId || 0;
                if (id) state.audioDurEls.delete(id);
            });
        }
        function canonicalAudioMime(mt) {
            return (mt || '').split(';')[0] || 'audio/webm';
        }
        function pickAudioMimeType() {
            const cands = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/mp4'];
            if (!('MediaRecorder' in window)) return '';
            for (const t of cands) {
                try { if (!MediaRecorder.isTypeSupported || MediaRecorder.isTypeSupported(t)) return t; } catch { }
            }
            return '';
        }
        function extForMime(mt) {
            if ((mt || '').includes('ogg')) return 'ogg';
            if ((mt || '').includes('mp4')) return 'm4a';
            return 'webm';
        }
        async function probeAudioBlobMs(blob) {
            return new Promise((resolve) => {
                try {
                    const a = document.createElement('audio');
                    a.preload = 'metadata';
                    const url = URL.createObjectURL(blob);
                    a.src = url;
                    const finish = (ms) => { try { URL.revokeObjectURL(url); } catch { } resolve(ms | 0); };
                    a.onloadedmetadata = () => {
                        const ms = Number.isFinite(a.duration) ? Math.round(a.duration * 1000) : 0;
                        console.debug('[rec] client probe loadedmetadata duration_ms=', ms);
                        finish(ms);
                    };
                    a.onerror = () => { console.debug('[rec] client probe failed to decode for duration'); finish(0); };
                } catch {
                    resolve(0);
                }
            });
        }
        async function startRecording() {
            if (state.recording.active) return;
            try {
                console.debug('[rec] requesting microphone…');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                const mime = pickAudioMimeType();
                const opts = mime ? { mimeType: mime, audioBitsPerSecond: 64000 } : {};
                console.debug('[rec] MediaRecorder opts:', opts);

                const rec = new MediaRecorder(stream, opts);
                state.recording = { active: true, chunks: [], size: 0, rec, warnShown: false, mime };

                rec.onstart = () => console.debug('[rec] onstart');
                rec.onerror = (e) => console.error('[rec] error', e);

                rec.ondataavailable = (e) => {
                    const sz = (e?.data?.size) || 0;
                    if (!sz) return;
                    state.recording.chunks.push(e.data);
                    state.recording.size += sz;
                    console.debug('[rec] chunk', { chunkBytes: sz, totalBytes: state.recording.size });

                    if (!state.recording.warnShown && state.recording.size > 850 * 1024) {
                        recWarn.style.display = '';
                        recWarn.textContent = 'Approaching 1MB limit…';
                        state.recording.warnShown = true;
                    }
                    if (state.recording.size > 990 * 1024) {
                        console.debug('[rec] forcing stop to keep under 1MB');
                        stopRecording(true);
                    }
                };

                rec.onstop = async () => {
                    console.debug('[rec] onstop, totalBytes=', state.recording.size);
                    try { recWarn.style.display = 'none'; } catch { }

                    try {
                        const mt = canonicalAudioMime(state.recording.mime || 'audio/webm');
                        let blob;
                        try {
                            blob = new Blob(state.recording.chunks, { type: mt });
                        } catch (e) {
                            console.error('[rec] Blob() failed', e);
                            alert('Could not finalize recording.');
                            return;
                        }
                        if (!blob.size) {
                            console.warn('[rec] empty blob; nothing to attach');
                            return;
                        }

                        // client-side best-effort duration probe
                        const estMs = await probeAudioBlobMs(blob);

                        const ab = await blob.arrayBuffer();
                        const buf = new Uint8Array(ab);
                        if (buf.length > MAX) {
                            alert('Voice message too large');
                            return;
                        }

                        const ext = extForMime(mt);
                        const name = `voice.${ext}`;
                        const ftype = mt;
                        console.debug('[rec] attached file (client estimate):', { name, bytes: buf.length, mime: ftype, client_est_ms: estMs });
                        addPendingFile({ name, type: ftype, buf, size: buf.length, encoding: null, durationMs: estMs });
                    } catch (e) {
                        console.error('[rec] finalize failed', e);
                        alert(e.message || e);
                    } finally {
                        try { stream.getTracks().forEach(t => t.stop()); } catch { }
                        state.recording = { active: false, chunks: [], size: 0, rec: null, warnShown: false, mime: state.recording.mime };
                        try { $('btn-voice').textContent = 'Hold to record'; } catch { }
                    }
                };

                rec.start(200);
                console.debug('[rec] started with timeslice 200ms');
            } catch (err) {
                console.error('[rec] start failed', err);
                alert('Could not start recording: ' + (err.message || err));
            }
        }
        function stopRecording(force = false) {
            const r = state.recording.rec;
            console.debug('[rec] stopRecording called', { force, hasRecorder: !!r });
            if (r && r.state !== 'inactive') { try { r.stop(); } catch (e) { console.error('[rec] stop error', e); } }
            state.recording.active = false;
            if (force) recWarn.textContent = 'Stopped to keep under 1MB.';
        }
    })();
</script>
