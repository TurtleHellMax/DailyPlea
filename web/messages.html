<!doctype html>
<meta charset="utf-8">
<title>Messages</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/web/site.css">

<style>
    :root {
        color-scheme: dark;
        --bg: #0a0b0d;
        --panel: #0e1116;
        --panel-2: #12161c;
        --border: #e6e6e6;
        --soft: rgba(255,255,255,.12);
        --text: #fff;
        --muted: #b8b8b8;
        --bw: 2px;
    }

    /* Font */
    @font-face {
        font-family: 'Voice1';
        src: url('/fonts/Voice1.woff2') format('woff2'), url('/fonts/Voice1.woff') format('woff'), url('/fonts/Voice1.ttf') format('truetype');
        font-weight: 100 900;
        font-style: normal;
        font-display: swap;
    }

    html, body {
        font-family: 'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
    }

    *, :before, :after {
        border-radius: 0 !important;
        box-sizing: border-box;
    }

    input, textarea, button, select {
        font-family: 'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
        -webkit-appearance: none;
        appearance: none;
        color: var(--text);
        border: var(--bw) solid var(--border);
        background: #0e1116;
    }

    ::placeholder {
        color: var(--muted);
        opacity: 1;
    }

    body {
        margin: 0;
        color: var(--text);
        background: #0a0b0d;
        height: 100vh;
        overflow: hidden;
    }

    .wrap {
        height: 100vh;
        display: grid;
        grid-template-columns: 320px 1fr;
    }

    /* LEFT */
    .left {
        background: linear-gradient(180deg,#12161c,#0e1116);
        border-right: var(--bw) solid var(--border);
        display: grid;
        grid-template-rows: auto auto 1fr;
        min-height: 0;
    }

        .left .head {
            padding: 12px 14px;
            border-bottom: var(--bw) solid var(--border);
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .left .tools {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: var(--bw) solid var(--border);
        }

    #convs {
        overflow: auto;
        padding-bottom: 10px;
    }

    .search-input {
        width: 100%;
        height: 40px;
        padding: 9px 12px;
        border: var(--bw) solid var(--border);
        background: #0e1116;
        color: #fff;
        box-shadow: 0 1px 0 var(--soft) inset;
    }

    .btn {
        padding: 10px 14px;
        border: var(--bw) solid var(--border);
        background: #0e1116;
        color: #fff;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 1px 0 var(--soft) inset;
        line-height: 1;
        white-space: nowrap;
    }

        .btn[disabled] {
            opacity: .5;
            cursor: not-allowed;
        }

        .btn:hover {
            background: #fff !important;
            color: #000;
            border-color: #fff;
        }

    .iconbtn {
        border: var(--bw) solid var(--border);
        background: #0e1116;
        cursor: pointer;
        opacity: .9;
        display: grid;
        place-items: center;
        width: 38px;
        height: 38px;
    }

        .iconbtn:hover {
            background: #151921;
        }

        .iconbtn img {
            width: 22px;
            height: 22px;
            display: block;
            image-rendering: pixelated;
        }

    .conv {
        display: grid;
        grid-template-columns: 44px 1fr;
        gap: 10px;
        padding: 10px 12px;
        border-bottom: 1px solid var(--soft);
        cursor: pointer;
    }

        .conv:hover {
            background: rgba(255,255,255,.06);
        }

        .conv.active {
            background: rgba(255,255,255,.10);
            outline: 2px solid #fff;
        }

    .avatar {
        width: 44px;
        height: 44px;
        border: 2px solid #fff;
        background: #000;
        object-fit: cover;
    }

    .conv .name {
        font-weight: 700;
    }

    .conv .preview {
        color: var(--muted);
        font-size: 13px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    /* RIGHT */
    .right {
        display: grid;
        grid-template-rows: auto 1fr auto;
        min-height: 0;
        position: relative;
    }

    .chat-head {
        padding: 10px 14px;
        border-bottom: var(--bw) solid var(--border);
        background: linear-gradient(180deg,#12161c,#0e1116);
        display: flex;
        align-items: center;
        gap: 10px;
        position: relative;
    }

        .chat-head .spacer {
            flex: 1;
        }

    .chat-pfp {
        width: 28px;
        height: 28px;
        border: var(--bw) solid var(--border);
        object-fit: cover;
        background: #000;
    }

    .chat-title {
        font-weight: 700;
    }

    /* 3-dots menu */
    .menu {
        position: absolute;
        right: 10px;
        top: 48px;
        background: var(--panel);
        border: var(--bw) solid var(--border);
        box-shadow: 0 8px 18px rgba(0,0,0,.35);
        padding: 6px;
        display: none;
        min-width: 200px;
        z-index: 20;
    }

        .menu .item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .menu .item:hover {
                background: rgba(255,255,255,.06);
            }

    .msgs {
        background: #000;
        padding: 12px 14px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-height: 0;
        position: relative; /* ⬅️ add */
    }

    #pad-top, #pad-bottom {
        height: 0;
    }

    .msg {
        max-width: 70%;
        padding: 10px 12px;
        margin: 0;
        border: var(--bw) solid var(--border);
        background: #0b0e12;
        box-shadow: 0 1px 0 var(--soft) inset;
        word-break: break-word;
        overflow-wrap: anywhere;
    }

        .msg > div {
            white-space: pre-wrap;
        }

    .me {
        align-self: flex-end;
        background: #0f1216;
    }

    /* system/command message */
    .sysmsg {
        align-self: center;
        max-width: 84%;
        border: none;
        background: transparent;
        box-shadow: none;
        color: var(--muted);
        font-style: italic;
        text-align: center;
        padding: 6px 8px;
    }

    .meta {
        color: var(--muted);
        font-size: 12px;
        margin-top: 4px;
    }

    .att {
        margin-top: 6px;
    }

    .composer {
        border-top: var(--bw) solid var(--border);
        background: #0b0e12;
        padding: 10px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
    }

        .composer > * {
            min-width: 0;
        }

        .composer textarea {
            width: 100%;
            min-height: 48px;
            max-height: 200px;
            resize: vertical;
            background: #0e1116;
            color: #fff;
            border: var(--bw) solid var(--border);
            padding: 12px;
            caret-color: #fff;
            line-height: 1.25;
        }

    .col {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        flex-wrap: wrap;
    }

    .chips {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 6px;
    }

    .chip {
        display: flex;
        align-items: center;
        gap: 6px;
        border: 1px solid var(--soft);
        padding: 6px 8px;
        font-size: 13px;
    }

        .chip .x {
            cursor: pointer;
            opacity: .85;
        }

    .warn {
        color: #ffdb74;
        font-size: 12px;
    }

    .jump {
        position: sticky; /* ⬅️ sits within the scroller */
        bottom: 12px; /* ⬅️ floats just above the bottom edge */
        align-self: center; /* ⬅️ centers horizontally in the flex column */
        opacity: 0;
        pointer-events: none;
        transition: opacity .18s ease;
        z-index: 5;
    }

    .jump.show {
        opacity: 1;
        pointer-events: auto;
    }

    @media (max-width:520px) {
        .msg {
            max-width: 100%;
        }
    }

    /* Overlay */
    .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
    }

    .sheet {
        width: min(720px,94vw);
        max-height: 82vh;
        overflow: auto;
        background: linear-gradient(180deg,var(--panel-2),var(--panel));
        border: var(--bw) solid var(--border);
        box-shadow: 0 8px 18px rgba(0,0,0,.35);
        padding: 12px;
    }

        .sheet h3 {
            margin: 0 0 10px;
        }

    .picker-bar {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin-bottom: 10px;
    }

    .list {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
    }

    .person {
        display: grid;
        grid-template-columns: 44px 1fr auto;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border: var(--bw) solid var(--border);
        background: #0c0f13;
        box-shadow: 0 1px 0 var(--soft) inset;
        cursor: pointer;
    }

    .pfp {
        width: 44px;
        height: 44px;
        border: 2px solid #fff;
        background: #000;
        object-fit: cover;
    }

    .person .name {
        font-weight: 700;
    }

    .person .bio {
        color: var(--muted);
        font-size: 13px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    .sheet .bottom-center {
        position: sticky;
        bottom: 0;
        display: flex;
        align-items: center;
        gap: 10px;
        padding-top: 10px;
        margin-top: 10px;
        background: linear-gradient(180deg,transparent,rgba(0,0,0,.35));
    }

    /* Checkbox — white hollow square when off; filled white when on */
    .checkbox {
        appearance: none;
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border: 2px solid #fff;
        background: transparent;
        display: inline-block;
        vertical-align: middle;
        margin: 0;
        cursor: pointer;
    }

    .checkbox:hover:not(:checked) {
        opacity: .5;
    }
    /* 50% opacity on hover when not selected */
    .checkbox:checked {
        background: #fff;
    }
    /* filled white square when checked */
    .checkbox:disabled {
        opacity: .3;
        cursor: not-allowed;
    }

    .checkbox:focus-visible {
        outline: 2px solid #fff;
        outline-offset: 2px;
    }

    .avatar, .pfp, .chat-pfp {
        border-radius: 999px !important;
        aspect-ratio: 1 / 1;
        object-fit: cover;
    }

    /* chips row in picker footer */
    #selected-chips {
        flex: 1;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
    }
</style>

<div class="wrap">
    <aside class="left">
        <div class="head">Direct Messages</div>
        <div class="tools">
            <input id="conv-q" class="search-input" placeholder="Search conversations…">
            <button id="btn-newdm" class="iconbtn" title="Start a conversation"><img src="/web/icons/new-dm.png" alt="+"></button>
            <button id="btn-newgroup" class="iconbtn" title="Create a group"><img src="/web/icons/new-group.png" alt="◎"></button>
        </div>
        <div id="convs"></div>
    </aside>

    <main class="right">
        <div class="chat-head">
            <img id="chat-pfp" class="chat-pfp" src="/web/default-avatar.png" alt="">
            <div class="chat-title" id="chat-title">Pick a conversation</div>
            <div class="spacer"></div>
            <button id="chat-menu-btn" class="iconbtn" title="Group options">⋮</button>
            <div id="chat-menu" class="menu"></div>
        </div>

        <div class="msgs" id="msgs">
            <div id="pad-top"></div>

            <!-- ⬇️ MOVE the jump button INTO .msgs, above pad-bottom -->
            <button id="jump" class="jump btn" style="display:none">Jump to present ↓</button>

            <div id="pad-bottom"></div>
        </div>

        <div class="composer">
            <div>
                <textarea id="text" maxlength="10000" placeholder="Message…"></textarea>
                <div class="chips" id="att-chips"></div>
                <div class="warn" id="rec-warn" style="display:none"></div>
            </div>
            <div class="col">
                <button class="btn" id="btn-attach">Attach</button>
                <button class="btn" id="btn-voice">Hold to record</button>
                <button class="btn" id="btn-send">Send</button>
                <input type="file" id="file" multiple style="display:none">
            </div>
        </div>
    </main>
</div>

<!-- Overlay -->
<div id="overlay" class="overlay" role="dialog" aria-modal="true">
    <div class="sheet" id="sheet">
        <h3 id="sheet-title">Start a conversation</h3>
        <div class="picker-bar">
            <input id="user-q" class="search-input" placeholder="Search friends…">
        </div>
        <div id="user-list" class="list"></div>
        <div class="bottom-center" id="group-cta" style="display:none">
            <div id="selected-chips"></div>
            <div style="display:flex; gap:8px;">
                <button class="btn" id="btn-cancel">Cancel</button>
                <button class="btn" id="btn-group-submit" disabled>Create Group</button>
            </div>
        </div>
    </div>
</div>

<script>
    (() => {
        const API = 'http://localhost:3000/api';
        const $ = id => document.getElementById(id);

        /* ---------------- state ---------------- */
        const state = {
            convId: null, meId: 0,
            allConvs: [], filteredConvs: [],
            lastMsgId: 0, oldestMsgId: null, nextBefore: null,
            es: null, poll: null,
            uploading: false,
            pendingFiles: [],
            recording: { active: false, chunks: [], size: 0, rec: null, warnShown: false },

            // convo + meta
            convMeta: new Map(),         // convId -> { name:'@og'|group title, photo:url }
            convRowEls: new Map(),       // convId -> DOM div.conv
            convUserOg: new Map(),       // convId -> og username (1:1)
            userCache: new Map(),        // og -> { username, photo, display_name, raw }
            convItems: new Map(),        // convId -> raw item (for debugging)

            // group/menu
            convDetailById: new Map(),
            currentConvDetail: null,     // {id,is_group,title,owner_id,is_owner,members:[]}
            pickerMode: 'dm',            // 'dm' | 'group-create' | 'group-edit' | 'view-members'
            selectedIds: new Set(),      // picked user_ids (others)
            initialSelectedIds: new Set(), // for edit-change detection
            friendsCache: [],            // list from fetchFriends()
            idToFriend: new Map(),       // id -> friend object for quick lookup

            renderedMsgIds: new Set(),
            fetchingAfter: false,
            meSlug: '',
        };
        const LASTDM_KEY = 'dp:lastdm';
        const META_CACHE_KEY = 'dp:metaCache';
        let _metaSaveTimer = null;
        function saveMetaCache() {
            const out = {
                convUserOg: Array.from(state.convUserOg.entries()),
                userCache: Array.from(state.userCache.entries()),
                convMeta: Array.from(state.convMeta.entries()),
            };
            try { localStorage.setItem(META_CACHE_KEY, JSON.stringify(out)); } catch { }
        }
        function scheduleSaveMeta() {
            clearTimeout(_metaSaveTimer);
            _metaSaveTimer = setTimeout(saveMetaCache, 120);
        }
        function loadMetaCache() {
            try {
                const j = JSON.parse(localStorage.getItem(META_CACHE_KEY) || 'null');
                if (!j) return;
                (j.convUserOg || []).forEach(([k, v]) => state.convUserOg.set(+k || k, v));
                (j.userCache || []).forEach(([k, v]) => state.userCache.set(k, v));
                (j.convMeta || []).forEach(([k, v]) => state.convMeta.set(+k || k, v));
            } catch { }
        }

        /* ---------------- utils ---------------- */
        const afterPaint = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        function esc(s) { return String(s || '').replace(/[&<>]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m])) }
        function fmt(t) { try { return new Date(t).toLocaleString() } catch { return '' } }
        function saveLastDM() { try { localStorage.setItem(LASTDM_KEY, JSON.stringify({ meId: state.meId | 0, convId: state.convId | 0, at: Date.now() })) } catch { } }
        function loadLastDM() { try { return JSON.parse(localStorage.getItem(LASTDM_KEY) || 'null') } catch { return null } }
        function nearBottom(px = 60) { const el = $('msgs'); return (el.scrollHeight - el.scrollTop - el.clientHeight) < px }
        function scrollToBottom() { const el = $('msgs'); el.scrollTop = el.scrollHeight + 9999 }

        const pickDisplay = o => o?.display_name || o?.name || null;
        const pickUsername = o => o?.first_username || o?.username || o?.handle || null;
        const DEFAULT_PFP = '/web/default-avatar.png';
        const pickPhoto = o => o?.profile_photo || o?.profile_photo_url || o?.photo || o?.photo_url || o?.avatar || o?.avatar_url || o?.picture || o?.image || o?.image_url || null;
        const pickName = o => o?.display_name || o?.name || o?.username || o?.first_username || o?.handle || o?.title || null;

        const isPlaceholder = (m) => !m || m.name === 'Direct Message' || !m.photo || m.photo === DEFAULT_PFP;
        const scoreMeta = (m) => !m ? 0 : ((m.name && m.name !== 'Direct Message') ? 1 : 0) + ((m.photo && m.photo !== DEFAULT_PFP) ? 1 : 0);

        function mergeMeta(prev, next) {
            const out = { ...(prev || {}), ...(next || {}) };
            if (prev) {
                if (!next?.name || next.name === 'Direct Message') out.name = prev.name;
                if (!next?.photo || next.photo === DEFAULT_PFP) out.photo = prev.photo;
            }
            return out;
        }

        function joinNames(list) {
            const arr = (list || []).filter(Boolean);
            if (arr.length === 0) return '';
            if (arr.length === 1) return arr[0];
            if (arr.length === 2) return `${arr[0]} and ${arr[1]}`;
            return `${arr.slice(0, -1).join(', ')}, and ${arr[arr.length - 1]}`;
        }

        function friendDisplay(u) {
            // Prefer nice name; fall back to username-ish, capitalize first letter
            const raw = u.display_name || u.name || u.first_username || u.username || 'User';
            return String(raw);
        }

        /* ---------------- API core ---------------- */
        async function api(path, opts = {}) {
            const headers = Object.assign({ 'Accept': 'application/json' }, opts.headers || {});
            const isJSON = opts.body && !(opts.body instanceof FormData);
            if (isJSON && !headers['Content-Type']) headers['Content-Type'] = 'application/json';
            const url = API + path;
            try {
                const r = await fetch(url, { credentials: 'include', method: opts.method || 'GET', headers, body: isJSON ? JSON.stringify(opts.body) : opts.body });
                const t = await r.text(); let d; try { d = t ? JSON.parse(t) : {} } catch { d = { raw: t } }
                if (!r.ok) { const e = new Error(d?.error || r.statusText); e.status = r.status; e.detail = d?.detail || t; throw e; }
                return d;
            } catch (e) { throw e; }
        }
        async function getMe() {
            const j = await api('/auth/me');
            state.meId = j?.user?.id || 0;
            state.meSlug = j?.user?.first_username || j?.user?.username || '';
            return state.meId;
        }

        /* ---------------- meta resolution ---------------- */
        async function fetchConvMeta(id) {
            const prev = state.convMeta.get(id);
            try {
                const j = await api(`/dm/conversations/${id}`);

                // Build meta for the left list/top bar
                let meta = { name: 'Direct Message', photo: DEFAULT_PFP };
                if (j.is_group) {
                    if ((j.title || '').trim()) meta.name = j.title.trim();
                    meta.photo = j.photo || j.avatar || meta.photo;
                } else {
                    const other = j.other || (Array.isArray(j.members) ? j.members.find(u => (u.id | 0) !== (state.meId | 0)) : null);
                    meta.name = pickName(other) || meta.name;
                    meta.photo = pickPhoto(other) || meta.photo;
                }

                // Build a stable “detail” object
                const detail = {
                    id: j.id,
                    is_group: !!j.is_group,
                    title: j.title || null,
                    owner_id: j.owner_id || null,
                    is_owner: !!j.is_owner,
                    members: j.members || []
                };

                // Cache detail by id
                state.convDetailById.set(id, detail);

                // Only update the "current" detail if this is the currently open conversation
                if ((state.convId | 0) === (id | 0)) {
                    state.currentConvDetail = detail;
                }

                // Merge/display meta
                const best = mergeMeta(prev, meta);
                state.convMeta.set(id, best);

                // Only touch the UI of the current chat
                if ((state.convId | 0) === (id | 0)) updateEverywhere(id);

                return best;
            } catch (e) {
                if (prev) return prev;
                const fallback = { name: 'Direct Message', photo: DEFAULT_PFP };
                state.convMeta.set(id, fallback);
                return fallback;
            }
        }

        function setConvMeta(id, meta, source = 'unknown') {
            const prev = state.convMeta.get(id);
            const ps = scoreMeta(prev), ns = scoreMeta(meta);
            if (ns > ps) { state.convMeta.set(id, meta); updateEverywhere(id); scheduleSaveMeta(); }
        }

        function setImgSafe(img, src) {
            const want = src || DEFAULT_PFP;
            if (!img) return;
            if (img.dataset.srcApplied === want) return;
            img.onerror = () => { img.src = DEFAULT_PFP; img.dataset.srcApplied = DEFAULT_PFP; };
            img.src = want; img.dataset.srcApplied = want;
        }

        function updateTopBar(meta) {
            if (!meta) return;
            $('chat-title').textContent = meta.name || 'Direct Message';
            setImgSafe($('chat-pfp'), meta.photo);
            renderChatMenu();
        }

        function updateEverywhere(id) {
            const meta = state.convMeta.get(id);
            if (!meta) return;
            const row = state.convRowEls.get(id);
            if (row) setConvRowContent(row, meta, row.querySelector('.preview')?.textContent || '');
            if (state.convId === id) {
                const current = { name: $('chat-title').textContent, photo: $('chat-pfp').getAttribute('src') };
                const better = scoreMeta(meta) >= scoreMeta(current);
                if (better) updateTopBar(meta);
            }
        }

        function setConvRowContent(row, meta, preview) {
            row.innerHTML = `
            <img class="avatar" src="${meta?.photo || DEFAULT_PFP}" alt="">
            <div>
                <div class="name">${esc(meta?.name || 'Direct Message')}</div>
                <div class="preview">${esc(preview || '…')}</div>
            </div>`;
        }

        function applySelectedHighlight() {
            document.querySelectorAll('.conv.active').forEach(el => el.classList.remove('active'));
            const el = state.convRowEls.get(state.convId);
            if (el) el.classList.add('active');
        }

        /* OG extraction for 1:1 fallback */
        function extractOgFromConvDetail(j) {
            const direct = j?.other_username || j?.other?.first_username || j?.other?.username ||
                j?.with?.first_username || j?.with?.username || null;
            if (direct) return direct;
            const arr = j?.members || j?.participants || j?.users || j?.people || [];
            if (Array.isArray(arr) && arr.length) {
                const other = arr.find(p => {
                    const pid = (p?.id ?? p?.user?.id);
                    return pid == null || (pid | 0) !== (state.meId | 0);
                }) || arr[0];
                const u = other?.user || other || {};
                return pickUsername(u) || null;
            }
            return null;
        }

        async function fetchUserByOg(og) {
            if (!og) throw new Error('no-og');
            if (state.userCache.has(og)) return state.userCache.get(og);
            const tries = [
                `/users/${encodeURIComponent(og)}`,
                `/users/${encodeURIComponent(og)}?view=basic`,
                `/profiles/${encodeURIComponent(og)}`,
                `/users/by_username/${encodeURIComponent(og)}`,
                `/user/${encodeURIComponent(og)}`
            ];
            for (const path of tries) {
                try {
                    const j = await api(path);
                    const username = pickUsername(j) || og;
                    const photo = pickPhoto(j);
                    const display = pickDisplay(j);
                    const result = { username, photo, display_name: display, raw: j };
                    state.userCache.set(og, result);
                    scheduleSaveMeta();
                    return result;
                } catch { }
            }
            throw new Error('user-not-found:' + og);
        }
        function metaFromUser(u) {
            const nm = '@' + (u?.username || 'user');
            const ph = u?.photo || DEFAULT_PFP;
            return { name: nm, photo: ph };
        }

        /* ---------------- conversations list ---------------- */
        function renderConvs(list) {
            const wrap = $('convs'); wrap.innerHTML = '';
            state.convRowEls.clear();
            list.forEach(it => {
                const row = document.createElement('div'); row.className = 'conv'; row.dataset.id = it.id;
                const meta = state.convMeta.get(it.id) || { name: it.title || 'Direct Message', photo: DEFAULT_PFP };
                row.onclick = () => openConversation(it.id, meta?.name || it.title || 'Direct Message');
                setConvRowContent(row, meta, it.preview);
                state.convRowEls.set(it.id, row);
                wrap.append(row);
                // Safety only (should already be hydrated when blockingMeta=true on first load):
                if (!state.convMeta.has(it.id) || isPlaceholder(state.convMeta.get(it.id))) {
                        fetchConvMeta(it.id).catch(() => { });
                }
            });
            applySelectedHighlight();
        }
        function applyConvFilter() {
            const q = $('conv-q').value.trim().toLowerCase();
            state.filteredConvs = !q ? [...state.allConvs]
                : state.allConvs.filter(c => {
                    const name = (state.convMeta.get(c.id)?.name || c.title || 'Direct Message').toLowerCase();
                    return name.includes(q) || (c.preview || '').toLowerCase().includes(q);
                });
            renderConvs(state.filteredConvs);
        }
        async function loadConversations({ blockingMeta = false } = {}) {
            const j = await api('/dm/conversations');
            state.allConvs = j.items || [];
            state.allConvs.forEach(it => state.convItems.set(it.id, it));

            // ⬇️ NEW: pre-seed row names/photos synchronously
            for (const it of state.allConvs) {
                if (!state.convMeta.has(it.id)) {
                    let meta = { name: it.title || 'Direct Message', photo: DEFAULT_PFP };

                    if (!it.is_group) {
                        // Try to infer @username directly from list item (if it exposes it),
                        // otherwise use any cached mapping from prior sessions.
                        let og = state.convUserOg.get(it.id) || extractOgFromConvDetail(it);
                        if (og) {
                            state.convUserOg.set(it.id, og);
                            meta.name = '@' + og;
                            const cached = state.userCache.get(og);
                            if (cached?.photo) meta.photo = cached.photo;
                            scheduleSaveMeta();
                        }
                    }

                    state.convMeta.set(it.id, meta);
                }
            }
            scheduleSaveMeta();

            if (blockingMeta) {
            // Fetch real meta for each conversation exactly like chat-open does
                await Promise.allSettled(
                    state.allConvs.map(it => fetchConvMeta(it.id))
                );
            } else {
            // Non-blocking path (used after new messages arrive)
                state.allConvs.forEach(it => {
                    if (!state.convMeta.has(it.id) || isPlaceholder(state.convMeta.get(it.id))) {
                        fetchConvMeta(it.id).catch(() => { });
                        }
                });
            }

            renderConvs(state.allConvs);
        }
        $('conv-q').addEventListener('input', applyConvFilter);

        /* ---------------- virtualization ---------------- */
        const MAX_DOM = 140, GAP = 6;
        let bottomPadPx = 0, removedBottom = [];
        function setBottomPad(px) { bottomPadPx = Math.max(0, px | 0); $('pad-bottom').style.height = bottomPadPx + 'px'; }

        function renderMessage(m) {
            const isSystem = (m.kind === 'system');
            const wrap = document.createElement('div');
            wrap.className = (isSystem ? 'msg sysmsg' : ('msg' + (m.sender_id === state.meId ? ' me' : '')));
            if (m.text) wrap.insertAdjacentHTML('beforeend', '<div>' + esc(m.text) + '</div>');
            if (!isSystem) {
                (m.attachments || []).forEach(a => {
                    const url = `${API}/dm/attachments/${a.id}/download?inline=1`;
                    let v = '';
                    if ((a.mime_type || '').startsWith('image/')) v = `<img class="att" src="${url}" style="max-width:420px;display:block">`;
                    else if ((a.mime_type || '').startsWith('video/')) v = `<video class="att" src="${url}" controls style="max-width:420px;display:block"></video>`;
                    else if ((a.mime_type || '').startsWith('audio/')) v = `<audio class="att" src="${url}" controls></audio>`;
                    else v = `<a class="att" href="${url}">📎 ${esc(a.filename)}</a>`;
                    wrap.insertAdjacentHTML('beforeend', v);
                });
                wrap.insertAdjacentHTML('beforeend', `<div class="meta">${m.created_at ? fmt(m.created_at) : ''}</div>`);
            }
            wrap.querySelectorAll('img').forEach(img => img.addEventListener('load', () => { if (nearBottom(200)) scrollToBottom(); }, { once: true }));
            wrap.querySelectorAll('video').forEach(v => v.addEventListener('loadedmetadata', () => { if (nearBottom(200)) scrollToBottom(); }, { once: true }));
            return wrap;
        }

        function appendMessagesAscending(items) {
            items = (items || []).filter(m => !state.renderedMsgIds.has(m.id));
            const anchor = $('pad-bottom');
            items.forEach(m => {
                state.renderedMsgIds.add(m.id);                     // <-- mark seen
                const el = renderMessage(m);
                anchor.before(el);
                state.oldestMsgId = state.oldestMsgId === null ? m.id : Math.min(state.oldestMsgId, m.id);
                state.lastMsgId = Math.max(state.lastMsgId, m.id);
            });
            maybeTrimBottom();
        }
        function prependOlderAscending(items) {
            items = (items || []).filter(m => !state.renderedMsgIds.has(m.id));
            if (!items.length) return;
            const box = $('msgs');
            const prevTop = box.scrollTop, prevH = box.scrollHeight;
            const frag = document.createDocumentFragment();
            items.forEach(m => {
                state.renderedMsgIds.add(m.id);                     // <-- mark seen
                frag.append(renderMessage(m));
                state.oldestMsgId = state.oldestMsgId === null ? m.id : Math.min(state.oldestMsgId, m.id);
                state.lastMsgId = Math.max(state.lastMsgId, m.id);
            });
            const afterTop = $('pad-top').nextSibling || $('pad-bottom');
            box.insertBefore(frag, afterTop);
            box.scrollTop = prevTop + (box.scrollHeight - prevH);
            maybeTrimBottom();
        }
        function maybeTrimBottom() {
            const box = $('msgs');
            if (nearBottom(200)) return;
            while (true) {
                const last = $('pad-bottom').previousElementSibling;
                if (!last || !last.classList.contains('msg')) break;
                const count = box.querySelectorAll('.msg').length;
                if (count <= MAX_DOM) break;
                const h = last.offsetHeight + GAP;
                removedBottom.push({ el: last, h });
                last.remove(); setBottomPad(bottomPadPx + h);
            }
        }
        function maybeRestoreBottom(chunk = 24) {
            if (!removedBottom.length) return;
            const box = $('msgs'); const dist = (box.scrollHeight - box.clientHeight - box.scrollTop);
            if (dist > 1200) return;
            let n = 0; while (removedBottom.length && n < chunk) {
                const { el, h } = removedBottom.pop();
                $('pad-bottom').before(el); setBottomPad(bottomPadPx - h); n++;
            }
        }

        const jumpBtn = (() => {
            const el = $('jump');
            function sync() { if (nearBottom(120)) { el.classList.remove('show'); el.style.display = 'none'; } else { el.style.display = ''; el.classList.add('show'); } }
            el.addEventListener('click', () => { while (removedBottom.length) { const { el: n, h } = removedBottom.pop(); $('pad-bottom').before(n); setBottomPad(bottomPadPx - h); } scrollToBottom(); sync(); });
            return { sync };
        })();

        /* ---------------- open/paging/realtime ---------------- */
        async function openConversation(id) {
            if (state.es) { try { state.es.close(); } catch { } state.es = null; }
            if (state.poll) { clearInterval(state.poll); state.poll = null; }

            state.convId = id; saveLastDM();
            state.currentConvDetail = state.convDetailById.get(id) || null;
            renderChatMenu(); // show something immediately; fetch will firm it up
            applySelectedHighlight();

            if (!state.convMeta.has(id)) {
                const seedItem = state.convItems.get(id) || {};
                state.convMeta.set(id, { name: seedItem.title || 'Direct Message', photo: DEFAULT_PFP });
            }
            updateEverywhere(id);

            // hydrate meta & detail
            fetchConvMeta(id).catch(() => { });

            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
            state.renderedMsgIds.clear();          // <-- add this
            setBottomPad(0); removedBottom = []; state.lastMsgId = 0; state.oldestMsgId = null; state.nextBefore = null;

            const j = await api(`/dm/conversations/${id}/messages?limit=30`);
            appendMessagesAscending(j.items || []);
            state.nextBefore = j.next_before;

            try { await (document.fonts && document.fonts.ready); } catch { }
            await afterPaint(); await afterPaint();
            scrollToBottom();

            jumpBtn.sync();
            openStream(id);
            startCatchup();
        }

        $('msgs').addEventListener('scroll', async () => {
            jumpBtn.sync(); maybeRestoreBottom();
            const box = $('msgs');
            if (box.scrollTop <= 20 && state.nextBefore) {
                const j = await api(`/dm/conversations/${state.convId}/messages?before=${state.nextBefore}&limit=20`);
                prependOlderAscending(j.items || []); state.nextBefore = j.next_before;
            }
        });

        function openStream(id) {
            const es = new EventSource(`${API}/dm/conversations/${id}/stream`, { withCredentials: true });
            state.es = es;
            es.addEventListener('new', async () => { await fetchAfter(state.lastMsgId); });
        }
        function startCatchup() { state.poll = setInterval(() => { fetchAfter(state.lastMsgId).catch(() => { }); }, 30000); }
        async function fetchAfter(lastId) {
            if (state.fetchingAfter) return;          // <-- lock
            state.fetchingAfter = true;
            try {
                const j = await api(`/dm/conversations/${state.convId}/messages?after=${lastId}&limit=100`);
                if (!j.items || !j.items.length) return;

                const newOnes = j.items.filter(m => !state.renderedMsgIds.has(m.id));
                if (!newOnes.length) return;

                const stick = nearBottom(80);
                appendMessagesAscending(newOnes);
                if (stick) { await afterPaint(); scrollToBottom(); }
                loadConversations().catch(() => { });
                jumpBtn.sync();
            } finally {
                state.fetchingAfter = false;
            }
        }

        /* ---------------- attachments + voice ---------------- */
        const MAX = 1024 * 1024;
        const chips = $('att-chips'); const recWarn = $('rec-warn');

        function refreshChips() {
            chips.innerHTML = '';
            state.pendingFiles.forEach((f, i) => {
                const c = document.createElement('div'); c.className = 'chip';
                c.innerHTML = `<span>${esc(f.name)} · ${(f.size / 1024 | 0)} KB</span><span class="x">✕</span>`;
                c.querySelector('.x').onclick = () => { state.pendingFiles.splice(i, 1); refreshChips(); };
                chips.append(c);
            });
        }
        function addPendingFile(o) { state.pendingFiles.push(o); refreshChips(); }

        async function gzipBytes(uint8) {
            if (!('CompressionStream' in window)) return { buf: uint8, encoding: null };
            const cs = new CompressionStream('gzip'); const w = cs.writable.getWriter(); await w.write(uint8); await w.close();
            const res = await new Response(cs.readable).arrayBuffer(); return { buf: new Uint8Array(res), encoding: 'gzip' };
        }
        async function compressImage(file, maxSide = 1280, q = .75) {
            const img = await createImageBitmap(file);
            let { width: w, height: h } = img; const s = Math.min(1, maxSide / Math.max(w, h)); w = (w * s) | 0; h = (h * s) | 0;
            const canvas = new OffscreenCanvas(w, h); const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, w, h);
            let blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: q });
            while (blob.size > MAX && q > 0.4) { q -= 0.1; blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: q }); }
            if (blob.size > MAX) throw new Error('Image too large even after compression');
            return new Uint8Array(await blob.arrayBuffer());
        }
        async function compressGeneric(file) {
            const uint = new Uint8Array(await file.arrayBuffer());
            const { buf, encoding } = await gzipBytes(uint);
            if (buf.length > MAX) throw new Error('File too large after compression');
            return { buf, encoding };
        }
        async function handleFileInput(files) {
            for (const file of files) {
                try {
                    const type = (file.type || '').toLowerCase();
                    if (type.startsWith('image/')) {
                        const buf = await compressImage(file);
                        addPendingFile({ name: file.name.replace(/\.(png|webp|jpeg|jpg)$/i, '.jpg'), type: 'image/jpeg', buf, size: buf.length, encoding: null });
                    } else {
                        const { buf, encoding } = await compressGeneric(file);
                        addPendingFile({ name: (encoding === 'gzip' && !/\.gz$/i.test(file.name)) ? file.name + '.gz' : file.name, type: file.type || 'application/octet-stream', buf, size: buf.length, encoding });
                    }
                } catch (e) { alert(`${file.name}: ${e.message || e}`); }
            }
        }

        /* ---------------- overlay (friends / group create/edit / view members) ---------------- */
        const overlay = $('overlay'), userList = $('user-list');
        const pageSlug = (location.pathname.match(/\/user\/([^\/]+)\/messages/i) || [])[1]
            ? decodeURIComponent((location.pathname.match(/\/user\/([^\/]+)\/messages/i) || [])[1]) : '';

        async function fetchFriends() {
            // Try /users/me/friends first (most correct), then fall back to slugged endpoint
            let arr = [];
            try {
                const j1 = await api(`/users/me/friends`);
                arr = j1.items || j1.friends || [];
            } catch { }

            if ((!arr || !arr.length) && state.meSlug) {
                try {
                    const j2 = await api(`/users/${encodeURIComponent(state.meSlug)}/friends?offset=0&limit=500`);
                    arr = j2.items || j2.friends || [];
                } catch { }
            }

            // Normalize fields (id/username may be at top level or nested)
            const norm = (arr || []).map(u => {
                const nu = u.user || u; // some APIs nest under { user: { ... } }
                const id = nu.id ?? nu.user_id ?? nu.friend_id ?? null;
                const username = nu.username ?? nu.first_username ?? null;
                const first_username = nu.first_username ?? nu.username ?? null;
                const profile_photo = nu.profile_photo ?? null;
                const bio = nu.bio ?? nu.bio_html ?? '';
                return { id, username, first_username, profile_photo, bio };
            }).filter(x => x.id);

            return norm;
        }

        function refreshSelectedChips() {
            const chipBox = $('selected-chips'); chipBox.innerHTML = '';
            const ids = [...state.selectedIds];
            ids.forEach(uid => {
                const u = state.idToFriend.get(uid) || {};
                const label = friendDisplay(u);
                const el = document.createElement('div');
                el.className = 'chip';
                el.innerHTML = `<span>${esc(label)}</span><span class="x" title="Remove">✕</span>`;
                el.querySelector('.x').onclick = (e) => { e.stopPropagation(); state.selectedIds.delete(uid); renderFriends(state.friendsCache); refreshSelectedChips(); refreshGroupSubmitState(); };
                chipBox.append(el);
            });
        }

        function refreshGroupSubmitState() {
            const btn = $('btn-group-submit');
            const mode = state.pickerMode;
            if (mode === 'group-create') {
                btn.textContent = 'Create Group';
                btn.disabled = (state.selectedIds.size < 2); // need >1 other (3 total incl me)
            } else if (mode === 'group-edit') {
                btn.textContent = 'Save Changes';
                // total members after save = 1 (owner/me) + selectedIds.size (others incl current may overlap)
                const total = 1 + state.selectedIds.size;
                const changed = !eqSets(state.selectedIds, state.initialSelectedIds);
                btn.disabled = !(changed && total >= 3);
            } else {
                btn.textContent = 'Close';
                btn.disabled = false;
            }
            $('group-cta').style.display = (mode === 'group-create' || mode === 'group-edit') ? '' : 'none';
        }

        function eqSets(a, b) { if (a.size !== b.size) return false; for (const v of a) if (!b.has(v)) return false; return true; }

        function renderFriends(list) {
            state.friendsCache = list || [];
            state.idToFriend.clear();
            list.forEach(u => state.idToFriend.set(u.id, u));

            userList.innerHTML = '';
            const q = $('user-q').value.trim().toLowerCase();

            let items = list.filter(u => {
                if (!q) return true;
                return (u.username || '').toLowerCase().includes(q) ||
                    (u.first_username || '').toLowerCase().includes(q) ||
                    (u.bio || '').toLowerCase().includes(q);
            });

            const mode = state.pickerMode;

            items.forEach(u => {
                const row = document.createElement('div'); row.className = 'person';

                const label = '@' + (u.username || u.first_username || 'user');
                const checked = state.selectedIds.has(u.id);
                const isEdit = (mode === 'group-edit');
                const isOwner = state.currentConvDetail?.is_owner;
                const isMe = (u.id | 0) === (state.meId | 0); // should not be in friends list anyway
                const disableCheck = false; // only friends list (not members) so no self here

                let right = '';

                if (mode === 'dm') {
                    right = `<div class="act"><button class="btn person-message">Message</button></div>`;
                } else if (mode === 'group-create' || mode === 'group-edit') {
                    right = `<div class="act">
                    <input type="checkbox" class="checkbox person-check" ${checked ? 'checked' : ''} ${disableCheck ? 'disabled' : ''} />
                </div>`;
                } else if (mode === 'view-members') {
                    right = `<div class="act"></div>`;
                }

                row.innerHTML = `
                <img class="pfp" src="${u.profile_photo || DEFAULT_PFP}" alt="">
                <div>
                    <div class="name">${esc(label)}</div>
                    <div class="bio">${esc(u.bio || '')}</div>
                </div>
                ${right}
            `;

                if (mode === 'dm') {
                    row.onclick = (e) => { if (e.target.closest('.person-message')) return; startDmWith(u); };
                    row.querySelector('.person-message').onclick = async (e) => { e.stopPropagation(); await startDmWith(u); };
                } else if (mode === 'group-create' || mode === 'group-edit') {
                    const toggle = () => {
                        if (state.selectedIds.has(u.id)) state.selectedIds.delete(u.id);
                        else state.selectedIds.add(u.id);
                        renderFriends(state.friendsCache);
                        refreshSelectedChips();
                        refreshGroupSubmitState();
                    };
                    row.onclick = toggle;
                    const cb = row.querySelector('.person-check');
                    if (cb) cb.addEventListener('click', (e) => { e.stopPropagation(); toggle(); });
                } else {
                    row.onclick = () => { };
                }

                userList.append(row);
            });

            refreshSelectedChips();
        }

        async function openPicker(mode = 'dm', opts = {}) {
            state.pickerMode = mode;
            state.selectedIds = new Set(opts.preselectIds || []);
            state.initialSelectedIds = new Set(opts.preselectIds || []);
            $('overlay').style.display = 'flex';
            $('user-q').value = '';
            $('sheet-title').textContent =
                mode === 'dm' ? 'Start a conversation'
                    : mode === 'group-create' ? 'Create a Group'
                        : mode === 'group-edit' ? 'Edit Group Members'
                            : 'Group Members';

            $('group-cta').style.display = (mode === 'group-create' || mode === 'group-edit') ? '' : 'none';
            refreshGroupSubmitState();

            const friends = await fetchFriends();
            renderFriends(friends);
        }
        function closePicker() { $('overlay').style.display = 'none'; }

        $('btn-newdm').onclick = () => openPicker('dm');
        $('btn-newgroup').onclick = () => openPicker('group-create');

        overlay.addEventListener('click', e => { if (e.target === overlay) closePicker(); });
        document.addEventListener('keydown', e => { if (e.key === 'Escape') { closePicker(); hideChatMenu(); } });

        $('user-q').addEventListener('input', async () => renderFriends(state.friendsCache));

        $('btn-cancel').onclick = () => closePicker();

        $('btn-group-submit').onclick = async () => {
            if (state.pickerMode === 'group-create') {
                if (state.selectedIds.size < 2) return;
                const ids = [...state.selectedIds];
                const names = ids.map(id => friendDisplay(state.idToFriend.get(id)));
                const title = joinNames(names);
                try {
                    const res = await api('/dm/conversations', { method: 'POST', body: { user_ids: ids, title } });
                    closePicker();
                    await loadConversations({ blockingMeta: true });
                    if (res?.id) await openConversation(res.id);
                } catch (e) { alert(e.detail || e.message || e); }
            } else if (state.pickerMode === 'group-edit') {
                const detail = state.currentConvDetail || {};
                const before = new Set(state.initialSelectedIds);
                const after = new Set(state.selectedIds);
                const add = [...after].filter(x => !before.has(x));
                const remove = [...before].filter(x => !after.has(x));
                const total = 1 + after.size;
                if (total < 3 || (add.length === 0 && remove.length === 0)) return;
                try {
                    await api(`/dm/conversations/${state.convId}/members`, { method: 'PATCH', body: { add_user_ids: add, remove_user_ids: remove } });
                    closePicker();
                    await fetchConvMeta(state.convId);
                    await fetchAfter(state.lastMsgId);
                    await loadConversations({ blockingMeta: true });
                } catch (e) { alert(e.detail || e.message || e); }
            } else {
                closePicker();
            }
        };

        async function startDmWith(u) {
            try {
                const og = u.first_username || u.username;
                const res = await api(`/dm/with/${encodeURIComponent(og)}`, { method: 'POST' });
                closePicker(); await loadConversations({ blockingMeta: true });
                const cid = res?.conversation_id || res?.id;
                if (cid) {
                    const meta = { name: '@' + og, photo: u.profile_photo || DEFAULT_PFP };
                    setConvMeta(cid, meta, 'startDmWith');
                    state.userCache.set(og, { username: og, photo: u.profile_photo || DEFAULT_PFP, display_name: null, raw: u });
                    scheduleSaveMeta();
                    openConversation(cid);
                } else if (state.allConvs[0]) {
                    openConversation(state.allConvs[0].id);
                }
            } catch (e) { alert(e.message || e); }
        }

        /* ---------------- 3-dots chat menu ---------------- */
        const chatMenu = $('chat-menu');
        const chatMenuBtn = $('chat-menu-btn');

        function hideChatMenu() { chatMenu.style.display = 'none'; }
        function toggleChatMenu() {
            if (chatMenu.style.display === 'none' || !chatMenu.style.display) { renderChatMenu(); chatMenu.style.display = 'block'; }
            else chatMenu.style.display = 'none';
        }
        chatMenuBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleChatMenu(); });
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.menu') && e.target !== chatMenuBtn) hideChatMenu();
        });

        function renderChatMenu() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            const isGroup = det.is_group;
            const isOwner = !!det.is_owner;

            // Only hide the button if we *know* this is a DM. If we don't know yet, keep it visible.
            if (isGroup === false) {
                chatMenu.innerHTML = '';
                chatMenu.style.display = 'none';
                chatMenuBtn.style.display = 'none';
                return;
            }
            chatMenuBtn.style.display = '';

            const items = [];
            if (isOwner) {
                items.push({ id: 'rename', label: 'Rename group' });
                items.push({ id: 'edit-members', label: 'Add or remove people' });
            }
            items.push({ id: 'view-members', label: 'View members' });
            if (!isOwner) items.push({ id: 'leave', label: 'Leave group' });
            if (isOwner) items.push({ id: 'disband', label: 'Disband group' });

            chatMenu.innerHTML = items.map(i => `<div class="item" data-id="${i.id}">${esc(i.label)}</div>`).join('');

            chatMenu.querySelectorAll('.item').forEach(el => {
                el.onclick = async () => {
                    const id = el.dataset.id;
                    hideChatMenu();
                    if (id === 'rename') {
                        const current = state.currentConvDetail?.title || state.convMeta.get(state.convId)?.name || '';
                        const name = prompt('New group name:', current) || '';
                        const trimmed = name.trim();
                        if (!trimmed) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/title`, { method: 'PATCH', body: { title: trimmed } });
                            await fetchConvMeta(state.convId);
                            await fetchAfter(state.lastMsgId);
                            await loadConversations({ blockingMeta: true });
                            await afterPaint();          // <-- add
                            renderChatMenu();            // <-- add (ensures menu rebinds cleanly)
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'edit-members') {
                        // preselect all current others (everyone except owner/me)
                        const members = (state.currentConvDetail?.members || []).filter(u => (u.id | 0) !== (state.currentConvDetail.owner_id | 0));
                        const pre = members.map(u => u.id);
                        await openPicker('group-edit', { preselectIds: pre });
                    } else if (id === 'view-members') {
                        // List current members (no checkboxes)
                        state.pickerMode = 'view-members';
                        $('sheet-title').textContent = 'Group Members';
                        $('group-cta').style.display = 'none';
                        $('overlay').style.display = 'flex';
                        $('user-q').value = '';
                        // synthesize a list from current members (may include non-friends)
                        const members = (state.currentConvDetail?.members || []).map(u => ({
                            id: u.id, username: u.username, first_username: u.first_username, profile_photo: u.profile_photo, bio: ''
                        }));
                        renderFriends(members);
                    } else if (id === 'leave') {
                        if (!confirm('Leave this group?')) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/leave`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'disband') {
                        if (!confirm('Disband this group for everyone? This cannot be undone.')) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/disband`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || e.message || e); }
                    }
                };
            });
        }

        /* ---------------- wire UI ---------------- */
        $('btn-attach').onclick = () => $('file').click();
        $('file').onchange = async e => { await handleFileInput(e.target.files); e.target.value = ''; };
        $('btn-send').onclick = sendMessage;
        $('text').addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

        const voice = $('btn-voice');
        const startRec = e => { e.preventDefault(); voice.textContent = 'Recording… release to stop'; startRecording(); };
        const stopRec = e => { e.preventDefault(); voice.textContent = 'Hold to record'; stopRecording(false); };
        voice.addEventListener('pointerdown', startRec);
        voice.addEventListener('pointerup', stopRec);
        voice.addEventListener('pointercancel', stopRec);
        voice.addEventListener('mouseleave', () => { if (state.recording.active) stopRec(new Event('pointerup')); });

        async function sendMessage() {
            if (!state.convId || state.uploading) return;
            let text = $('text').value;
            if (!text && state.pendingFiles.length === 0) return;
            if (text.length > 10000) { alert('Message is over 10,000 characters. Please shorten it.'); return; }
            text = text.trim();

            const fd = new FormData();
            fd.append('text', text);
            state.pendingFiles.forEach((f, i) => {
                const blob = new Blob([f.buf], { type: f.type || 'application/octet-stream' });
                const name = f.name || `file-${i}`;
                fd.append('files', blob, name);
                if (f.encoding) fd.append(`encoding_${name}`, f.encoding);
            });

            state.uploading = true;
            try {
                const r = await fetch(`${API}/dm/conversations/${state.convId}/messages`, { method: 'POST', credentials: 'include', body: fd });
                const t = await r.text(); if (!r.ok) throw new Error(t || r.statusText);
                const j = JSON.parse(t);
                if (j && j.id) state.lastMsgId = Math.max(state.lastMsgId, j.id | 0);
                $('text').value = ''; state.pendingFiles = []; refreshChips();
                await fetchAfter(state.lastMsgId);
                loadConversations().catch(() => { });
                if (nearBottom()) { await afterPaint(); scrollToBottom(); }
            } catch (e) { alert(e.message || e); }
            finally { state.uploading = false; }
        }

        /* ---------------- boot ---------------- */
        (async () => {
            await getMe();
            loadMetaCache();

            // If the URL contains someone else’s slug, rewrite it to mine.
            const urlMatch = location.pathname.match(/\/user\/([^\/]+)\/messages/i);
            const urlSlug = urlMatch ? decodeURIComponent(urlMatch[1]) : '';
            if (state.meSlug && urlSlug && urlSlug.toLowerCase() !== state.meSlug.toLowerCase()) {
                history.replaceState(null, '', `/user/${encodeURIComponent(state.meSlug)}/messages`);
            }

            await loadConversations({ blockingMeta: true });
            const last = loadLastDM();
            if (last && (last.meId | 0) === (state.meId | 0)) {
                const exists = state.allConvs.find(c => (c.id | 0) === (last.convId | 0));
                if (exists) { await openConversation(exists.id); return; }
            }
        })();

        /* ---------------- recording impl ---------------- */
        async function startRecording() {
            if (state.recording.active) return;
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const rec = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus', bitsPerSecond: 48000 });
            state.recording = { active: true, chunks: [], size: 0, rec, warnShown: false };

            rec.ondataavailable = (e) => {
                if (!e.data || !e.data.size) return;
                state.recording.chunks.push(e.data); state.recording.size += e.data.size;
                if (!state.recording.warnShown && state.recording.size > 850 * 1024) { recWarn.style.display = ''; recWarn.textContent = 'Approaching 1MB limit…'; state.recording.warnShown = true; }
                if (state.recording.size > 990 * 1024) { stopRecording(true); }
            };
            rec.onstop = async () => {
                recWarn.style.display = 'none';
                const blob = new Blob(state.recording.chunks, { type: 'audio/webm;codecs=opus' });
                try { stream.getTracks().forEach(t => t.stop()); } catch { }
                if (!blob.size) { state.recording = { active: false, chunks: [], size: 0, rec: null, warnShown: false }; return; }
                try {
                    const ab = await blob.arrayBuffer();
                    const { buf, encoding } = await gzipBytes(new Uint8Array(ab));
                    if (buf.length > MAX) throw new Error('Voice message too large');
                    addPendingFile({ name: 'voice.webm', type: 'audio/webm', buf, size: buf.length, encoding });
                } catch (e) { alert(e.message || e); }
                state.recording = { active: false, chunks: [], size: 0, rec: null, warnShown: false };
            };
            rec.start(200);
        }
        function stopRecording(force = false) {
            const r = state.recording.rec;
            if (r && r.state !== 'inactive') { try { r.stop(); } catch { } }
            state.recording.active = false;
            if (force) recWarn.textContent = 'Stopped to keep under 1MB.';
        }
    })();
</script>
