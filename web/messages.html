<!doctype html>
<meta charset="utf-8">
<title>Messages</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/web/site.css">

<style>
    :root {
        color-scheme: dark;
        --bg: #0a0b0d;
        --panel: #0e1116;
        --panel-2: #12161c;
        --border: #e6e6e6;
        --soft: rgba(255,255,255,.12);
        --text: #fff;
        --muted: #b8b8b8;
        --bw: 2px;
    }

    /* Font */
    @font-face {
        font-family: 'Voice1';
        src: url('/fonts/Voice1.woff2') format('woff2'), url('/fonts/Voice1.woff') format('woff'), url('/fonts/Voice1.ttf') format('truetype');
        font-weight: 100 900;
        font-style: normal;
        font-display: swap;
    }

    html, body {
        font-family: 'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
    }

    *, :before, :after {
        border-radius: 0 !important;
        box-sizing: border-box;
    }

    input, textarea, button, select {
        font-family: 'Voice1','Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif !important;
        -webkit-appearance: none;
        appearance: none;
        color: var(--text);
        border: var(--bw) solid var(--border);
        background: #0e1116;
    }

    ::placeholder {
        color: var(--muted);
        opacity: 1;
    }

    body {
        margin: 0;
        color: var(--text);
        background: #0a0b0d;
        height: 100vh;
        overflow: hidden;
    }

    .wrap {
        height: 100vh;
        display: grid;
        grid-template-columns: 320px 1fr;
    }

    /* LEFT */
    .left {
        background: linear-gradient(180deg,#12161c,#0e1116);
        border-right: var(--bw) solid var(--border);
        display: grid;
        grid-template-rows: auto auto 1fr;
        min-height: 0;
    }

        .left .head {
            padding: 12px 14px;
            border-bottom: var(--bw) solid var(--border);
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .left .tools {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: var(--bw) solid var(--border);
        }

    #convs {
        overflow: auto;
        padding-bottom: 10px;
    }

    .search-input {
        width: 100%;
        height: 40px;
        padding: 9px 12px;
        border: var(--bw) solid var(--border);
        background: #0e1116;
        color: #fff;
        box-shadow: 0 1px 0 var(--soft) inset;
    }

    .btn {
        padding: 10px 14px;
        border: var(--bw) solid var(--border);
        background: #0e1116;
        color: #fff;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 1px 0 var(--soft) inset;
        line-height: 1;
        white-space: nowrap;
    }

        .btn[disabled] {
            opacity: .5;
            cursor: not-allowed;
        }

        .btn:hover {
            background: #fff !important;
            color: #000;
            border-color: #fff;
        }

    .iconbtn {
        border: var(--bw) solid var(--border);
        background: #0e1116;
        cursor: pointer;
        opacity: .9;
        display: grid;
        place-items: center;
        width: 38px;
        height: 38px;
    }

        .iconbtn:hover {
            background: #151921;
        }

        .iconbtn img {
            width: 22px;
            height: 22px;
            display: block;
            image-rendering: pixelated;
        }

    .conv {
        display: grid;
        grid-template-columns: 44px 1fr;
        gap: 10px;
        padding: 10px 12px;
        border-bottom: 1px solid var(--soft);
        cursor: pointer;
    }

        .conv:hover {
            background: rgba(255,255,255,.06);
        }

        .conv.active {
            background: rgba(255,255,255,.10);
            outline: 2px solid #fff;
        }

    .avatar {
        width: 44px;
        height: 44px;
        border: 2px solid #fff;
        background: #000;
        object-fit: cover;
    }

    .conv .name {
        font-weight: 700;
    }

    .conv .preview {
        color: var(--muted);
        font-size: 13px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    /* RIGHT */
    .right {
        display: grid;
        grid-template-rows: auto 1fr auto;
        min-height: 0;
        position: relative;
    }

    .chat-head {
        padding: 10px 14px;
        border-bottom: var(--bw) solid var(--border);
        background: linear-gradient(180deg,#12161c,#0e1116);
        display: flex;
        align-items: center;
        gap: 10px;
        position: relative;
    }

        .chat-head .spacer {
            flex: 1;
        }

    .chat-pfp {
        width: 28px;
        height: 28px;
        border: var(--bw) solid var(--border);
        object-fit: cover;
        background: #000;
    }

    .chat-title {
        font-weight: 700;
    }

    /* 3-dots menu */
    .menu {
        position: absolute;
        right: 10px;
        top: 48px;
        background: var(--panel);
        border: var(--bw) solid var(--border);
        box-shadow: 0 8px 18px rgba(0,0,0,.35);
        padding: 6px;
        display: none;
        min-width: 220px;
        z-index: 20;
    }

        .menu .item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .menu .item:hover {
                background: rgba(255,255,255,.06);
            }

    .msgs {
        background: #000;
        padding: 12px 14px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-height: 0;
        position: relative; /* ⬅️ add */
    }

    #pad-top, #pad-bottom {
        height: 0;
    }

    .msg {
        max-width: 70%;
        padding: 10px 12px;
        margin: 0;
        border: var(--bw) solid var(--border);
        background: #0b0e12;
        box-shadow: 0 1px 0 var(--soft) inset;
        word-break: break-word;
        overflow-wrap: anywhere;
    }

        .msg > div {
            white-space: pre-wrap;
        }

    .me {
        align-self: flex-end;
        background: #0f1216;
    }

    /* system/command message */
    .sysmsg {
        align-self: center;
        max-width: 84%;
        border: none;
        background: transparent;
        box-shadow: none;
        color: var(--muted);
        font-style: italic;
        text-align: center;
        padding: 6px 8px;
    }

    .meta {
        color: var(--muted);
        font-size: 12px;
        margin-top: 4px;
    }

    .att {
        margin-top: 6px;
    }

    .composer {
        border-top: var(--bw) solid var(--border);
        background: #0b0e12;
        padding: 10px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
    }

        .composer > * {
            min-width: 0;
        }

        .composer textarea {
            width: 100%;
            min-height: 48px;
            max-height: 200px;
            resize: vertical;
            background: #0e1116;
            color: #fff;
            border: var(--bw) solid var(--border);
            padding: 12px;
            caret-color: #fff;
            line-height: 1.25;
        }

    .col {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        flex-wrap: wrap;
    }

    .chips {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 6px;
    }

    .chip {
        display: flex;
        align-items: center;
        gap: 6px;
        border: 1px solid var(--soft);
        padding: 6px 8px;
        font-size: 13px;
    }

        .chip .x {
            cursor: pointer;
            opacity: .85;
        }

    .warn {
        color: #ffdb74;
        font-size: 12px;
    }

    .jump {
        position: sticky; /* ⬅️ sits within the scroller */
        bottom: 12px; /* ⬅️ floats just above the bottom edge */
        align-self: center; /* ⬅️ centers horizontally in the flex column */
        opacity: 0;
        pointer-events: none;
        transition: opacity .18s ease;
        z-index: 5;
    }

        .jump.show {
            pointer-events: auto;
        }

    @media (max-width:520px) {
        .msg {
            max-width: 100%;
        }
    }

    /* Overlay */
    .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
    }

    .sheet {
        width: min(720px,94vw);
        max-height: 82vh;
        overflow: auto;
        background: linear-gradient(180deg,var(--panel-2),var(--panel));
        border: var(--bw) solid var(--border);
        box-shadow: 0 8px 18px rgba(0,0,0,.35);
        padding: 12px;
    }

        .sheet h3 {
            margin: 0 0 10px;
        }

    .picker-bar {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin-bottom: 10px;
    }

    .list {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
    }

    .person {
        display: grid;
        grid-template-columns: 44px 1fr auto;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border: var(--bw) solid var(--border);
        background: #0c0f13;
        box-shadow: 0 1px 0 var(--soft) inset;
        cursor: pointer;
    }

    .pfp {
        width: 44px;
        height: 44px;
        border: 2px solid #fff;
        background: #000;
        object-fit: cover;
    }

    .person .name {
        font-weight: 700;
    }

    .person .bio {
        color: var(--muted);
        font-size: 13px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    .sheet .bottom-center {
        position: sticky;
        bottom: 0;
        display: flex;
        align-items: center;
        gap: 10px;
        padding-top: 10px;
        margin-top: 10px;
        background: linear-gradient(180deg,transparent,rgba(0,0,0,.35));
    }

    /* Checkbox — white hollow square when off; filled white when on */
    .checkbox {
        appearance: none;
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border: 2px solid #fff;
        background: transparent;
        display: inline-block;
        vertical-align: middle;
        margin: 0;
        cursor: pointer;
    }

        .checkbox:hover:not(:checked) {
            opacity: .5;
        }
        /* 50% opacity on hover when not selected */
        .checkbox:checked {
            background: #fff;
        }
        /* filled white square when checked */
        .checkbox:disabled {
            opacity: .3;
            cursor: not-allowed;
        }

        .checkbox:focus-visible {
            outline: 2px solid #fff;
            outline-offset: 2px;
        }

    .avatar, .pfp, .chat-pfp {
        border-radius: 999px !important;
        aspect-ratio: 1 / 1;
        object-fit: cover;
    }

        /* Default group icon tint helper */
        .chat-pfp.tinted-default {
            box-shadow: 0 0 0 2px var(--gc, #fff) inset;
        }

    /* chips row in picker footer */
    #selected-chips {
        flex: 1;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
    }

    /* === Restyle Group editor (scoped) === */
    #restyle-overlay .editor {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
    }

    #restyle-overlay .stage {
        background: #0d1520;
        border: 1px dashed #2a3646;
        border-radius: 12px;
        display: grid;
        place-items: center;
        padding: 10px;
        position: relative;
    }

        #restyle-overlay .stage canvas {
            width: 100%;
            max-width: 480px;
            background: transparent;
        }

    #restyle-overlay .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }

        #restyle-overlay .controls .ctl {
            background: #0d1520;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px;
        }

        #restyle-overlay .controls input[type="range"] {
            width: 100%;
        }

    #restyle-overlay .file-row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
    }

    #restyle-overlay label.pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 6px 10px;
        border-radius: 999px;
        background: #0d1520;
        border: 1px solid var(--border);
        cursor: pointer;
    }

    #restyle-overlay .pf-preview {
        display: grid;
        grid-template-columns: 88px auto;
        gap: 12px;
        align-items: center;
        background: #0d1520;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 10px;
    }

        #restyle-overlay .pf-preview .thumb {
            width: 88px;
            height: 88px;
            border-radius: 50%;
            overflow: hidden;
            background: #0e1622;
            border: var(--bw) solid #fff; /* thicker white ring like profile */
            display: grid;
            place-items: center;
        }

        #restyle-overlay .pf-preview img {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
</style>

<div class="wrap">
    <aside class="left">
        <div class="head">Direct Messages</div>
        <div class="tools">
            <input id="conv-q" class="search-input" placeholder="Search conversations…">
            <button id="btn-newdm" class="iconbtn" title="Start a conversation"><img src="/web/icons/new-dm.png" alt="+"></button>
            <button id="btn-newgroup" class="iconbtn" title="Create a group"><img src="/web/icons/new-group.png" alt="◎"></button>
        </div>
        <div id="convs"></div>
    </aside>

    <main class="right">
        <div class="chat-head">
            <img id="chat-pfp" class="chat-pfp" src="/web/default-avatar.png" alt="">
            <div class="chat-title" id="chat-title">Pick a conversation</div>
            <div class="spacer"></div>
            <button id="chat-menu-btn" class="iconbtn" title="Options">⋮</button>
            <div id="chat-menu" class="menu"></div>
        </div>

        <div class="msgs" id="msgs">
            <div id="pad-top"></div>
            <button id="jump" class="jump btn" style="display:none">Jump to present ↓</button>
            <div id="pad-bottom"></div>
        </div>

        <div class="composer">
            <div>
                <textarea id="text" maxlength="10000" placeholder="Message…"></textarea>
                <div class="chips" id="att-chips"></div>
                <div class="warn" id="rec-warn" style="display:none"></div>
            </div>
            <div class="col">
                <button class="btn" id="btn-attach">Attach</button>
                <button class="btn" id="btn-voice">Hold to record</button>
                <button class="btn" id="btn-send">Send</button>
                <input type="file" id="file" multiple style="display:none">
            </div>
        </div>
    </main>
</div>

<!-- People picker overlay (DM / group create / edit / view) -->
<div id="overlay" class="overlay" role="dialog" aria-modal="true">
    <div class="sheet" id="sheet">
        <h3 id="sheet-title">Start a conversation</h3>
        <div class="picker-bar">
            <input id="user-q" class="search-input" placeholder="Search friends…">
        </div>
        <div id="user-list" class="list"></div>
        <div class="bottom-center" id="group-cta" style="display:none">
            <div id="selected-chips"></div>
            <div style="display:flex; gap:8px;">
                <button class="btn" id="btn-cancel">Cancel</button>
                <button class="btn" id="btn-group-submit" disabled>Create Group</button>
            </div>
        </div>
    </div>
</div>

<script>
    (() => {
        const API = 'http://localhost:3000/api';
        const $ = id => document.getElementById(id);

        /* ---------------- state ---------------- */
        const state = {
            convId: null, meId: 0,
            allConvs: [], filteredConvs: [],
            lastMsgId: 0, oldestMsgId: null, nextBefore: null,
            es: null, poll: null,
            uploading: false,
            pendingFiles: [],
            recording: { active: false, chunks: [], size: 0, rec: null, warnShown: false },

            // convo + meta
            convMeta: new Map(),         // convId -> { name, photo, is_group, color }
            convRowEls: new Map(),       // convId -> DOM div.conv
            convUserOg: new Map(),       // convId -> other @username (1:1)
            userCache: new Map(),        // og -> { username, photo, display_name, raw }
            convItems: new Map(),        // convId -> raw item

            // group/menu
            convDetailById: new Map(),
            currentConvDetail: null,     // {id,is_group,title,owner_id,is_owner,members:[]}
            pickerMode: 'dm',            // 'dm' | 'group-create' | 'group-edit' | 'view-members'
            selectedIds: new Set(),      // picked user_ids (others)
            initialSelectedIds: new Set(),
            friendsCache: [],
            idToFriend: new Map(),

            renderedMsgIds: new Set(),
            fetchingAfter: false,
            meSlug: '',
        };

        const LASTDM_KEY = 'dp:lastdm';
        const META_CACHE_KEY = 'dp:metaCache';
        let _metaSaveTimer = null;

        /* ---------------- defaults & helpers ---------------- */
        const DEFAULT_PFP_DM = '/web/default-avatar.png';
        const DEFAULT_PFP_GROUP = '/web/default-groupavatar.png';

        const GROUP_COLORS = [
            { key: 'blue', val: '#3b82f6' },
            { key: 'green', val: '#22c55e' },
            { key: 'purple', val: '#a855f7' },
            { key: 'orange', val: '#f97316' },
            { key: 'pink', val: '#ec4899' },
            { key: 'teal', val: '#14b8a6' },
            { key: 'yellow', val: '#eab308' },
            { key: 'red', val: '#ef4444' },
        ];
        function randomGroupColor() { return GROUP_COLORS[(Math.random() * GROUP_COLORS.length) | 0]; }

        const afterPaint = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        function esc(s) { return String(s || '').replace(/[&<>]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m])) }
        function fmt(t) { try { return new Date(t).toLocaleString() } catch { return '' } }
        function saveLastDM() { try { localStorage.setItem(LASTDM_KEY, JSON.stringify({ meId: state.meId | 0, convId: state.convId | 0, at: Date.now() })) } catch { } }
        function loadLastDM() { try { return JSON.parse(localStorage.getItem(LASTDM_KEY) || 'null') } catch { return null } }
        function nearBottom(px = 60) { const el = $('msgs'); return (el.scrollHeight - el.scrollTop - el.clientHeight) < px }
        function scrollToBottom() { const el = $('msgs'); el.scrollTop = el.scrollHeight + 9999 }

        const pickDisplay = o => o?.display_name || o?.name || null;
        const pickUsername = o => o?.first_username || o?.username || o?.handle || null;
        const pickPhoto = o => o?.profile_photo || o?.profile_photo_url || o?.photo || o?.photo_url || o?.avatar || o?.avatar_url || o?.picture || o?.image || o?.image_url || null;
        const pickName = o => o?.display_name || o?.name || o?.username || o?.first_username || o?.handle || o?.title || null;

        function saveMetaCache() {
            const out = {
                convUserOg: Array.from(state.convUserOg.entries()),
                userCache: Array.from(state.userCache.entries()),
                convMeta: Array.from(state.convMeta.entries()),
            };
            try { localStorage.setItem(META_CACHE_KEY, JSON.stringify(out)); } catch { }
        }
        function scheduleSaveMeta() {
            clearTimeout(_metaSaveTimer);
            _metaSaveTimer = setTimeout(saveMetaCache, 120);
        }
        function loadMetaCache() {
            try {
                const j = JSON.parse(localStorage.getItem(META_CACHE_KEY) || 'null');
                if (!j) return;
                (j.convUserOg || []).forEach(([k, v]) => state.convUserOg.set(+k || k, v));
                (j.userCache || []).forEach(([k, v]) => state.userCache.set(k, v));
                (j.convMeta || []).forEach(([k, v]) => state.convMeta.set(+k || k, v));
            } catch { }
        }

        /* ---------------- API core ---------------- */
        async function api(path, opts = {}) {
            const headers = Object.assign({ 'Accept': 'application/json' }, opts.headers || {});
            const isJSON = opts.body && !(opts.body instanceof FormData);
            if (isJSON && !headers['Content-Type']) headers['Content-Type'] = 'application/json';
            const url = API + path;
            const r = await fetch(url, { credentials: 'include', method: opts.method || 'GET', headers, body: isJSON ? JSON.stringify(opts.body) : opts.body });
            const t = await r.text(); let d; try { d = t ? JSON.parse(t) : {} } catch { d = { raw: t } }
            if (!r.ok) { const e = new Error(d?.error || r.statusText); e.status = r.status; e.detail = d?.detail || t; throw e; }
            return d;
        }
        async function getMe() {
            const j = await api('/auth/me');
            state.meId = j?.user?.id || 0;
            state.meSlug = j?.user?.first_username || j?.user?.username || '';
            return state.meId;
        }

        /* ---------------- meta resolution ---------------- */
        async function fetchConvMeta(id) {
            const prev = state.convMeta.get(id);
            try {
                const j = await api(`/dm/conversations/${id}`);

                // Build meta for the left list/top bar
                let meta = { name: 'Direct Message', photo: DEFAULT_PFP_DM, is_group: !!j.is_group, color: (j.color || null) };
                if (j.is_group) {
                    if ((j.title || '').trim()) meta.name = j.title.trim();
                    meta.photo = j.photo || j.avatar || DEFAULT_PFP_GROUP;
                    meta.color = j.color || meta.color || '#ffffff';
                } else {
                    const other = j.other || (Array.isArray(j.members) ? j.members.find(u => (u.id | 0) !== (state.meId | 0)) : null);
                    meta.name = pickName(other) || meta.name;
                    meta.photo = pickPhoto(other) || DEFAULT_PFP_DM;
                }

                // Stable detail object
                const detail = {
                    id: j.id,
                    is_group: !!j.is_group,
                    title: j.title || null,
                    owner_id: j.owner_id || null,
                    is_owner: !!j.is_owner,
                    members: j.members || []
                };

                state.convDetailById.set(id, detail);
                if ((state.convId | 0) === (id | 0)) state.currentConvDetail = detail;

                // Merge/display meta
                const best = { ...(prev || {}), ...meta };
                state.convMeta.set(id, best);
                if ((state.convId | 0) === (id | 0)) updateEverywhere(id);
                return best;
            } catch (e) {
                if (prev) return prev;
                const fallback = { name: 'Direct Message', photo: DEFAULT_PFP_DM, is_group: false };
                state.convMeta.set(id, fallback);
                return fallback;
            }
        }

        function setConvMeta(id, meta) {
            const prev = state.convMeta.get(id) || {};
            const next = { ...prev, ...meta };
            state.convMeta.set(id, next);
            updateEverywhere(id);
            scheduleSaveMeta();
        }

        function setImgSafe(img, src, fallback = DEFAULT_PFP_DM) {
            if (!img) return;
            const want = src || fallback;
            if (img.dataset.srcApplied === want) return;
            img.onerror = () => { img.src = fallback; img.dataset.srcApplied = fallback; };
            img.src = want; img.dataset.srcApplied = want;
        }

        function updateTopBar(meta) {
            if (!meta) return;
            $('chat-title').textContent = meta.name || 'Direct Message';
            const pfp = $('chat-pfp');
            setImgSafe(pfp, meta.photo, meta?.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM);
            if (meta.is_group) {
                const gc = meta.color || '#ffffff';
                pfp.style.borderColor = gc;
                pfp.style.setProperty('--gc', gc);
                const isDefaultGroup = (meta.photo === DEFAULT_PFP_GROUP);
                pfp.classList.toggle('tinted-default', isDefaultGroup);
                pfp.style.background = isDefaultGroup ? gc : '#000';
            } else {
                pfp.style.borderColor = 'var(--border)';
                pfp.classList.remove('tinted-default');
                pfp.style.background = '#000';
            }
            renderChatMenu();
        }

        function updateEverywhere(id) {
            const meta = state.convMeta.get(id);
            if (!meta) return;
            const row = state.convRowEls.get(id);
            if (row) setConvRowContent(row, meta, row.querySelector('.preview')?.textContent || '');
            if (state.convId === id) updateTopBar(meta);
        }

        function setConvRowContent(row, meta, preview) {
            const photo = meta?.photo || (meta?.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM);
            const border = meta?.is_group ? (meta?.color || '#fff') : '#fff';
            row.innerHTML = `
            <img class="avatar ${photo === DEFAULT_PFP_GROUP ? 'tinted-default' : ''}" src="${photo}" alt="" style="border-color:${border}; background:${photo === DEFAULT_PFP_GROUP ? border : '#000'}">
            <div>
                <div class="name">${esc(meta?.name || 'Direct Message')}</div>
                <div class="preview">${esc(preview || '…')}</div>
            </div>`;
        }

        function applySelectedHighlight() {
            document.querySelectorAll('.conv.active').forEach(el => el.classList.remove('active'));
            const el = state.convRowEls.get(state.convId);
            if (el) el.classList.add('active');
        }

        /* OG extraction for 1:1 fallback */
        function extractOgFromConvDetail(j) {
            const direct = j?.other_username || j?.other?.first_username || j?.other?.username ||
                j?.with?.first_username || j?.with?.username || null;
            if (direct) return direct;
            const arr = j?.members || j?.participants || j?.users || j?.people || [];
            if (Array.isArray(arr) && arr.length) {
                const other = arr.find(p => {
                    const pid = (p?.id ?? p?.user?.id);
                    return pid == null || (pid | 0) !== (state.meId | 0);
                }) || arr[0];
                const u = other?.user || other || {};
                return pickUsername(u) || null;
            }
            return null;
        }

        async function fetchUserByOg(og) {
            if (!og) throw new Error('no-og');
            if (state.userCache.has(og)) return state.userCache.get(og);
            const tries = [
                `/users/${encodeURIComponent(og)}`,
                `/users/${encodeURIComponent(og)}?view=basic`,
                `/profiles/${encodeURIComponent(og)}`,
                `/users/by_username/${encodeURIComponent(og)}`,
                `/user/${encodeURIComponent(og)}`
            ];
            for (const path of tries) {
                try {
                    const j = await api(path);
                    const username = pickUsername(j) || og;
                    const photo = pickPhoto(j);
                    const display = pickDisplay(j);
                    const result = { username, photo, display_name: display, raw: j };
                    state.userCache.set(og, result);
                    scheduleSaveMeta();
                    return result;
                } catch { }
            }
            throw new Error('user-not-found:' + og);
        }
        function metaFromUser(u) {
            const nm = '@' + (u?.username || 'user');
            const ph = u?.photo || DEFAULT_PFP_DM;
            return { name: nm, photo: ph, is_group: false };
        }

        /* ---------------- conversations list ---------------- */
        function renderConvs(list) {
            const wrap = $('convs'); wrap.innerHTML = '';
            state.convRowEls.clear();
            list.forEach(it => {
                const row = document.createElement('div'); row.className = 'conv'; row.dataset.id = it.id;
                const defaultMeta = {
                    name: (it.is_group ? (it.title || 'Group') : (it.title || 'Direct Message')),
                    photo: it.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM,
                    is_group: !!it.is_group,
                    color: it.color || null
                };
                const meta = state.convMeta.get(it.id) || defaultMeta;
                row.onclick = () => openConversation(it.id, meta?.name || defaultMeta.name);
                setConvRowContent(row, meta, it.preview);
                state.convRowEls.set(it.id, row);
                wrap.append(row);
                if (!state.convMeta.has(it.id)) state.convMeta.set(it.id, defaultMeta);
                // Background hydrate
                if (!state.convMeta.has(it.id)) fetchConvMeta(it.id).catch(() => { });
            });
            applySelectedHighlight();
        }
        function applyConvFilter() {
            const q = $('conv-q').value.trim().toLowerCase();
            state.filteredConvs = !q ? [...state.allConvs]
                : state.allConvs.filter(c => {
                    const name = (state.convMeta.get(c.id)?.name || c.title || 'Direct Message').toLowerCase();
                    return name.includes(q) || (c.preview || '').toLowerCase().includes(q);
                });
            renderConvs(state.filteredConvs);
        }
        async function loadConversations({ blockingMeta = false } = {}) {
            const j = await api('/dm/conversations');
            state.allConvs = j.items || [];
            state.allConvs.forEach(it => state.convItems.set(it.id, it));

            // Pre-seed meta
            for (const it of state.allConvs) {
                if (!state.convMeta.has(it.id)) {
                    let meta = {
                        name: it.is_group ? (it.title || 'Group') : 'Direct Message',
                        photo: it.is_group ? DEFAULT_PFP_GROUP : DEFAULT_PFP_DM,
                        is_group: !!it.is_group,
                        color: it.color || null
                    };

                    if (!it.is_group) {
                        let og = state.convUserOg.get(it.id) || extractOgFromConvDetail(it);
                        if (og) {
                            state.convUserOg.set(it.id, og);
                            meta.name = '@' + og;
                            const cached = state.userCache.get(og);
                            if (cached?.photo) meta.photo = cached.photo;
                            scheduleSaveMeta();
                        }
                    }
                    state.convMeta.set(it.id, meta);
                }
            }
            scheduleSaveMeta();

            if (blockingMeta) {
                await Promise.allSettled(
                    state.allConvs.map(it => fetchConvMeta(it.id))
                );
            } else {
                state.allConvs.forEach(it => {
                    if (!state.convMeta.has(it.id)) fetchConvMeta(it.id).catch(() => { });
                });
            }
            renderConvs(state.allConvs);
        }
        $('conv-q').addEventListener('input', applyConvFilter);

        /* ---------------- virtualization ---------------- */
        const MAX_DOM = 140, GAP = 6;
        let bottomPadPx = 0, removedBottom = [];
        function setBottomPad(px) { bottomPadPx = Math.max(0, px | 0); $('pad-bottom').style.height = bottomPadPx + 'px'; }

        function renderMessage(m) {
            const isSystem = (m.kind === 'system');
            const wrap = document.createElement('div');
            wrap.className = (isSystem ? 'msg sysmsg' : ('msg' + (m.sender_id === state.meId ? ' me' : '')));
            if (m.text) wrap.insertAdjacentHTML('beforeend', '<div>' + esc(m.text) + '</div>');
            if (!isSystem) {
                (m.attachments || []).forEach(a => {
                    const url = `${API}/dm/attachments/${a.id}/download?inline=1`;
                    let v = '';
                    if ((a.mime_type || '').startsWith('image/')) v = `<img class="att" src="${url}" style="max-width:420px;display:block">`;
                    else if ((a.mime_type || '').startsWith('video/')) v = `<video class="att" src="${url}" controls style="max-width:420px;display:block"></video>`;
                    else if ((a.mime_type || '').startsWith('audio/')) v = `<audio class="att" src="${url}" controls></audio>`;
                    else v = `<a class="att" href="${url}">📎 ${esc(a.filename)}</a>`;
                    wrap.insertAdjacentHTML('beforeend', v);
                });
                wrap.insertAdjacentHTML('beforeend', `<div class="meta">${m.created_at ? fmt(m.created_at) : ''}</div>`);
            }
            wrap.querySelectorAll('img').forEach(img => img.addEventListener('load', () => { if (nearBottom(200)) scrollToBottom(); }, { once: true }));
            wrap.querySelectorAll('video').forEach(v => v.addEventListener('loadedmetadata', () => { if (nearBottom(200)) scrollToBottom(); }, { once: true }));
            return wrap;
        }

        function appendMessagesAscending(items) {
            items = (items || []).filter(m => !state.renderedMsgIds.has(m.id));
            const anchor = $('pad-bottom');
            items.forEach(m => {
                state.renderedMsgIds.add(m.id);
                const el = renderMessage(m);
                anchor.before(el);
                state.oldestMsgId = state.oldestMsgId === null ? m.id : Math.min(state.oldestMsgId, m.id);
                state.lastMsgId = Math.max(state.lastMsgId, m.id);
            });
            maybeTrimBottom();
        }
        function prependOlderAscending(items) {
            items = (items || []).filter(m => !state.renderedMsgIds.has(m.id));
            if (!items.length) return;
            const box = $('msgs');
            const prevTop = box.scrollTop, prevH = box.scrollHeight;
            const frag = document.createDocumentFragment();
            items.forEach(m => {
                state.renderedMsgIds.add(m.id);
                frag.append(renderMessage(m));
                state.oldestMsgId = state.oldestMsgId === null ? m.id : Math.min(state.oldestMsgId, m.id);
                state.lastMsgId = Math.max(state.lastMsgId, m.id);
            });
            const afterTop = $('pad-top').nextSibling || $('pad-bottom');
            box.insertBefore(frag, afterTop);
            box.scrollTop = prevTop + (box.scrollHeight - prevH);
            maybeTrimBottom();
        }
        function maybeTrimBottom() {
            const box = $('msgs');
            if (nearBottom(200)) return;
            while (true) {
                const last = $('pad-bottom').previousElementSibling;
                if (!last || !last.classList.contains('msg')) break;
                const count = box.querySelectorAll('.msg').length;
                if (count <= MAX_DOM) break;
                const h = last.offsetHeight + GAP;
                removedBottom.push({ el: last, h });
                last.remove(); setBottomPad(bottomPadPx + h);
            }
        }
        function maybeRestoreBottom(chunk = 24) {
            if (!removedBottom.length) return;
            const box = $('msgs'); const dist = (box.scrollHeight - box.clientHeight - box.scrollTop);
            if (dist > 1200) return;
            let n = 0; while (removedBottom.length && n < chunk) {
                const { el, h } = removedBottom.pop();
                $('pad-bottom').before(el); setBottomPad(bottomPadPx - h); n++;
            }
        }

        const jumpBtn = (() => {
            const el = $('jump');
            function sync() { if (nearBottom(120)) { el.classList.remove('show'); el.style.display = 'none'; } else { el.style.display = ''; el.classList.add('show'); } }
            el.addEventListener('click', () => { while (removedBottom.length) { const { el: n, h } = removedBottom.pop(); $('pad-bottom').before(n); setBottomPad(bottomPadPx - h); } scrollToBottom(); sync(); });
            return { sync };
        })();

        /* ---------------- open/paging/realtime ---------------- */
        async function openConversation(id) {
            if (state.es) { try { state.es.close(); } catch { } state.es = null; }
            if (state.poll) { clearInterval(state.poll); state.poll = null; }

            state.convId = id; saveLastDM();
            state.currentConvDetail = state.convDetailById.get(id) || null;
            applySelectedHighlight();

            if (!state.convMeta.has(id)) {
                const seedItem = state.convItems.get(id) || {};
                state.convMeta.set(id, { name: seedItem.title || 'Direct Message', photo: DEFAULT_PFP_DM, is_group: !!seedItem.is_group, color: seedItem.color || null });
            }
            updateEverywhere(id); // force header to current chat

            // hydrate meta & detail
            fetchConvMeta(id).catch(() => { });

            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
            state.renderedMsgIds.clear();
            setBottomPad(0); removedBottom = []; state.lastMsgId = 0; state.oldestMsgId = null; state.nextBefore = null;

            const j = await api(`/dm/conversations/${id}/messages?limit=30`);
            appendMessagesAscending(j.items || []);
            state.nextBefore = j.next_before;

            try { await (document.fonts && document.fonts.ready); } catch { }
            await afterPaint(); await afterPaint();
            scrollToBottom();

            jumpBtn.sync();
            openStream(id);
            startCatchup();
        }

        $('msgs').addEventListener('scroll', async () => {
            jumpBtn.sync(); maybeRestoreBottom();
            const box = $('msgs');
            if (box.scrollTop <= 20 && state.nextBefore) {
                const j = await api(`/dm/conversations/${state.convId}/messages?before=${state.nextBefore}&limit=20`);
                prependOlderAscending(j.items || []); state.nextBefore = j.next_before;
            }
        });

        function openStream(id) {
            const es = new EventSource(`${API}/dm/conversations/${id}/stream`, { withCredentials: true });
            state.es = es;
            es.addEventListener('new', async () => { await fetchAfter(state.lastMsgId); });
        }
        function startCatchup() { state.poll = setInterval(() => { fetchAfter(state.lastMsgId).catch(() => { }); }, 30000); }
        async function fetchAfter(lastId) {
            if (state.fetchingAfter) return;
            state.fetchingAfter = true;
            try {
                const j = await api(`/dm/conversations/${state.convId}/messages?after=${lastId}&limit=100`);
                if (!j.items || !j.items.length) return;

                const newOnes = j.items.filter(m => !state.renderedMsgIds.has(m.id));
                if (!newOnes.length) return;

                const stick = nearBottom(80);
                appendMessagesAscending(newOnes);
                if (stick) { await afterPaint(); scrollToBottom(); }
                loadConversations().catch(() => { });
                jumpBtn.sync();
            } finally {
                state.fetchingAfter = false;
            }
        }

        /* ---------------- attachments + voice ---------------- */
        const MAX = 1024 * 1024;
        const chips = $('att-chips'); const recWarn = $('rec-warn');

        function refreshChips() {
            chips.innerHTML = '';
            state.pendingFiles.forEach((f, i) => {
                const c = document.createElement('div'); c.className = 'chip';
                c.innerHTML = `<span>${esc(f.name)} · ${(f.size / 1024 | 0)} KB</span><span class="x">✕</span>`;
                c.querySelector('.x').onclick = () => { state.pendingFiles.splice(i, 1); refreshChips(); };
                chips.append(c);
            });
        }
        function addPendingFile(o) { state.pendingFiles.push(o); refreshChips(); }

        async function gzipBytes(uint8) {
            if (!('CompressionStream' in window)) return { buf: uint8, encoding: null };
            const cs = new CompressionStream('gzip'); const w = cs.writable.getWriter(); await w.write(uint8); await w.close();
            const res = await new Response(cs.readable).arrayBuffer(); return { buf: new Uint8Array(res), encoding: 'gzip' };
        }
        async function compressImage(file, maxSide = 1280, q = .75) {
            const img = await createImageBitmap(file);
            let { width: w, height: h } = img; const s = Math.min(1, maxSide / Math.max(w, h)); w = (w * s) | 0; h = (h * s) | 0;
            const canvas = new OffscreenCanvas(w, h); const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, w, h);
            let blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: q });
            while (blob.size > MAX && q > 0.4) { q -= 0.1; blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: q }); }
            if (blob.size > MAX) throw new Error('Image too large even after compression');
            return new Uint8Array(await blob.arrayBuffer());
        }
        async function compressGeneric(file) {
            const uint = new Uint8Array(await file.arrayBuffer());
            const { buf, encoding } = await gzipBytes(uint);
            if (buf.length > MAX) throw new Error('File too large after compression');
            return { buf, encoding };
        }
        async function handleFileInput(files) {
            for (const file of files) {
                try {
                    const type = (file.type || '').toLowerCase();
                    if (type.startsWith('image/')) {
                        const buf = await compressImage(file);
                        addPendingFile({ name: file.name.replace(/\.(png|webp|jpeg|jpg)$/i, '.jpg'), type: 'image/jpeg', buf, size: buf.length, encoding: null });
                    } else {
                        const { buf, encoding } = await compressGeneric(file);
                        addPendingFile({ name: (encoding === 'gzip' && !/\.gz$/i.test(file.name)) ? file.name + '.gz' : file.name, type: file.type || 'application/octet-stream', buf, size: buf.length, encoding });
                    }
                } catch (e) { alert(`${file.name}: ${e.message || e}`); }
            }
        }

        /* ---------------- overlay (friends / group create/edit/view) ---------------- */
        const overlay = $('overlay'), userList = $('user-list');

        async function fetchFriends() {
            let arr = [];
            try {
                const j1 = await api(`/users/me/friends`);
                arr = j1.items || j1.friends || [];
            } catch { }
            if ((!arr || !arr.length) && state.meSlug) {
                try {
                    const j2 = await api(`/users/${encodeURIComponent(state.meSlug)}/friends?offset=0&limit=500`);
                    arr = j2.items || j2.friends || [];
                } catch { }
            }
            const norm = (arr || []).map(u => {
                const nu = u.user || u;
                const id = nu.id ?? nu.user_id ?? nu.friend_id ?? null;
                const username = nu.username ?? nu.first_username ?? null;
                const first_username = nu.first_username ?? nu.username ?? null;
                const profile_photo = nu.profile_photo ?? null;
                const bio = nu.bio ?? nu.bio_html ?? '';
                return { id, username, first_username, profile_photo, bio };
            }).filter(x => x.id);
            return norm;
        }

        function friendDisplay(u) {
            const raw = u.display_name || u.name || u.first_username || u.username || 'User';
            return String(raw);
        }

        function refreshSelectedChips() {
            const chipBox = $('selected-chips'); chipBox.innerHTML = '';
            const ids = [...state.selectedIds];
            ids.forEach(uid => {
                const u = state.idToFriend.get(uid) || {};
                const label = friendDisplay(u);
                const el = document.createElement('div');
                el.className = 'chip';
                el.innerHTML = `<span>${esc(label)}</span><span class="x" title="Remove">✕</span>`;
                el.querySelector('.x').onclick = (e) => { e.stopPropagation(); state.selectedIds.delete(uid); renderFriends(state.friendsCache); refreshSelectedChips(); refreshGroupSubmitState(); };
                chipBox.append(el);
            });
        }

        function refreshGroupSubmitState() {
            const btn = $('btn-group-submit');
            const mode = state.pickerMode;
            if (mode === 'group-create') {
                btn.textContent = 'Create Group';
                btn.disabled = (state.selectedIds.size < 2);
            } else if (mode === 'group-edit') {
                btn.textContent = 'Save Changes';
                const total = 1 + state.selectedIds.size;
                const changed = !eqSets(state.selectedIds, state.initialSelectedIds);
                btn.disabled = !(changed && total >= 3);
            } else {
                btn.textContent = 'Close';
                btn.disabled = false;
            }
            $('group-cta').style.display = (mode === 'group-create' || mode === 'group-edit') ? '' : 'none';
        }

        function eqSets(a, b) { if (a.size !== b.size) return false; for (const v of a) if (!b.has(v)) return false; return true; }

        function renderFriends(list) {
            state.friendsCache = list || [];
            state.idToFriend.clear();
            list.forEach(u => state.idToFriend.set(u.id, u));

            userList.innerHTML = '';
            const q = $('user-q').value.trim().toLowerCase();
            let items = list.filter(u => {
                if (!q) return true;
                return (u.username || '').toLowerCase().includes(q) ||
                    (u.first_username || '').toLowerCase().includes(q) ||
                    (u.bio || '').toLowerCase().includes(q);
            });

            const mode = state.pickerMode;
            items.forEach(u => {
                const row = document.createElement('div'); row.className = 'person';
                const label = '@' + (u.username || u.first_username || 'user');
                const checked = state.selectedIds.has(u.id);

                let right = '';
                if (mode === 'dm') {
                    right = `<div class="act"><button class="btn person-message">Message</button></div>`;
                } else if (mode === 'group-create' || mode === 'group-edit') {
                    right = `<div class="act">
                    <input type="checkbox" class="checkbox person-check" ${checked ? 'checked' : ''}/>
                </div>`;
                } else {
                    right = `<div class="act"></div>`;
                }

                row.innerHTML = `
                <img class="pfp" src="${u.profile_photo || DEFAULT_PFP_DM}" alt="">
                <div>
                    <div class="name">${esc(label)}</div>
                    <div class="bio">${esc(u.bio || '')}</div>
                </div>
                ${right}
            `;

                if (mode === 'dm') {
                    row.onclick = (e) => { if (e.target.closest('.person-message')) return; startDmWith(u); };
                    row.querySelector('.person-message').onclick = async (e) => { e.stopPropagation(); await startDmWith(u); };
                } else if (mode === 'group-create' || mode === 'group-edit') {
                    const toggle = () => {
                        if (state.selectedIds.has(u.id)) state.selectedIds.delete(u.id);
                        else state.selectedIds.add(u.id);
                        renderFriends(state.friendsCache);
                        refreshSelectedChips();
                        refreshGroupSubmitState();
                    };
                    row.onclick = toggle;
                    const cb = row.querySelector('.person-check');
                    if (cb) cb.addEventListener('click', (e) => { e.stopPropagation(); toggle(); });
                } else {
                    row.onclick = () => { };
                }

                userList.append(row);
            });

            refreshSelectedChips();
        }

        async function openPicker(mode = 'dm', opts = {}) {
            state.pickerMode = mode;
            state.selectedIds = new Set(opts.preselectIds || []);
            state.initialSelectedIds = new Set(opts.preselectIds || []);
            $('overlay').style.display = 'flex';
            $('user-q').value = '';
            $('sheet-title').textContent =
                mode === 'dm' ? 'Start a conversation'
                    : mode === 'group-create' ? 'Create a Group'
                        : mode === 'group-edit' ? 'Edit Group Members'
                            : 'Group Members';

            $('group-cta').style.display = (mode === 'group-create' || mode === 'group-edit') ? '' : 'none';
            refreshGroupSubmitState();

            const friends = await fetchFriends();
            renderFriends(friends);
        }
        function closePicker() { $('overlay').style.display = 'none'; }

        $('btn-newdm').onclick = () => openPicker('dm');
        $('btn-newgroup').onclick = () => openPicker('group-create');

        overlay.addEventListener('click', e => { if (e.target === overlay) closePicker(); });
        document.addEventListener('keydown', e => { if (e.key === 'Escape') { closePicker(); hideChatMenu(); hideRestyle(); } });

        $('user-q').addEventListener('input', async () => renderFriends(state.friendsCache));
        $('btn-cancel').onclick = () => closePicker();

        $('btn-group-submit').onclick = async () => {
            if (state.pickerMode === 'group-create') {
                if (state.selectedIds.size < 2) return;
                const ids = [...state.selectedIds];
                const names = ids.map(id => friendDisplay(state.idToFriend.get(id)));
                const title = joinNames(names);
                try {
                    const rc = randomGroupColor();
                    const res = await api('/dm/conversations', { method: 'POST', body: { user_ids: ids, title, color: rc.val } });
                    closePicker();
                    await loadConversations({ blockingMeta: true });
                    if (res?.id) await openConversation(res.id);
                } catch (e) { alert(e.detail || e.message || e); }
            } else if (state.pickerMode === 'group-edit') {
                const detail = state.currentConvDetail || {};
                const before = new Set(state.initialSelectedIds);
                const after = new Set(state.selectedIds);
                const add = [...after].filter(x => !before.has(x));
                const remove = [...before].filter(x => !after.has(x));
                const total = 1 + after.size;
                if (total < 3 || (add.length === 0 && remove.length === 0)) return;
                try {
                    await api(`/dm/conversations/${state.convId}/members`, { method: 'PATCH', body: { add_user_ids: add, remove_user_ids: remove } });
                    closePicker();
                    await fetchConvMeta(state.convId);
                    await fetchAfter(state.lastMsgId);
                    await loadConversations({ blockingMeta: true });
                } catch (e) { alert(e.detail || e.message || e); }
            } else {
                closePicker();
            }
        };

        async function startDmWith(u) {
            try {
                const og = u.first_username || u.username;
                const res = await api(`/dm/with/${encodeURIComponent(og)}`, { method: 'POST' });
                closePicker(); await loadConversations({ blockingMeta: true });
                const cid = res?.conversation_id || res?.id;
                if (cid) {
                    const meta = { name: '@' + og, photo: u.profile_photo || DEFAULT_PFP_DM, is_group: false };
                    setConvMeta(cid, meta);
                    state.userCache.set(og, { username: og, photo: u.profile_photo || DEFAULT_PFP_DM, display_name: null, raw: u });
                    scheduleSaveMeta();
                    openConversation(cid);
                } else if (state.allConvs[0]) {
                    openConversation(state.allConvs[0].id);
                }
            } catch (e) { alert(e.message || e); }
        }

        /* ---------------- 3-dots chat menu ---------------- */
        const chatMenu = $('chat-menu');
        const chatMenuBtn = $('chat-menu-btn');

        function hideChatMenu() { chatMenu.style.display = 'none'; }
        function toggleChatMenu() {
            if (chatMenu.style.display === 'none' || !chatMenu.style.display) { renderChatMenu(); chatMenu.style.display = 'block'; }
            else chatMenu.style.display = 'none';
        }
        chatMenuBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleChatMenu(); });
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.menu') && e.target !== chatMenuBtn) hideChatMenu();
        });

        function renderChatMenu() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            const isGroup = !!det.is_group;
            const isOwner = !!det.is_owner;

            // Always show menu; content varies
            chatMenuBtn.style.display = '';

            const items = [];
            if (isGroup) {
                if (isOwner) {
                    items.push({ id: 'rename', label: 'Rename group' });
                    items.push({ id: 'manage', label: 'Manage members' }); // owner: remove + make owner
                } else {
                    items.push({ id: 'view-members', label: 'View members' });
                }
                items.push({ id: 'restyle', label: 'Restyle Group' }); // color + icon
                items.push({ id: 'leave', label: 'Leave group' });
                items.push({ id: 'block-group', label: 'Block this group' });
            } else {
                items.push({ id: 'delete-dm', label: 'Delete chat (for me)' });
                items.push({ id: 'block-user', label: 'Block user' });
            }

            chatMenu.innerHTML = items.map(i => `<div class="item" data-id="${i.id}">${esc(i.label)}</div>`).join('');

            chatMenu.querySelectorAll('.item').forEach(el => {
                el.onclick = async () => {
                    const id = el.dataset.id;
                    hideChatMenu();
                    if (id === 'rename') {
                        const current = state.currentConvDetail?.title || state.convMeta.get(state.convId)?.name || '';
                        const name = prompt('New group name:', current) || '';
                        const trimmed = name.trim();
                        if (!trimmed) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/title`, { method: 'PATCH', body: { title: trimmed } });
                            await fetchConvMeta(state.convId);
                            await fetchAfter(state.lastMsgId);
                            await loadConversations({ blockingMeta: true });
                            await afterPaint();
                            renderChatMenu();
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'manage') {
                        await openManageMembers();
                    } else if (id === 'view-members') {
                        state.pickerMode = 'view-members';
                        $('sheet-title').textContent = 'Group Members';
                        $('group-cta').style.display = 'none';
                        $('overlay').style.display = 'flex';
                        $('user-q').value = '';
                        const members = (state.currentConvDetail?.members || []).map(u => ({
                            id: u.id, username: u.username, first_username: u.first_username, profile_photo: u.profile_photo, bio: ''
                        }));
                        renderFriends(members);
                    } else if (id === 'restyle') {
                        openRestyleOverlay();
                    } else if (id === 'leave') {
                        if (!confirm('Leave this group?')) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/leave`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'block-group') {
                        if (!confirm('Block this group? You will also leave it and won’t be added again.')) return;
                        try {
                            await api(`/dm/conversations/${state.convId}/block`, { method: 'POST' });
                            await api(`/dm/conversations/${state.convId}/leave`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'delete-dm') {
                        if (!confirm('Delete this chat for you? The other person will still see it.')) return;
                        try {
                            const my = state.meSlug || 'Someone';
                            await api(`/dm/conversations/${state.convId}/messages`, { method: 'POST', body: { text: `${my} deleted this chat.`, kind: 'system' } });
                            await api(`/dm/conversations/${state.convId}/delete_for_me`, { method: 'POST' });
                            state.convId = null; state.currentConvDetail = null;
                            $('chat-title').textContent = 'Pick a conversation';
                            $('chat-pfp').src = DEFAULT_PFP_DM;
                            $('msgs').innerHTML = '<div id="pad-top"></div><div id="pad-bottom"></div>';
                            await loadConversations({ blockingMeta: true });
                        } catch (e) { alert(e.detail || e.message || e); }
                    } else if (id === 'block-user') {
                        try {
                            const other = (state.currentConvDetail?.members || []).find(u => (u.id | 0) !== (state.meId | 0));
                            if (!other) { alert('Could not find user to block.'); return; }
                            await api(`/blocks/users`, { method: 'POST', body: { user_id: other.id } });
                            alert('User blocked.');
                        } catch (e) { alert(e.detail || e.message || e); }
                    }
                };
            });
        }

        /* ---------------- Manage members (owner only) ---------------- */
        async function openManageMembers() {
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            if (!det?.is_group || !det?.members?.length) return;
            state.pickerMode = 'view-members';
            $('sheet-title').textContent = 'Manage Group';
            $('group-cta').style.display = 'none';
            $('overlay').style.display = 'flex';
            $('user-q').value = '';
            const members = (det.members || []).map(u => ({
                id: u.id, username: u.username, first_username: u.first_username, profile_photo: u.profile_photo, bio: ''
            }));
            renderFriends(members);
            // Add action buttons to each member row
            Array.from(document.querySelectorAll('#user-list .person')).forEach((row, idx) => {
                const m = members[idx];
                const act = document.createElement('div');
                act.className = 'act';
                act.style.display = 'flex';
                act.style.gap = '8px';
                const makeOwner = document.createElement('button');
                makeOwner.className = 'btn';
                makeOwner.textContent = 'Make owner';
                makeOwner.onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        await api(`/dm/conversations/${state.convId}/owner`, { method: 'PATCH', body: { owner_id: m.id } });
                        await fetchConvMeta(state.convId);
                        await loadConversations({ blockingMeta: true });
                        alert('Owner updated.');
                    } catch (e) { alert(e.detail || e.message || e); }
                };
                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn';
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!confirm('Remove this person from the group?')) return;
                    try {
                        await api(`/dm/conversations/${state.convId}/members`, { method: 'PATCH', body: { add_user_ids: [], remove_user_ids: [m.id] } });
                        await fetchConvMeta(state.convId);
                        await loadConversations({ blockingMeta: true });
                        row.remove();
                    } catch (e) { alert(e.detail || e.message || e); }
                };
                act.append(makeOwner, removeBtn);
                row.append(act);
            });
        }

        /* ---------------- Restyle Group (color + icon) ---------------- */
        /* ---------------- Restyle Group (color + icon) ---------------- */
        let restyleEl = null;

        function ensureRestyle() {
            if (restyleEl) return restyleEl;
            restyleEl = document.createElement('div');
            restyleEl.id = 'restyle-overlay';
            restyleEl.className = 'overlay';
            restyleEl.innerHTML = `
    <div class="sheet" style="width:min(720px,94vw)">
      <h3>Restyle Group</h3>

      <div class="pf-preview">
        <div class="thumb"><img id="restyle-preview" alt="preview"></div>
        <div class="muted">PNG will be generated at up to <b>512px</b> (longest side). Final file must be ≤ <b>1&nbsp;MB</b>.</div>
      </div>

      <div class="file-row">
        <label class="pill">
          <span>Choose image</span>
          <input id="restyle-file" type="file" accept="image/png,image/jpeg,image/webp,image/gif,image/svg+xml" style="display:none">
        </label>
        <span class="muted">or drag & drop onto the canvas</span>
        <div id="restyle-filename" class="muted" style="font-size:13px"></div>
        <button class="btn" id="restyle-clear" type="button">Use default</button>
      </div>

      <div class="editor" style="margin-top:10px">
        <div class="stage" id="restyle-drop">
          <canvas id="restyle-canvas" width="320" height="320"></canvas>
        </div>

        <div class="controls">
          <div class="ctl">
            <div class="muted" style="margin-bottom:6px">Zoom</div>
            <input id="restyle-zoom" type="range" min="0" max="1" step="0.01" value="0.5">
          </div>
          <div class="ctl">
            <div class="muted" style="margin-bottom:6px">Rotate</div>
            <input id="restyle-rot" type="range" min="-180" max="180" step="1" value="0">
          </div>
        </div>

        <div class="actions">
          <button class="btn secondary" id="restyle-cancel" type="button">Cancel</button>
          <button class="btn" id="restyle-save" disabled>Save changes</button>
        </div>
        <div class="note">Tips: drag the image to reposition. Use zoom/rotate. Output is PNG with transparency preserved.</div>
      </div>
    </div>
  `;
            document.body.append(restyleEl);
            restyleEl.addEventListener('click', (e) => { if (e.target === restyleEl) hideRestyle(); });
            return restyleEl;
        }

        function hideRestyle() { if (restyleEl) restyleEl.style.display = 'none'; }

        function openRestyleOverlay() {
            const meta = state.convMeta.get(state.convId) || {};
            const det = state.currentConvDetail || state.convDetailById.get(state.convId) || {};
            if (!det.is_group) return;

            const el = ensureRestyle();
            el.style.display = 'flex';

            const preview = el.querySelector('#restyle-preview');
            const fileIn = el.querySelector('#restyle-file');
            const fileName = el.querySelector('#restyle-filename');
            const clearBtn = el.querySelector('#restyle-clear');
            const saveBtn = el.querySelector('#restyle-save');
            const cancelBtn = el.querySelector('#restyle-cancel');

            const colorBox = document.createElement('div');
            colorBox.style.display = 'flex';
            colorBox.style.gap = '8px';
            colorBox.style.flexWrap = 'wrap';
            colorBox.style.alignItems = 'center';
            colorBox.style.margin = '12px 0 0';
            colorBox.innerHTML = `<div style="font-weight:700">Color</div>`;
            // insert before editor
            el.querySelector('.editor').insertAdjacentElement('beforebegin', colorBox);

            const canvas = el.querySelector('#restyle-canvas');
            const ctx = canvas.getContext('2d');
            const drop = el.querySelector('#restyle-drop');
            const zoomEl = el.querySelector('#restyle-zoom');
            const rotEl = el.querySelector('#restyle-rot');

            // --- state ---
            let selectedColor = meta.color || '#ffffff';
            let selectedColorKey = (GROUP_COLORS.find(c => c.val === selectedColor)?.key) || null;

            let imgBitmap = null;
            let imgW = 0, imgH = 0;
            let pos = { x: 0, y: 0 };
            let dragging = false, last = { x: 0, y: 0 };
            let zoom = parseFloat(zoomEl.value);
            let rot = parseFloat(rotEl.value) * Math.PI / 180;
            let usingDefault = (meta.photo === DEFAULT_PFP_GROUP);
            let dirty = false;

            // --- color chips (exact look via existing .btn polish) ---
            GROUP_COLORS.forEach(c => {
                const b = document.createElement('button');
                b.type = 'button';
                b.className = 'btn';
                b.style.cssText = `border-color:${c.val};background:${c.val};color:#000`;
                b.textContent = c.key;
                b.onclick = () => {
                    selectedColor = c.val;
                    selectedColorKey = c.key;
                    paintPreview(); markDirty();
                };
                colorBox.append(b);
            });

            function setImgSafe(img, src, fallback) {
                img.onerror = () => { img.src = fallback; };
                img.src = src || fallback;
            }
            function paintPreview() {
                const isDefault = usingDefault && !imgBitmap;
                const fallback = DEFAULT_PFP_GROUP;
                const active = isDefault ? fallback : (meta.photo || fallback);
                setImgSafe(preview, active, fallback);
                preview.style.borderColor = selectedColor;
                preview.style.background = isDefault ? selectedColor : '#000';
            }
            function markDirty() { dirty = true; saveBtn.disabled = false; }
            paintPreview(); saveBtn.disabled = true;

            // --- draw current transform to editor canvas ---
            function scaleForZoom() { return 0.5 + zoom * 2.5; } // 0.5x..3x
            function redraw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!imgBitmap) return;
                ctx.save();
                ctx.translate(canvas.width / 2 + pos.x, canvas.height / 2 + pos.y);
                ctx.rotate(rot);
                const s = scaleForZoom();
                const dw = imgW * s, dh = imgH * s;
                ctx.drawImage(imgBitmap, -dw / 2, -dh / 2, dw, dh);
                ctx.restore();
            }

            // --- file -> bitmap ---
            function loadBitmapFromFile(file) {
                return new Promise((resolve, reject) => {
                    const r = new FileReader();
                    r.onload = async () => {
                        try {
                            const bmp = await createImageBitmap(new Blob([r.result]));
                            resolve(bmp);
                        } catch (e) { reject(e); }
                    };
                    r.onerror = () => reject(r.error);
                    r.readAsArrayBuffer(file);
                });
            }

            async function setImageFile(file) {
                if (!file) return;
                try {
                    imgBitmap = await loadBitmapFromFile(file);
                    imgW = imgBitmap.width; imgH = imgBitmap.height;
                    pos = { x: 0, y: 0 };
                    zoom = 0.5; zoomEl.value = '0.5';
                    rot = 0; rotEl.value = '0';
                    fileName.textContent = file.name;
                    usingDefault = false;
                    redraw();
                    const url = URL.createObjectURL(file);
                    preview.src = url; preview.style.background = '#000';
                    markDirty();
                } catch (e) { alert('Could not read image: ' + (e.message || e)); }
            }

            // drag & drop
            drop.addEventListener('dragover', e => { e.preventDefault(); });
            drop.addEventListener('drop', e => {
                e.preventDefault();
                const f = e.dataTransfer?.files?.[0];
                if (f) setImageFile(f);
            });

            // choose
            fileIn.onchange = () => {
                const f = fileIn.files?.[0];
                if (f) setImageFile(f);
            };

            // clear to default
            clearBtn.onclick = () => {
                imgBitmap = null; imgW = imgH = 0;
                pos = { x: 0, y: 0 };
                zoom = 0.5; zoomEl.value = '0.5';
                rot = 0; rotEl.value = '0';
                fileIn.value = ''; fileName.textContent = '';
                usingDefault = true;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                paintPreview(); markDirty();
            };

            // pan
            canvas.addEventListener('pointerdown', e => {
                dragging = true; last = { x: e.clientX, y: e.clientY };
                canvas.setPointerCapture(e.pointerId);
            });
            canvas.addEventListener('pointermove', e => {
                if (!dragging) return;
                const dx = e.clientX - last.x, dy = e.clientY - last.y;
                last = { x: e.clientX, y: e.clientY };
                pos.x += dx; pos.y += dy;
                redraw(); markDirty();
            });
            const endDrag = e => { dragging = false; try { canvas.releasePointerCapture(e.pointerId); } catch { } };
            canvas.addEventListener('pointerup', endDrag);
            canvas.addEventListener('pointercancel', endDrag);
            canvas.addEventListener('pointerleave', endDrag);

            // sliders
            zoomEl.oninput = () => { zoom = parseFloat(zoomEl.value); redraw(); markDirty(); };
            rotEl.oninput = () => { rot = parseFloat(rotEl.value) * Math.PI / 180; redraw(); markDirty(); };

            cancelBtn.onclick = () => hideRestyle();

            // export ≤512px and ≤1MB (PNG)
            async function exportPNGMax512() {
                const BYTES_MAX = 1024 * 1024;
                let size = 512;

                async function renderTo(px) {
                    const out = ('OffscreenCanvas' in window) ? new OffscreenCanvas(px, px)
                        : Object.assign(document.createElement('canvas'), { width: px, height: px });
                    const octx = out.getContext('2d');
                    octx.clearRect(0, 0, px, px);

                    if (imgBitmap) {
                        const s = scaleForZoom();
                        octx.save();
                        // map editor offsets into output
                        octx.translate(px / 2 + (pos.x * (px / canvas.width)), px / 2 + (pos.y * (px / canvas.height)));
                        octx.rotate(rot);
                        const dw = imgW * s * (px / canvas.width);
                        const dh = imgH * s * (px / canvas.height);
                        octx.drawImage(imgBitmap, -dw / 2, -dh / 2, dw, dh);
                        octx.restore();
                    }

                    let blob;
                    if (out.convertToBlob) blob = await out.convertToBlob({ type: 'image/png' });
                    else blob = await new Promise(res => out.toBlob(res, 'image/png'));
                    const arr = new Uint8Array(await blob.arrayBuffer());
                    return arr;
                }

                let png = imgBitmap ? await renderTo(size) : null;
                while (png && png.length > BYTES_MAX && size > 192) {
                    size = Math.floor(size * 0.85);
                    png = await renderTo(size);
                }
                if (png && png.length > BYTES_MAX) throw new Error('Icon too large even after resizing');
                return { png, size };
            }

            // save
            saveBtn.onclick = async () => {
                try {
                    const fd = new FormData();
                    const beforeColor = meta.color || '#ffffff';
                    if (selectedColor && selectedColor !== beforeColor) fd.append('color', selectedColor);

                    if (usingDefault && !imgBitmap) {
                        fd.append('use_default_icon', '1');
                    } else if (imgBitmap) {
                        const { png } = await exportPNGMax512();
                        if (!png) fd.append('use_default_icon', '1');
                        else fd.append('icon', new Blob([png], { type: 'image/png' }), 'group-icon.png');
                    }

                    await fetch(`${API}/dm/conversations/${state.convId}/appearance`, { method: 'PATCH', credentials: 'include', body: fd });

                    // mirror profile's system messages
                    const my = state.meSlug || 'Someone';
                    if (selectedColor && selectedColor !== beforeColor) {
                        await api(`/dm/conversations/${state.convId}/messages`, {
                            method: 'POST',
                            body: { text: `${my} changed group color to ${selectedColorKey || selectedColor}.`, kind: 'system' }
                        });
                    }
                    if (imgBitmap) {
                        await api(`/dm/conversations/${state.convId}/messages`, { method: 'POST', body: { text: `${my} changed the group icon.`, kind: 'system' } });
                    } else if (usingDefault) {
                        await api(`/dm/conversations/${state.convId}/messages`, { method: 'POST', body: { text: `${my} changed the group icon to default.`, kind: 'system' } });
                    }

                    await fetchConvMeta(state.convId);
                    await loadConversations({ blockingMeta: true });
                    hideRestyle();
                } catch (e) {
                    alert(e.detail || e.message || e);
                }
            };

            // initial paint
            paintPreview();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        /* ---------------- wire UI ---------------- */
        $('btn-attach').onclick = () => $('file').click();
        $('file').onchange = async e => { await handleFileInput(e.target.files); e.target.value = ''; };
        $('btn-send').onclick = sendMessage;
        $('text').addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

        const voice = $('btn-voice');
        const startRec = e => { e.preventDefault(); voice.textContent = 'Recording… release to stop'; startRecording(); };
        const stopRec = e => { e.preventDefault(); voice.textContent = 'Hold to record'; stopRecording(false); };
        voice.addEventListener('pointerdown', startRec);
        voice.addEventListener('pointerup', stopRec);
        voice.addEventListener('pointercancel', stopRec);
        voice.addEventListener('mouseleave', () => { if (state.recording.active) stopRec(new Event('pointerup')); });

        async function sendMessage() {
            if (!state.convId || state.uploading) return;
            let text = $('text').value;
            if (!text && state.pendingFiles.length === 0) return;
            if (text.length > 10000) { alert('Message is over 10,000 characters. Please shorten it.'); return; }
            text = text.trim();

            const fd = new FormData();
            fd.append('text', text);
            state.pendingFiles.forEach((f, i) => {
                const blob = new Blob([f.buf], { type: f.type || 'application/octet-stream' });
                const name = f.name || `file-${i}`;
                fd.append('files', blob, name);
                if (f.encoding) fd.append(`encoding_${name}`, f.encoding);
            });

            state.uploading = true;
            try {
                const r = await fetch(`${API}/dm/conversations/${state.convId}/messages`, { method: 'POST', credentials: 'include', body: fd });
                const t = await r.text(); if (!r.ok) throw new Error(t || r.statusText);
                const j = JSON.parse(t);
                if (j && j.id) state.lastMsgId = Math.max(state.lastMsgId, j.id | 0);
                $('text').value = ''; state.pendingFiles = []; refreshChips();
                await fetchAfter(state.lastMsgId);
                loadConversations().catch(() => { });
                if (nearBottom()) { await afterPaint(); scrollToBottom(); }
            } catch (e) { alert(e.message || e); }
            finally { state.uploading = false; }
        }

        /* ---------------- boot ---------------- */
        (async () => {
            await getMe();
            loadMetaCache();

            // normalize URL user slug
            const urlMatch = location.pathname.match(/\/user\/([^\/]+)\/messages/i);
            const urlSlug = urlMatch ? decodeURIComponent(urlMatch[1]) : '';
            if (state.meSlug && urlSlug && urlSlug.toLowerCase() !== state.meSlug.toLowerCase()) {
                history.replaceState(null, '', `/user/${encodeURIComponent(state.meSlug)}/messages`);
            }

            await loadConversations({ blockingMeta: true });
            const last = loadLastDM();
            if (last && (last.meId | 0) === (state.meId | 0)) {
                const exists = state.allConvs.find(c => (c.id | 0) === (last.convId | 0));
                if (exists) { await openConversation(exists.id); return; }
            }
        })();

        /* ---------------- recording impl ---------------- */
        async function startRecording() {
            if (state.recording.active) return;
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const rec = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus', bitsPerSecond: 48000 });
            state.recording = { active: true, chunks: [], size: 0, rec, warnShown: false };

            rec.ondataavailable = (e) => {
                if (!e.data || !e.data.size) return;
                state.recording.chunks.push(e.data); state.recording.size += e.data.size;
                if (!state.recording.warnShown && state.recording.size > 850 * 1024) { recWarn.style.display = ''; recWarn.textContent = 'Approaching 1MB limit…'; state.recording.warnShown = true; }
                if (state.recording.size > 990 * 1024) { stopRecording(true); }
            };
            rec.onstop = async () => {
                recWarn.style.display = 'none';
                const blob = new Blob(state.recording.chunks, { type: 'audio/webm;codecs=opus' });
                try { stream.getTracks().forEach(t => t.stop()); } catch { }
                if (!blob.size) { state.recording = { active: false, chunks: [], size: 0, rec: null, warnShown: false }; return; }
                try {
                    const ab = await blob.arrayBuffer();
                    const { buf, encoding } = await gzipBytes(new Uint8Array(ab));
                    if (buf.length > MAX) throw new Error('Voice message too large');
                    addPendingFile({ name: 'voice.webm', type: 'audio/webm', buf, size: buf.length, encoding });
                } catch (e) { alert(e.message || e); }
                state.recording = { active: false, chunks: [], size: 0, rec: null, warnShown: false };
            };
            rec.start(200);
        }
        function stopRecording(force = false) {
            const r = state.recording.rec;
            if (r && r.state !== 'inactive') { try { r.stop(); } catch { } }
            state.recording.active = false;
            if (force) recWarn.textContent = 'Stopped to keep under 1MB.';
        }
    })();
</script>
